"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reactflow";
exports.ids = ["vendor-chunks/@reactflow"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reactflow/background/dist/esm/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@reactflow/background/dist/esm/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background$1),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var _reactflow_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reactflow/core */ \"(ssr)/./node_modules/@reactflow/core/dist/esm/index.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/shallow.mjs\");\n\n\n\n\nvar BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nfunction LinePattern({ color, dimensions, lineWidth }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        stroke: color,\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`\n    });\n}\nfunction DotPattern({ color, radius }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        fill: color\n    });\n}\nconst defaultColor = {\n    [BackgroundVariant.Dots]: \"#91919a\",\n    [BackgroundVariant.Lines]: \"#eee\",\n    [BackgroundVariant.Cross]: \"#e2e2e2\"\n};\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction Background({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 2, color, style, className }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { transform, patternId } = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_2__.useStore)(selector, zustand_shallow__WEBPACK_IMPORTED_MODULE_3__.shallow);\n    const patternColor = color || defaultColor[variant];\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const patternOffset = isDots ? [\n        scaledSize / offset,\n        scaledSize / offset\n    ] : [\n        patternDimensions[0] / offset,\n        patternDimensions[1] / offset\n    ];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__background\",\n            className\n        ]),\n        style: {\n            ...style,\n            position: \"absolute\",\n            width: \"100%\",\n            height: \"100%\",\n            top: 0,\n            left: 0\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pattern\", {\n        id: patternId + id,\n        x: transform[0] % scaledGap[0],\n        y: transform[1] % scaledGap[1],\n        width: scaledGap[0],\n        height: scaledGap[1],\n        patternUnits: \"userSpaceOnUse\",\n        patternTransform: `translate(-${patternOffset[0]},-${patternOffset[1]})`\n    }, isDots ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DotPattern, {\n        color: patternColor,\n        radius: scaledSize / offset\n    }) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LinePattern, {\n        dimensions: patternDimensions,\n        color: patternColor,\n        lineWidth: lineWidth\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        x: \"0\",\n        y: \"0\",\n        width: \"100%\",\n        height: \"100%\",\n        fill: `url(#${patternId + id})`\n    }));\n}\nBackground.displayName = \"Background\";\nvar Background$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(Background);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0Zmxvdy9iYWNrZ3JvdW5kL2Rpc3QvZXNtL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNEM7QUFDbEI7QUFDaUI7QUFDRDtBQUUxQyxJQUFJTTtBQUNILFVBQVVBLGlCQUFpQjtJQUN4QkEsaUJBQWlCLENBQUMsUUFBUSxHQUFHO0lBQzdCQSxpQkFBaUIsQ0FBQyxPQUFPLEdBQUc7SUFDNUJBLGlCQUFpQixDQUFDLFFBQVEsR0FBRztBQUNqQyxHQUFHQSxxQkFBc0JBLENBQUFBLG9CQUFvQixDQUFDO0FBRTlDLFNBQVNDLFlBQVksRUFBRUMsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRTtJQUNqRCxxQkFBUVYsZ0RBQW1CLENBQUMsUUFBUTtRQUFFWSxRQUFRSjtRQUFPSyxhQUFhSDtRQUFXSSxHQUFHLENBQUMsQ0FBQyxFQUFFTCxVQUFVLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFQSxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRUEsVUFBVSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRUEsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQUM7QUFDMUs7QUFDQSxTQUFTTSxXQUFXLEVBQUVQLEtBQUssRUFBRVEsTUFBTSxFQUFFO0lBQ2pDLHFCQUFPaEIsZ0RBQW1CLENBQUMsVUFBVTtRQUFFaUIsSUFBSUQ7UUFBUUUsSUFBSUY7UUFBUUcsR0FBR0g7UUFBUUksTUFBTVo7SUFBTTtBQUMxRjtBQUVBLE1BQU1hLGVBQWU7SUFDakIsQ0FBQ2Ysa0JBQWtCZ0IsSUFBSSxDQUFDLEVBQUU7SUFDMUIsQ0FBQ2hCLGtCQUFrQmlCLEtBQUssQ0FBQyxFQUFFO0lBQzNCLENBQUNqQixrQkFBa0JrQixLQUFLLENBQUMsRUFBRTtBQUMvQjtBQUNBLE1BQU1DLGNBQWM7SUFDaEIsQ0FBQ25CLGtCQUFrQmdCLElBQUksQ0FBQyxFQUFFO0lBQzFCLENBQUNoQixrQkFBa0JpQixL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QUN6QixJQUFJQyw2QkFBZTVELDJDQUFJQSxDQUFDOEI7QUFFaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5kLW1hcC8uL25vZGVfbW9kdWxlcy9AcmVhY3RmbG93L2JhY2tncm91bmQvZGlzdC9lc20vaW5kZXgubWpzPzllYWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IG1lbW8sIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjYyBmcm9tICdjbGFzc2NhdCc7XG5pbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0ByZWFjdGZsb3cvY29yZSc7XG5pbXBvcnQgeyBzaGFsbG93IH0gZnJvbSAnenVzdGFuZC9zaGFsbG93JztcblxudmFyIEJhY2tncm91bmRWYXJpYW50O1xuKGZ1bmN0aW9uIChCYWNrZ3JvdW5kVmFyaWFudCkge1xuICAgIEJhY2tncm91bmRWYXJpYW50W1wiTGluZXNcIl0gPSBcImxpbmVzXCI7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJEb3RzXCJdID0gXCJkb3RzXCI7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJDcm9zc1wiXSA9IFwiY3Jvc3NcIjtcbn0pKEJhY2tncm91bmRWYXJpYW50IHx8IChCYWNrZ3JvdW5kVmFyaWFudCA9IHt9KSk7XG5cbmZ1bmN0aW9uIExpbmVQYXR0ZXJuKHsgY29sb3IsIGRpbWVuc2lvbnMsIGxpbmVXaWR0aCB9KSB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IHN0cm9rZTogY29sb3IsIHN0cm9rZVdpZHRoOiBsaW5lV2lkdGgsIGQ6IGBNJHtkaW1lbnNpb25zWzBdIC8gMn0gMCBWJHtkaW1lbnNpb25zWzFdfSBNMCAke2RpbWVuc2lvbnNbMV0gLyAyfSBIJHtkaW1lbnNpb25zWzBdfWAgfSkpO1xufVxuZnVuY3Rpb24gRG90UGF0dGVybih7IGNvbG9yLCByYWRpdXMgfSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHsgY3g6IHJhZGl1cywgY3k6IHJhZGl1cywgcjogcmFkaXVzLCBmaWxsOiBjb2xvciB9KTtcbn1cblxuY29uc3QgZGVmYXVsdENvbG9yID0ge1xuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzXTogJyM5MTkxOWEnLFxuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc106ICcjZWVlJyxcbiAgICBbQmFja2dyb3VuZFZhcmlhbnQuQ3Jvc3NdOiAnI2UyZTJlMicsXG59O1xuY29uc3QgZGVmYXVsdFNpemUgPSB7XG4gICAgW0JhY2tncm91bmRWYXJpYW50LkRvdHNdOiAxLFxuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc106IDEsXG4gICAgW0JhY2tncm91bmRWYXJpYW50LkNyb3NzXTogNixcbn07XG5jb25zdCBzZWxlY3RvciA9IChzKSA9PiAoeyB0cmFuc2Zvcm06IHMudHJhbnNmb3JtLCBwYXR0ZXJuSWQ6IGBwYXR0ZXJuLSR7cy5yZklkfWAgfSk7XG5mdW5jdGlvbiBCYWNrZ3JvdW5kKHsgaWQsIHZhcmlhbnQgPSBCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzLCBcbi8vIG9ubHkgdXNlZCBmb3IgZG90cyBhbmQgY3Jvc3NcbmdhcCA9IDIwLCBcbi8vIG9ubHkgdXNlZCBmb3IgbGluZXMgYW5kIGNyb3NzXG5zaXplLCBsaW5lV2lkdGggPSAxLCBvZmZzZXQgPSAyLCBjb2xvciwgc3R5bGUsIGNsYXNzTmFtZSwgfSkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IHRyYW5zZm9ybSwgcGF0dGVybklkIH0gPSB1c2VTdG9yZShzZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgY29uc3QgcGF0dGVybkNvbG9yID0gY29sb3IgfHwgZGVmYXVsdENvbG9yW3ZhcmlhbnRdO1xuICAgIGNvbnN0IHBhdHRlcm5TaXplID0gc2l6ZSB8fCBkZWZhdWx0U2l6ZVt2YXJpYW50XTtcbiAgICBjb25zdCBpc0RvdHMgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzO1xuICAgIGNvbnN0IGlzQ3Jvc3MgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Dcm9zcztcbiAgICBjb25zdCBnYXBYWSA9IEFycmF5LmlzQXJyYXkoZ2FwKSA/IGdhcCA6IFtnYXAsIGdhcF07XG4gICAgY29uc3Qgc2NhbGVkR2FwID0gW2dhcFhZWzBdICogdHJhbnNmb3JtWzJdIHx8IDEsIGdhcFhZWzFdICogdHJhbnNmb3JtWzJdIHx8IDFdO1xuICAgIGNvbnN0IHNjYWxlZFNpemUgPSBwYXR0ZXJuU2l6ZSAqIHRyYW5zZm9ybVsyXTtcbiAgICBjb25zdCBwYXR0ZXJuRGltZW5zaW9ucyA9IGlzQ3Jvc3MgPyBbc2NhbGVkU2l6ZSwgc2NhbGVkU2l6ZV0gOiBzY2FsZWRHYXA7XG4gICAgY29uc3QgcGF0dGVybk9mZnNldCA9IGlzRG90c1xuICAgICAgICA/IFtzY2FsZWRTaXplIC8gb2Zmc2V0LCBzY2FsZWRTaXplIC8gb2Zmc2V0XVxuICAgICAgICA6IFtwYXR0ZXJuRGltZW5zaW9uc1swXSAvIG9mZnNldCwgcGF0dGVybkRpbWVuc2lvbnNbMV0gLyBvZmZzZXRdO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19iYWNrZ3JvdW5kJywgY2xhc3NOYW1lXSksIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgfSwgcmVmOiByZWYsIFwiZGF0YS10ZXN0aWRcIjogXCJyZl9fYmFja2dyb3VuZFwiIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXR0ZXJuXCIsIHsgaWQ6IHBhdHRlcm5JZCArIGlkLCB4OiB0cmFuc2Zvcm1bMF0gJSBzY2FsZWRHYXBbMF0sIHk6IHRyYW5zZm9ybVsxXSAlIHNjYWxlZEdhcFsxXSwgd2lkdGg6IHNjYWxlZEdhcFswXSwgaGVpZ2h0OiBzY2FsZWRHYXBbMV0sIHBhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLCBwYXR0ZXJuVHJhbnNmb3JtOiBgdHJhbnNsYXRlKC0ke3BhdHRlcm5PZmZzZXRbMF19LC0ke3BhdHRlcm5PZmZzZXRbMV19KWAgfSwgaXNEb3RzID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRG90UGF0dGVybiwgeyBjb2xvcjogcGF0dGVybkNvbG9yLCByYWRpdXM6IHNjYWxlZFNpemUgLyBvZmZzZXQgfSkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluZVBhdHRlcm4sIHsgZGltZW5zaW9uczogcGF0dGVybkRpbWVuc2lvbnMsIGNvbG9yOiBwYXR0ZXJuQ29sb3IsIGxpbmVXaWR0aDogbGluZVdpZHRoIH0pKSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHsgeDogXCIwXCIsIHk6IFwiMFwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIGZpbGw6IGB1cmwoIyR7cGF0dGVybklkICsgaWR9KWAgfSkpKTtcbn1cbkJhY2tncm91bmQuZGlzcGxheU5hbWUgPSAnQmFja2dyb3VuZCc7XG52YXIgQmFja2dyb3VuZCQxID0gbWVtbyhCYWNrZ3JvdW5kKTtcblxuZXhwb3J0IHsgQmFja2dyb3VuZCQxIGFzIEJhY2tncm91bmQsIEJhY2tncm91bmRWYXJpYW50IH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJtZW1vIiwidXNlUmVmIiwiY2MiLCJ1c2VTdG9yZSIsInNoYWxsb3ciLCJCYWNrZ3JvdW5kVmFyaWFudCIsIkxpbmVQYXR0ZXJuIiwiY29sb3IiLCJkaW1lbnNpb25zIiwibGluZVdpZHRoIiwiY3JlYXRlRWxlbWVudCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwiZCIsIkRvdFBhdHRlcm4iLCJyYWRpdXMiLCJjeCIsImN5IiwiciIsImZpbGwiLCJkZWZhdWx0Q29sb3IiLCJEb3RzIiwiTGluZXMiLCJDcm9zcyIsImRlZmF1bHRTaXplIiwic2VsZWN0b3IiLCJzIiwidHJhbnNmb3JtIiwicGF0dGVybklkIiwicmZJZCIsIkJhY2tncm91bmQiLCJpZCIsInZhcmlhbnQiLCJnYXAiLCJzaXplIiwib2Zmc2V0Iiwic3R5bGUiLCJjbGFzc05hbWUiLCJyZWYiLCJwYXR0ZXJuQ29sb3IiLCJwYXR0ZXJuU2l6ZSIsImlzRG90cyIsImlzQ3Jvc3MiLCJnYXBYWSIsIkFycmF5IiwiaXNBcnJheSIsInNjYWxlZEdhcCIsInNjYWxlZFNpemUiLCJwYXR0ZXJuRGltZW5zaW9ucyIsInBhdHRlcm5PZmZzZXQiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwidG9wIiwibGVmdCIsIngiLCJ5IiwicGF0dGVyblVuaXRzIiwicGF0dGVyblRyYW5zZm9ybSIsImRpc3BsYXlOYW1lIiwiQmFja2dyb3VuZCQxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reactflow/background/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reactflow/controls/dist/esm/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@reactflow/controls/dist/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls$1)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var _reactflow_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reactflow/core */ \"(ssr)/./node_modules/@reactflow/core/dist/esm/index.mjs\");\n\n\n\n\nfunction PlusIcon() {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n    }));\n}\nfunction MinusIcon() {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M0 0h32v4.2H0z\"\n    }));\n}\nfunction FitViewIcon() {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n    }));\n}\nfunction LockIcon() {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n    }));\n}\nfunction UnlockIcon() {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n    }));\n}\nconst ControlButton = ({ children, className, ...rest })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__controls-button\",\n            className\n        ]),\n        ...rest\n    }, children);\nControlButton.displayName = \"ControlButton\";\nconst selector = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom\n    });\nconst Controls = ({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = \"bottom-left\" })=>{\n    const store = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_2__.useStoreApi)();\n    const [isVisible, setIsVisible] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const { isInteractive, minZoomReached, maxZoomReached } = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_2__.useStore)(selector, zustand_shallow__WEBPACK_IMPORTED_MODULE_3__.shallow);\n    const { zoomIn, zoomOut, fitView } = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_2__.useReactFlow)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setIsVisible(true);\n    }, []);\n    if (!isVisible) {\n        return null;\n    }\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_reactflow_core__WEBPACK_IMPORTED_MODULE_2__.Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__controls\",\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\"\n    }, showZoom && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ControlButton, {\n        onClick: onZoomInHandler,\n        className: \"react-flow__controls-zoomin\",\n        title: \"zoom in\",\n        \"aria-label\": \"zoom in\",\n        disabled: maxZoomReached\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PlusIcon, null)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ControlButton, {\n        onClick: onZoomOutHandler,\n        className: \"react-flow__controls-zoomout\",\n        title: \"zoom out\",\n        \"aria-label\": \"zoom out\",\n        disabled: minZoomReached\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MinusIcon, null))), showFitView && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ControlButton, {\n        className: \"react-flow__controls-fitview\",\n        onClick: onFitViewHandler,\n        title: \"fit view\",\n        \"aria-label\": \"fit view\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FitViewIcon, null)), showInteractive && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ControlButton, {\n        className: \"react-flow__controls-interactive\",\n        onClick: onToggleInteractivity,\n        title: \"toggle interactivity\",\n        \"aria-label\": \"toggle interactivity\"\n    }, isInteractive ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(UnlockIcon, null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LockIcon, null)), children);\n};\nControls.displayName = \"Controls\";\nvar Controls$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(Controls);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0Zmxvdy9jb250cm9scy9kaXN0L2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlEO0FBQy9CO0FBQ2dCO0FBQ21DO0FBRTdFLFNBQVNVO0lBQ0wscUJBQVFWLGdEQUFtQixDQUFDLE9BQU87UUFBRVksT0FBTztRQUE4QkMsU0FBUztJQUFZLGlCQUMzRmIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFYyxHQUFHO0lBQXdFO0FBQ2pIO0FBRUEsU0FBU0M7SUFDTCxxQkFBUWYsZ0RBQW1CLENBQUMsT0FBTztRQUFFWSxPQUFPO1FBQThCQyxTQUFTO0lBQVcsaUJBQzFGYixnREFBbUIsQ0FBQyxRQUFRO1FBQUVjLEdBQUc7SUFBaUI7QUFDMUQ7QUFFQSxTQUFTRTtJQUNMLHFCQUFRaEIsZ0RBQW1CLENBQUMsT0FBTztRQUFFWSxPQUFPO1FBQThCQyxTQUFTO0lBQVksaUJBQzNGYixnREFBbUIsQ0FBQyxRQUFRO1FBQUVjLEdBQUc7SUFBOFg7QUFDdmE7QUFFQSxTQUFTRztJQUNMLHFCQUFRakIsZ0RBQW1CLENBQUMsT0FBTztRQUFFWSxPQUFPO1FBQThCQyxTQUFTO0lBQVksaUJBQzNGYixnREFBbUIsQ0FBQyxRQUFRO1FBQUVjLEdBQUc7SUFBaWM7QUFDMWU7QUFFQSxTQUFTSTtJQUNMLHFCQUFRbEIsZ0RBQW1CLENBQUMsT0FBTztRQUFFWSxPQUFPO1FBQThCQyxTQUFTO0lBQVksaUJBQzNGYixnREFBbUIsQ0FBQyxRQUFRO1FBQUVjLEdBQUc7SUFBdVk7QUFDaGI7QUFFQSxNQUFNSyxnQkFBZ0IsQ0FBQyxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxNQUFNLGlCQUFNdEIsZ0RBQW1CLENBQUMsVUFBVTtRQUFFdUIsTUFBTTtRQUFVRixXQUFXakIsb0RBQUVBLENBQUM7WUFBQztZQUErQmlCO1NBQVU7UUFBRyxHQUFHQyxJQUFJO0lBQUMsR0FBR0Y7QUFDbkxELGNBQWNLLFdBQVcsR0FBRztBQUU1QixNQUFNQyxXQUFXLENBQUNDLElBQU87UUFDckJDLGVBQWVELEVBQUVFLGNBQWMsSUFBSUYsRUFBRUcsZ0JBQWdCLElBQUlILEVBQUVJLGtCQUFrQjtRQUM3RUMsZ0JBQWdCTCxFQUFFTSxTQUFTLENBQUMsRUFBRSxJQUFJTixFQUFFTyxPQUFPO1FBQzNDQyxnQkFBZ0JSLEVBQUVNLFNBQVMsQ0FBQyxFQUFFLElBQUlOLEVBQUVTLE9BQU87SUFDL0M7QUFDQSxNQUFNQyxXQUFXLENBQUMsRUFBRUMsS0FBSyxFQUFFQyxXQUFXLElBQUksRUFBRUMsY0FBYyxJQUFJLEVBQUVDLGtCQUFrQixJQUFJLEVBQUVDLGNBQWMsRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsbUJBQW1CLEVBQUV4QixTQUFTLEVBQUVELFFBQVEsRUFBRTBCLFdBQVcsYUFBYSxFQUFHO0lBQ3pNLE1BQU1DLFFBQVF6Qyw0REFBV0E7SUFDekIsTUFBTSxDQUFDMEMsV0FBV0MsYUFBYSxHQUFHL0MsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxFQUFFeUIsYUFBYSxFQUFFSSxjQUFjLEVBQUVHLGNBQWMsRUFBRSxHQUFHM0IseURBQVFBLENBQUNrQixVQUFVcEIsb0RBQU9BO0lBQ3BGLE1BQU0sRUFBRTZDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUUsR0FBRzVDLDZEQUFZQTtJQUNqREwsZ0RBQVNBLENBQUM7UUFDTjhDLGFBQWE7SUFDakIsR0FBRyxFQUFFO0lBQ0wsSUFBSSxDQUFDRCxXQUFXO1FBQ1osT0FBTztJQUNYO0lBQ0EsTUFBTUssa0JBQWtCO1FBQ3BCSDtRQUNBUjtJQUNKO0lBQ0EsTUFBTVksbUJBQW1CO1FBQ3JCSDtRQUNBUjtJQUNKO0lBQ0EsTUFBTVksbUJBQW1CO1FBQ3JCSCxRQUFRWDtRQUNSRztJQUNKO0lBQ0EsTUFBTVksd0JBQXdCO1FBQzFCVCxNQUFNVSxRQUFRLENBQUM7WUFDWDdCLGdCQUFnQixDQUFDRDtZQUNqQkUsa0JBQWtCLENBQUNGO1lBQ25CRyxvQkFBb0IsQ0FBQ0g7UUFDekI7UUFDQWtCLHNCQUFzQixDQUFDbEI7SUFDM0I7SUFDQSxxQkFBUTNCLGdEQUFtQixDQUFDUyxrREFBS0EsRUFBRTtRQUFFWSxXQUFXakIsb0RBQUVBLENBQUM7WUFBQztZQUF3QmlCO1NBQVU7UUFBR3lCLFVBQVVBO1FBQVVULE9BQU9BO1FBQU8sZUFBZTtJQUFlLEdBQ3JKQywwQkFBYXRDLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLG9CQUM3Q0EsZ0RBQW1CLENBQUNtQixlQUFlO1FBQUV3QyxTQUFTTjtRQUFpQmhDLFdBQVc7UUFBK0J1QyxPQUFPO1FBQVcsY0FBYztRQUFXQyxVQUFVM0I7SUFBZSxpQkFDektsQyxnREFBbUIsQ0FBQ1UsVUFBVSxzQkFDbENWLGdEQUFtQixDQUFDbUIsZUFBZTtRQUFFd0MsU0FBU0w7UUFBa0JqQyxXQUFXO1FBQWdDdUMsT0FBTztRQUFZLGNBQWM7UUFBWUMsVUFBVTlCO0lBQWUsaUJBQzdLL0IsZ0RBQW1CLENBQUNlLFdBQVcsU0FDdkN3Qiw2QkFBZ0J2QyxnREFBbUIsQ0FBQ21CLGVBQWU7UUFBRUUsV0FBVztRQUFnQ3NDLFNBQVNKO1FBQWtCSyxPQUFPO1FBQVksY0FBYztJQUFXLGlCQUNuSzVELGdEQUFtQixDQUFDZ0IsYUFBYSxRQUNyQ3dCLGlDQUFvQnhDLGdEQUFtQixDQUFDbUIsZUFBZTtRQUFFRSxXQUFXO1FBQW9Dc0MsU0FBU0g7UUFBdUJJLE9BQU87UUFBd0IsY0FBYztJQUF1QixHQUFHakMsOEJBQWdCM0IsZ0RBQW1CLENBQUNrQixZQUFZLHNCQUFRbEIsZ0RBQW1CLENBQUNpQixVQUFVLFFBQ3JTRztBQUNSO0FBQ0FnQixTQUFTWixXQUFXLEdBQUc7QUFDdkIsSUFBSXNDLDJCQUFhN0QsMkNBQUlBLENBQUNtQztBQUUyQiIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmQtbWFwLy4vbm9kZV9tb2R1bGVzL0ByZWFjdGZsb3cvY29udHJvbHMvZGlzdC9lc20vaW5kZXgubWpzP2ZkNjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IG1lbW8sIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2MgZnJvbSAnY2xhc3NjYXQnO1xuaW1wb3J0IHsgc2hhbGxvdyB9IGZyb20gJ3p1c3RhbmQvc2hhbGxvdyc7XG5pbXBvcnQgeyB1c2VTdG9yZUFwaSwgdXNlU3RvcmUsIHVzZVJlYWN0RmxvdywgUGFuZWwgfSBmcm9tICdAcmVhY3RmbG93L2NvcmUnO1xuXG5mdW5jdGlvbiBQbHVzSWNvbigpIHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMlwiIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMzIgMTguMTMzSDE4LjEzM1YzMmgtNC4yNjZWMTguMTMzSDB2LTQuMjY2aDEzLjg2N1YwaDQuMjY2djEzLjg2N0gzMnpcIiB9KSkpO1xufVxuXG5mdW5jdGlvbiBNaW51c0ljb24oKSB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMzIgNVwiIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMCAwaDMydjQuMkgwelwiIH0pKSk7XG59XG5cbmZ1bmN0aW9uIEZpdFZpZXdJY29uKCkge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDMwXCIgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0zLjY5MiA0LjYzYzAtLjUzLjQtLjkzOC45MzktLjkzOGg1LjIxNVYwSDQuNzA4QzIuMTMgMCAwIDIuMDU0IDAgNC42M3Y1LjIxNmgzLjY5MlY0LjYzMXpNMjcuMzU0IDBoLTUuMnYzLjY5Mmg1LjE3Yy41MyAwIC45ODQuNC45ODQuOTM5djUuMjE1SDMyVjQuNjMxQTQuNjI0IDQuNjI0IDAgMDAyNy4zNTQgMHptLjk1NCAyNC44M2MwIC41MzItLjQuOTQtLjkzOS45NGgtNS4yMTV2My43NjhoNS4yMTVjMi41NzcgMCA0LjYzMS0yLjEzIDQuNjMxLTQuNzA3di01LjEzOWgtMy42OTJ2NS4xMzl6bS0yMy42NzcuOTRjLS41MzEgMC0uOTM5LS40LS45MzktLjk0di01LjEzOEgwdjUuMTM5YzAgMi41NzcgMi4xMyA0LjcwNyA0LjcwOCA0LjcwN2g1LjEzOFYyNS43N0g0LjYzMXpcIiB9KSkpO1xufVxuXG5mdW5jdGlvbiBMb2NrSWNvbigpIHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMjEuMzMzIDEwLjY2N0gxOS44MVY3LjYxOUMxOS44MSAzLjQyOSAxNi4zOCAwIDEyLjE5IDAgOCAwIDQuNTcxIDMuNDI5IDQuNTcxIDcuNjE5djMuMDQ4SDMuMDQ4QTMuMDU2IDMuMDU2IDAgMDAwIDEzLjcxNHYxNS4yMzhBMy4wNTYgMy4wNTYgMCAwMDMuMDQ4IDMyaDE4LjI4NWEzLjA1NiAzLjA1NiAwIDAwMy4wNDgtMy4wNDhWMTMuNzE0YTMuMDU2IDMuMDU2IDAgMDAtMy4wNDgtMy4wNDd6TTEyLjE5IDI0LjUzM2EzLjA1NiAzLjA1NiAwIDAxLTMuMDQ3LTMuMDQ3IDMuMDU2IDMuMDU2IDAgMDEzLjA0Ny0zLjA0OCAzLjA1NiAzLjA1NiAwIDAxMy4wNDggMy4wNDggMy4wNTYgMy4wNTYgMCAwMS0zLjA0OCAzLjA0N3ptNC43MjQtMTMuODY2SDcuNDY3VjcuNjE5YzAtMi41OSAyLjEzMy00LjcyNCA0LjcyMy00LjcyNCAyLjU5MSAwIDQuNzI0IDIuMTMzIDQuNzI0IDQuNzI0djMuMDQ4elwiIH0pKSk7XG59XG5cbmZ1bmN0aW9uIFVubG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMjUgMzJcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwYy00LjExNCAxLjgyOC0xLjM3IDIuMTMzLjMwNSAyLjQzOCAxLjY3Ni4zMDUgNC40MiAyLjU5IDQuNDIgNS4xODF2My4wNDhIMy4wNDdBMy4wNTYgMy4wNTYgMCAwMDAgMTMuNzE0djE1LjIzOEEzLjA1NiAzLjA1NiAwIDAwMy4wNDggMzJoMTguMjg1YTMuMDU2IDMuMDU2IDAgMDAzLjA0OC0zLjA0OFYxMy43MTRhMy4wNTYgMy4wNTYgMCAwMC0zLjA0OC0zLjA0N3pNMTIuMTkgMjQuNTMzYTMuMDU2IDMuMDU2IDAgMDEtMy4wNDctMy4wNDcgMy4wNTYgMy4wNTYgMCAwMTMuMDQ3LTMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEzLjA0OCAzLjA0OCAzLjA1NiAzLjA1NiAwIDAxLTMuMDQ4IDMuMDQ3elwiIH0pKSk7XG59XG5cbmNvbnN0IENvbnRyb2xCdXR0b24gPSAoeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5yZXN0IH0pID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2NvbnRyb2xzLWJ1dHRvbicsIGNsYXNzTmFtZV0pLCAuLi5yZXN0IH0sIGNoaWxkcmVuKSk7XG5Db250cm9sQnV0dG9uLmRpc3BsYXlOYW1lID0gJ0NvbnRyb2xCdXR0b24nO1xuXG5jb25zdCBzZWxlY3RvciA9IChzKSA9PiAoe1xuICAgIGlzSW50ZXJhY3RpdmU6IHMubm9kZXNEcmFnZ2FibGUgfHwgcy5ub2Rlc0Nvbm5lY3RhYmxlIHx8IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIG1pblpvb21SZWFjaGVkOiBzLnRyYW5zZm9ybVsyXSA8PSBzLm1pblpvb20sXG4gICAgbWF4Wm9vbVJlYWNoZWQ6IHMudHJhbnNmb3JtWzJdID49IHMubWF4Wm9vbSxcbn0pO1xuY29uc3QgQ29udHJvbHMgPSAoeyBzdHlsZSwgc2hvd1pvb20gPSB0cnVlLCBzaG93Rml0VmlldyA9IHRydWUsIHNob3dJbnRlcmFjdGl2ZSA9IHRydWUsIGZpdFZpZXdPcHRpb25zLCBvblpvb21Jbiwgb25ab29tT3V0LCBvbkZpdFZpZXcsIG9uSW50ZXJhY3RpdmVDaGFuZ2UsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIHBvc2l0aW9uID0gJ2JvdHRvbS1sZWZ0JywgfSkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBbaXNWaXNpYmxlLCBzZXRJc1Zpc2libGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgaXNJbnRlcmFjdGl2ZSwgbWluWm9vbVJlYWNoZWQsIG1heFpvb21SZWFjaGVkIH0gPSB1c2VTdG9yZShzZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgY29uc3QgeyB6b29tSW4sIHpvb21PdXQsIGZpdFZpZXcgfSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldElzVmlzaWJsZSh0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKCFpc1Zpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9uWm9vbUluSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgem9vbUluKCk7XG4gICAgICAgIG9uWm9vbUluPy4oKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uWm9vbU91dEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHpvb21PdXQoKTtcbiAgICAgICAgb25ab29tT3V0Py4oKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRml0Vmlld0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGZpdFZpZXcoZml0Vmlld09wdGlvbnMpO1xuICAgICAgICBvbkZpdFZpZXc/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25Ub2dnbGVJbnRlcmFjdGl2aXR5ID0gKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBub2Rlc0RyYWdnYWJsZTogIWlzSW50ZXJhY3RpdmUsXG4gICAgICAgICAgICBub2Rlc0Nvbm5lY3RhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogIWlzSW50ZXJhY3RpdmUsXG4gICAgICAgIH0pO1xuICAgICAgICBvbkludGVyYWN0aXZlQ2hhbmdlPy4oIWlzSW50ZXJhY3RpdmUpO1xuICAgIH07XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFBhbmVsLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb250cm9scycsIGNsYXNzTmFtZV0pLCBwb3NpdGlvbjogcG9zaXRpb24sIHN0eWxlOiBzdHlsZSwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19jb250cm9sc1wiIH0sXG4gICAgICAgIHNob3dab29tICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb250cm9sQnV0dG9uLCB7IG9uQ2xpY2s6IG9uWm9vbUluSGFuZGxlciwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLXpvb21pblwiLCB0aXRsZTogXCJ6b29tIGluXCIsIFwiYXJpYS1sYWJlbFwiOiBcInpvb20gaW5cIiwgZGlzYWJsZWQ6IG1heFpvb21SZWFjaGVkIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQbHVzSWNvbiwgbnVsbCkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb250cm9sQnV0dG9uLCB7IG9uQ2xpY2s6IG9uWm9vbU91dEhhbmRsZXIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy16b29tb3V0XCIsIHRpdGxlOiBcInpvb20gb3V0XCIsIFwiYXJpYS1sYWJlbFwiOiBcInpvb20gb3V0XCIsIGRpc2FibGVkOiBtaW5ab29tUmVhY2hlZCB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWludXNJY29uLCBudWxsKSkpKSxcbiAgICAgICAgc2hvd0ZpdFZpZXcgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udHJvbEJ1dHRvbiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtZml0dmlld1wiLCBvbkNsaWNrOiBvbkZpdFZpZXdIYW5kbGVyLCB0aXRsZTogXCJmaXQgdmlld1wiLCBcImFyaWEtbGFiZWxcIjogXCJmaXQgdmlld1wiIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEZpdFZpZXdJY29uLCBudWxsKSkpLFxuICAgICAgICBzaG93SW50ZXJhY3RpdmUgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udHJvbEJ1dHRvbiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtaW50ZXJhY3RpdmVcIiwgb25DbGljazogb25Ub2dnbGVJbnRlcmFjdGl2aXR5LCB0aXRsZTogXCJ0b2dnbGUgaW50ZXJhY3Rpdml0eVwiLCBcImFyaWEtbGFiZWxcIjogXCJ0b2dnbGUgaW50ZXJhY3Rpdml0eVwiIH0sIGlzSW50ZXJhY3RpdmUgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFVubG9ja0ljb24sIG51bGwpIDogUmVhY3QuY3JlYXRlRWxlbWVudChMb2NrSWNvbiwgbnVsbCkpKSxcbiAgICAgICAgY2hpbGRyZW4pKTtcbn07XG5Db250cm9scy5kaXNwbGF5TmFtZSA9ICdDb250cm9scyc7XG52YXIgQ29udHJvbHMkMSA9IG1lbW8oQ29udHJvbHMpO1xuXG5leHBvcnQgeyBDb250cm9sQnV0dG9uLCBDb250cm9scyQxIGFzIENvbnRyb2xzIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJtZW1vIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJjYyIsInNoYWxsb3ciLCJ1c2VTdG9yZUFwaSIsInVzZVN0b3JlIiwidXNlUmVhY3RGbG93IiwiUGFuZWwiLCJQbHVzSWNvbiIsImNyZWF0ZUVsZW1lbnQiLCJ4bWxucyIsInZpZXdCb3giLCJkIiwiTWludXNJY29uIiwiRml0Vmlld0ljb24iLCJMb2NrSWNvbiIsIlVubG9ja0ljb24iLCJDb250cm9sQnV0dG9uIiwiY2hpbGRyZW4iLCJjbGFzc05hbWUiLCJyZXN0IiwidHlwZSIsImRpc3BsYXlOYW1lIiwic2VsZWN0b3IiLCJzIiwiaXNJbnRlcmFjdGl2ZSIsIm5vZGVzRHJhZ2dhYmxlIiwibm9kZXNDb25uZWN0YWJsZSIsImVsZW1lbnRzU2VsZWN0YWJsZSIsIm1pblpvb21SZWFjaGVkIiwidHJhbnNmb3JtIiwibWluWm9vbSIsIm1heFpvb21SZWFjaGVkIiwibWF4Wm9vbSIsIkNvbnRyb2xzIiwic3R5bGUiLCJzaG93Wm9vbSIsInNob3dGaXRWaWV3Iiwic2hvd0ludGVyYWN0aXZlIiwiZml0Vmlld09wdGlvbnMiLCJvblpvb21JbiIsIm9uWm9vbU91dCIsIm9uRml0VmlldyIsIm9uSW50ZXJhY3RpdmVDaGFuZ2UiLCJwb3NpdGlvbiIsInN0b3JlIiwiaXNWaXNpYmxlIiwic2V0SXNWaXNpYmxlIiwiem9vbUluIiwiem9vbU91dCIsImZpdFZpZXciLCJvblpvb21JbkhhbmRsZXIiLCJvblpvb21PdXRIYW5kbGVyIiwib25GaXRWaWV3SGFuZGxlciIsIm9uVG9nZ2xlSW50ZXJhY3Rpdml0eSIsInNldFN0YXRlIiwiRnJhZ21lbnQiLCJvbkNsaWNrIiwidGl0bGUiLCJkaXNhYmxlZCIsIkNvbnRyb2xzJDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reactflow/controls/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reactflow/core/dist/esm/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@reactflow/core/dist/esm/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText$1),\n/* harmony export */   Handle: () => (/* binding */ Handle$1),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ReactFlow: () => (/* binding */ ReactFlow),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getMarkerEnd: () => (/* binding */ getMarkerEnd),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getRectOfNodes: () => (/* binding */ getRectOfNodes),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getTransformForBounds: () => (/* binding */ getTransformForBounds),\n/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),\n/* harmony export */   handleParentExpand: () => (/* binding */ handleParentExpand),\n/* harmony export */   internalsSymbol: () => (/* binding */ internalsSymbol),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   updateEdge: () => (/* binding */ updateEdge),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useGetPointerPosition: () => (/* binding */ useGetPointerPosition),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst errorMessages = {\n    error001: ()=>\"[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001\",\n    error002: ()=>\"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType)=>`Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: ()=>\"The React Flow parent container needs a width and a height to render the graph.\",\n    error005: ()=>\"Only child nodes can use a parent extent.\",\n    error006: ()=>\"Can't create edge. An edge needs a source and a target.\",\n    error007: (id)=>`The old edge with id=${id} does not exist.`,\n    error009: (type)=>`Marker type \"${type}\" doesn't exist.`,\n    error008: (sourceHandle, edge)=>`Couldn't create edge for ${!sourceHandle ? \"source\" : \"target\"} handle id: \"${!sourceHandle ? edge.sourceHandle : edge.targetHandle}\", edge id: ${edge.id}.`,\n    error010: ()=>\"Handle: No node id found. Make sure to only use a Handle inside a custom Node.\",\n    error011: (edgeType)=>`Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id)=>`Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`\n};\nconst zustandErrorMessage = errorMessages[\"error001\"]();\nfunction useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_4__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\nconst useStoreApi = ()=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            getState: store.getState,\n            setState: store.setState,\n            subscribe: store.subscribe,\n            destroy: store.destroy\n        }), [\n        store\n    ]);\n};\nconst selector$g = (s)=>s.userSelectionActive ? \"none\" : \"all\";\nfunction Panel({ position, children, className, style, ...rest }) {\n    const pointerEvents = useStore(selector$g);\n    const positionClasses = `${position}`.split(\"-\");\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__panel\",\n            className,\n            ...positionClasses\n        ]),\n        style: {\n            ...style,\n            pointerEvents\n        },\n        ...rest\n    }, children);\n}\nfunction Attribution({ proOptions, position = \"bottom-right\" }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://reactflow.dev/pro\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", {\n        href: \"https://reactflow.dev\",\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        \"aria-label\": \"React Flow attribution\"\n    }, \"React Flow\"));\n}\nconst EdgeText = ({ x, y, label, labelStyle = {}, labelShowBg = true, labelBgStyle = {}, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest })=>{\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        \"react-flow__edge-textwrapper\",\n        className\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (edgeRef.current) {\n            const textBbox = edgeRef.current.getBBox();\n            setEdgeTextBbox({\n                x: textBbox.x,\n                y: textBbox.y,\n                width: textBbox.width,\n                height: textBbox.height\n            });\n        }\n    }, [\n        label\n    ]);\n    if (typeof label === \"undefined\" || !label) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? \"visible\" : \"hidden\",\n        ...rest\n    }, labelShowBg && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        width: edgeTextBbox.width + 2 * labelBgPadding[0],\n        x: -labelBgPadding[0],\n        y: -labelBgPadding[1],\n        height: edgeTextBbox.height + 2 * labelBgPadding[1],\n        className: \"react-flow__edge-textbg\",\n        style: labelBgStyle,\n        rx: labelBgBorderRadius,\n        ry: labelBgBorderRadius\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"text\", {\n        className: \"react-flow__edge-text\",\n        y: edgeTextBbox.height / 2,\n        dy: \"0.3em\",\n        ref: edgeRef,\n        style: labelStyle\n    }, label), children);\n};\nvar EdgeText$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(EdgeText);\nconst getDimensions = (node)=>({\n        width: node.offsetWidth,\n        height: node.offsetHeight\n    });\nconst clamp = (val, min = 0, max = 1)=>Math.min(Math.max(val, min), max);\nconst clampPosition = (position = {\n    x: 0,\n    y: 0\n}, extent)=>({\n        x: clamp(position.x, extent[0][0], extent[1][0]),\n        y: clamp(position.y, extent[0][1], extent[1][1])\n    });\n// returns a number between 0 and 1 that represents the velocity of the movement\n// when the mouse is close to the edge of the canvas\nconst calcAutoPanVelocity = (value, min, max)=>{\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, 50) / 50;\n    } else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, 50) / 50;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds)=>{\n    const xMovement = calcAutoPanVelocity(pos.x, 35, bounds.width - 35) * 20;\n    const yMovement = calcAutoPanVelocity(pos.y, 35, bounds.height - 35) * 20;\n    return [\n        xMovement,\n        yMovement\n    ];\n};\nconst getHostForElement = (element)=>element.getRootNode?.() || window?.document;\nconst getBoundsOfBoxes = (box1, box2)=>({\n        x: Math.min(box1.x, box2.x),\n        y: Math.min(box1.y, box2.y),\n        x2: Math.max(box1.x2, box2.x2),\n        y2: Math.max(box1.y2, box2.y2)\n    });\nconst rectToBox = ({ x, y, width, height })=>({\n        x,\n        y,\n        x2: x + width,\n        y2: y + height\n    });\nconst boxToRect = ({ x, y, x2, y2 })=>({\n        x,\n        y,\n        width: x2 - x,\n        height: y2 - y\n    });\nconst nodeToRect = (node)=>({\n        ...node.positionAbsolute || {\n            x: 0,\n            y: 0\n        },\n        width: node.width || 0,\n        height: node.height || 0\n    });\nconst getBoundsOfRects = (rect1, rect2)=>boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB)=>{\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj)=>isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */ const isNumeric = (n)=>!isNaN(n) && isFinite(n);\nconst internalsSymbol = Symbol.for(\"internals\");\n// used for a11y key board controls for nodes and edges\nconst elementSelectionKeys = [\n    \"Enter\",\n    \" \",\n    \"Escape\"\n];\nconst devWarn = (id, message)=>{\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst isReactKeyboardEvent = (event)=>\"nativeEvent\" in event;\nfunction isInputDOMNode(event) {\n    const kbEvent = isReactKeyboardEvent(event) ? event.nativeEvent : event;\n    // using composed path for handling shadow dom\n    const target = kbEvent.composedPath?.()?.[0] || event.target;\n    const isInput = [\n        \"INPUT\",\n        \"SELECT\",\n        \"TEXTAREA\"\n    ].includes(target?.nodeName) || target?.hasAttribute(\"contenteditable\");\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target?.closest(\".nokey\");\n}\nconst isMouseEvent = (event)=>\"clientX\" in event;\nconst getEventPosition = (event, bounds)=>{\n    const isMouseTriggered = isMouseEvent(event);\n    const evtX = isMouseTriggered ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouseTriggered ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0)\n    };\n};\nconst isMacOs = ()=>typeof navigator !== \"undefined\" && navigator?.userAgent?.indexOf(\"Mac\") >= 0;\nconst BaseEdge = ({ id, path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth = 20 })=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        id: id,\n        style: style,\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__edge-path\",\n        markerEnd: markerEnd,\n        markerStart: markerStart\n    }), interactionWidth && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: path,\n        fill: \"none\",\n        strokeOpacity: 0,\n        strokeWidth: interactionWidth,\n        className: \"react-flow__edge-interaction\"\n    }), label && isNumeric(labelX) && isNumeric(labelY) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeText$1, {\n        x: labelX,\n        y: labelY,\n        label: label,\n        labelStyle: labelStyle,\n        labelShowBg: labelShowBg,\n        labelBgStyle: labelBgStyle,\n        labelBgPadding: labelBgPadding,\n        labelBgBorderRadius: labelBgBorderRadius\n    }) : null);\n};\nBaseEdge.displayName = \"BaseEdge\";\nconst getMarkerEnd = (markerType, markerEndId)=>{\n    if (typeof markerEndId !== \"undefined\" && markerEndId) {\n        return `url(#${markerEndId})`;\n    }\n    return typeof markerType !== \"undefined\" ? `url(#react-flow__${markerType})` : \"none\";\n};\nfunction getMouseHandler$1(id, getState, handler) {\n    return handler === undefined ? handler : (event)=>{\n        const edge = getState().edges.find((e)=>e.id === id);\n        if (edge) {\n            handler(event, {\n                ...edge\n            });\n        }\n    };\n}\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [\n        centerX,\n        centerY,\n        xOffset,\n        yOffset\n    ];\n}\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {\n    // cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n    // https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [\n        centerX,\n        centerY,\n        offsetX,\n        offsetY\n    ];\n}\nvar ConnectionMode;\n(function(ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\nvar PanOnScrollMode;\n(function(PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function(SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nvar ConnectionLineType;\n(function(ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\nvar MarkerType;\n(function(MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\nvar Position;\n(function(Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === Position.Left || pos === Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\nfunction getSimpleBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nconst SimpleBezierEdge = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n    const [path, labelX, labelY] = getSimpleBezierPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseEdge, {\n        path: path,\n        labelX: labelX,\n        labelY: labelY,\n        label: label,\n        labelStyle: labelStyle,\n        labelShowBg: labelShowBg,\n        labelBgStyle: labelBgStyle,\n        labelBgPadding: labelBgPadding,\n        labelBgBorderRadius: labelBgBorderRadius,\n        style: style,\n        markerEnd: markerEnd,\n        markerStart: markerStart,\n        interactionWidth: interactionWidth\n    });\n});\nSimpleBezierEdge.displayName = \"SimpleBezierEdge\";\nconst handleDirections = {\n    [Position.Left]: {\n        x: -1,\n        y: 0\n    },\n    [Position.Right]: {\n        x: 1,\n        y: 0\n    },\n    [Position.Top]: {\n        x: 0,\n        y: -1\n    },\n    [Position.Bottom]: {\n        x: 0,\n        y: 1\n    }\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target })=>{\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? {\n            x: 1,\n            y: 0\n        } : {\n            x: -1,\n            y: 0\n        };\n    }\n    return source.y < target.y ? {\n        x: 0,\n        y: 1\n    } : {\n        x: 0,\n        y: -1\n    };\n};\nconst distance = (a, b)=>Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n// ith this function we try to mimic a orthogonal edge routing behaviour\n// It's not as good as a real orthogonal edge routing but it's faster and good enough as a default for step and smooth step edges\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = {\n        x: source.x + sourceDir.x * offset,\n        y: source.y + sourceDir.y * offset\n    };\n    const targetGapped = {\n        x: target.x + targetDir.x * offset,\n        y: target.y + targetDir.y * offset\n    };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped\n    });\n    const dirAccessor = dir.x !== 0 ? \"x\" : \"y\";\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = {\n        x: 0,\n        y: 0\n    };\n    const targetGapOffset = {\n        x: 0,\n        y: 0\n    };\n    const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        centerX = center.x || defaultCenterX;\n        centerY = center.y || defaultCenterY;\n        //    --->\n        //    |\n        // >---\n        const verticalSplit = [\n            {\n                x: centerX,\n                y: sourceGapped.y\n            },\n            {\n                x: centerX,\n                y: targetGapped.y\n            }\n        ];\n        //    |\n        //  ---\n        //  |\n        const horizontalSplit = [\n            {\n                x: sourceGapped.x,\n                y: centerY\n            },\n            {\n                x: targetGapped.x,\n                y: centerY\n            }\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === \"x\" ? verticalSplit : horizontalSplit;\n        } else {\n            points = dirAccessor === \"x\" ? horizontalSplit : verticalSplit;\n        }\n    } else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [\n            {\n                x: sourceGapped.x,\n                y: targetGapped.y\n            }\n        ];\n        const targetSource = [\n            {\n                x: targetGapped.x,\n                y: sourceGapped.y\n            }\n        ];\n        // this handles edges with same handle positions\n        if (dirAccessor === \"x\") {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        } else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                } else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === \"x\" ? \"y\" : \"x\";\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);\n            if (flipSourceTarget) {\n                points = dirAccessor === \"x\" ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = {\n            x: sourceGapped.x + sourceGapOffset.x,\n            y: sourceGapped.y + sourceGapOffset.y\n        };\n        const targetGapPoint = {\n            x: targetGapped.x + targetGapOffset.x,\n            y: targetGapped.y + targetGapOffset.y\n        };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        } else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        {\n            x: sourceGapped.x + sourceGapOffset.x,\n            y: sourceGapped.y + sourceGapOffset.y\n        },\n        ...points,\n        {\n            x: targetGapped.x + targetGapOffset.x,\n            y: targetGapped.y + targetGapOffset.y\n        },\n        target\n    ];\n    return [\n        pathPoints,\n        centerX,\n        centerY,\n        defaultOffsetX,\n        defaultOffsetY\n    ];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if (a.x === x && x === c.x || a.y === y && y === c.y) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20 }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: {\n            x: sourceX,\n            y: sourceY\n        },\n        sourcePosition,\n        target: {\n            x: targetX,\n            y: targetY\n        },\n        targetPosition,\n        center: {\n            x: centerX,\n            y: centerY\n        },\n        offset\n    });\n    const path = points.reduce((res, p, i)=>{\n        let segment = \"\";\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        } else {\n            segment = `${i === 0 ? \"M\" : \"L\"}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, \"\");\n    return [\n        path,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nconst SmoothStepEdge = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = Position.Bottom, targetPosition = Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n    const [path, labelX, labelY] = getSmoothStepPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition,\n        borderRadius: pathOptions?.borderRadius,\n        offset: pathOptions?.offset\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseEdge, {\n        path: path,\n        labelX: labelX,\n        labelY: labelY,\n        label: label,\n        labelStyle: labelStyle,\n        labelShowBg: labelShowBg,\n        labelBgStyle: labelBgStyle,\n        labelBgPadding: labelBgPadding,\n        labelBgBorderRadius: labelBgBorderRadius,\n        style: style,\n        markerEnd: markerEnd,\n        markerStart: markerStart,\n        interactionWidth: interactionWidth\n    });\n});\nSmoothStepEdge.displayName = \"SmoothStepEdge\";\nconst StepEdge = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)((props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SmoothStepEdge, {\n        ...props,\n        pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                borderRadius: 0,\n                offset: props.pathOptions?.offset\n            }), [\n            props.pathOptions?.offset\n        ])\n    }));\nStepEdge.displayName = \"StepEdge\";\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY\n    });\n    return [\n        `M ${sourceX},${sourceY}L ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nconst StraightEdge = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n    const [path, labelX, labelY] = getStraightPath({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseEdge, {\n        path: path,\n        labelX: labelX,\n        labelY: labelY,\n        label: label,\n        labelStyle: labelStyle,\n        labelShowBg: labelShowBg,\n        labelBgStyle: labelBgStyle,\n        labelBgPadding: labelBgPadding,\n        labelBgBorderRadius: labelBgBorderRadius,\n        style: style,\n        markerEnd: markerEnd,\n        markerStart: markerStart,\n        interactionWidth: interactionWidth\n    });\n});\nStraightEdge.displayName = \"StraightEdge\";\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch(pos){\n        case Position.Left:\n            return [\n                x1 - calculateControlOffset(x1 - x2, c),\n                y1\n            ];\n        case Position.Right:\n            return [\n                x1 + calculateControlOffset(x2 - x1, c),\n                y1\n            ];\n        case Position.Top:\n            return [\n                x1,\n                y1 - calculateControlOffset(y1 - y2, c)\n            ];\n        case Position.Bottom:\n            return [\n                x1,\n                y1 + calculateControlOffset(y2 - y1, c)\n            ];\n    }\n}\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nconst BezierEdge = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n    const [path, labelX, labelY] = getBezierPath({\n        sourceX,\n        sourceY,\n        sourcePosition,\n        targetX,\n        targetY,\n        targetPosition,\n        curvature: pathOptions?.curvature\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BaseEdge, {\n        path: path,\n        labelX: labelX,\n        labelY: labelY,\n        label: label,\n        labelStyle: labelStyle,\n        labelShowBg: labelShowBg,\n        labelBgStyle: labelBgStyle,\n        labelBgPadding: labelBgPadding,\n        labelBgBorderRadius: labelBgBorderRadius,\n        style: style,\n        markerEnd: markerEnd,\n        markerStart: markerStart,\n        interactionWidth: interactionWidth\n    });\n});\nBezierEdge.displayName = \"BezierEdge\";\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\nconst useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst isEdge = (element)=>\"id\" in element && \"source\" in element && \"target\" in element;\nconst isNode = (element)=>\"id\" in element && !(\"source\" in element) && !(\"target\" in element);\nconst getOutgoers = (node, nodes, edges)=>{\n    if (!isNode(node)) {\n        return [];\n    }\n    const outgoerIds = edges.filter((e)=>e.source === node.id).map((e)=>e.target);\n    return nodes.filter((n)=>outgoerIds.includes(n.id));\n};\nconst getIncomers = (node, nodes, edges)=>{\n    if (!isNode(node)) {\n        return [];\n    }\n    const incomersIds = edges.filter((e)=>e.target === node.id).map((e)=>e.source);\n    return nodes.filter((n)=>incomersIds.includes(n.id));\n};\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle })=>`reactflow__edge-${source}${sourceHandle || \"\"}-${target}${targetHandle || \"\"}`;\nconst getMarkerId = (marker, rfId)=>{\n    if (typeof marker === \"undefined\") {\n        return \"\";\n    }\n    if (typeof marker === \"string\") {\n        return marker;\n    }\n    const idPrefix = rfId ? `${rfId}__` : \"\";\n    return `${idPrefix}${Object.keys(marker).sort().map((key)=>`${key}=${marker[key]}`).join(\"&\")}`;\n};\nconst connectionExists = (edge, edges)=>{\n    return edges.some((el)=>el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle));\n};\nconst addEdge = (edgeParams, edges)=>{\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn(\"006\", errorMessages[\"error006\"]());\n        return edges;\n    }\n    let edge;\n    if (isEdge(edgeParams)) {\n        edge = {\n            ...edgeParams\n        };\n    } else {\n        edge = {\n            ...edgeParams,\n            id: getEdgeId(edgeParams)\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    return edges.concat(edge);\n};\nconst updateEdge = (oldEdge, newConnection, edges, options = {\n    shouldReplaceId: true\n})=>{\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn(\"006\", errorMessages[\"error006\"]());\n        return edges;\n    }\n    const foundEdge = edges.find((e)=>e.id === oldEdgeId);\n    if (!foundEdge) {\n        devWarn(\"007\", errorMessages[\"error007\"](oldEdgeId));\n        return edges;\n    }\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle\n    };\n    return edges.filter((e)=>e.id !== oldEdgeId).concat(edge);\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid, [snapX, snapY])=>{\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale\n    };\n    if (snapToGrid) {\n        return {\n            x: snapX * Math.round(position.x / snapX),\n            y: snapY * Math.round(position.y / snapY)\n        };\n    }\n    return position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale])=>{\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty\n    };\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [\n    0,\n    0\n])=>{\n    if (!node) {\n        return {\n            x: 0,\n            y: 0,\n            positionAbsolute: {\n                x: 0,\n                y: 0\n            }\n        };\n    }\n    const offsetX = (node.width ?? 0) * nodeOrigin[0];\n    const offsetY = (node.height ?? 0) * nodeOrigin[1];\n    const position = {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY\n    };\n    return {\n        ...position,\n        positionAbsolute: node.positionAbsolute ? {\n            x: node.positionAbsolute.x - offsetX,\n            y: node.positionAbsolute.y - offsetY\n        } : position\n    };\n};\nconst getNodesBounds = (nodes, nodeOrigin = [\n    0,\n    0\n])=>{\n    if (nodes.length === 0) {\n        return {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n    }\n    const box = nodes.reduce((currBox, node)=>{\n        const { x, y } = getNodePositionWithOrigin(node, nodeOrigin).positionAbsolute;\n        return getBoundsOfBoxes(currBox, rectToBox({\n            x,\n            y,\n            width: node.width || 0,\n            height: node.height || 0\n        }));\n    }, {\n        x: Infinity,\n        y: Infinity,\n        x2: -Infinity,\n        y2: -Infinity\n    });\n    return boxToRect(box);\n};\n// @deprecated Use `getNodesBounds`.\nconst getRectOfNodes = (nodes, nodeOrigin = [\n    0,\n    0\n])=>{\n    console.warn(\"[DEPRECATED] `getRectOfNodes` is deprecated. Instead use `getNodesBounds` https://reactflow.dev/api-reference/utils/get-nodes-bounds.\");\n    return getNodesBounds(nodes, nodeOrigin);\n};\nconst getNodesInside = (nodeInternals, rect, [tx, ty, tScale] = [\n    0,\n    0,\n    1\n], partially = false, // set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false, nodeOrigin = [\n    0,\n    0\n])=>{\n    const paneRect = {\n        x: (rect.x - tx) / tScale,\n        y: (rect.y - ty) / tScale,\n        width: rect.width / tScale,\n        height: rect.height / tScale\n    };\n    const visibleNodes = [];\n    nodeInternals.forEach((node)=>{\n        const { width, height, selectable = true, hidden = false } = node;\n        if (excludeNonSelectableNodes && !selectable || hidden) {\n            return false;\n        }\n        const { positionAbsolute } = getNodePositionWithOrigin(node, nodeOrigin);\n        const nodeRect = {\n            x: positionAbsolute.x,\n            y: positionAbsolute.y,\n            width: width || 0,\n            height: height || 0\n        };\n        const overlappingArea = getOverlappingArea(paneRect, nodeRect);\n        const notInitialized = typeof width === \"undefined\" || typeof height === \"undefined\" || width === null || height === null;\n        const partiallyVisible = partially && overlappingArea > 0;\n        const area = (width || 0) * (height || 0);\n        const isVisible = notInitialized || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    });\n    return visibleNodes;\n};\nconst getConnectedEdges = (nodes, edges)=>{\n    const nodeIds = nodes.map((node)=>node.id);\n    return edges.filter((edge)=>nodeIds.includes(edge.source) || nodeIds.includes(edge.target));\n};\n// @deprecated Use `getViewportForBounds`.\nconst getTransformForBounds = (bounds, width, height, minZoom, maxZoom, padding = 0.1)=>{\n    const { x, y, zoom } = getViewportForBounds(bounds, width, height, minZoom, maxZoom, padding);\n    console.warn(\"[DEPRECATED] `getTransformForBounds` is deprecated. Instead use `getViewportForBounds`. Beware that the return value is type Viewport (`{ x: number, y: number, zoom: number }`) instead of Transform (`[number, number, number]`). https://reactflow.dev/api-reference/utils/get-viewport-for-bounds\");\n    return [\n        x,\n        y,\n        zoom\n    ];\n};\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding = 0.1)=>{\n    const xZoom = width / (bounds.width * (1 + padding));\n    const yZoom = height / (bounds.height * (1 + padding));\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    return {\n        x,\n        y,\n        zoom: clampedZoom\n    };\n};\nconst getD3Transition = (selection, duration = 0)=>{\n    return selection.transition().duration(duration);\n};\n// this functions collects all handles and adds an absolute position\n// so that we can later find the closest handle to the mouse position\nfunction getHandles(node, handleBounds, type, currentHandle) {\n    return (handleBounds[type] || []).reduce((res, h)=>{\n        if (`${node.id}-${h.id}-${type}` !== currentHandle) {\n            res.push({\n                id: h.id || null,\n                type,\n                nodeId: node.id,\n                x: (node.positionAbsolute?.x ?? 0) + h.x + h.width / 2,\n                y: (node.positionAbsolute?.y ?? 0) + h.y + h.height / 2\n            });\n        }\n        return res;\n    }, []);\n}\nfunction getClosestHandle(event, doc, pos, connectionRadius, handles, validator) {\n    // we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n    // because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n    const { x, y } = getEventPosition(event);\n    const domNodes = doc.elementsFromPoint(x, y);\n    const handleBelow = domNodes.find((el)=>el.classList.contains(\"react-flow__handle\"));\n    if (handleBelow) {\n        const handleNodeId = handleBelow.getAttribute(\"data-nodeid\");\n        if (handleNodeId) {\n            const handleType = getHandleType(undefined, handleBelow);\n            const handleId = handleBelow.getAttribute(\"data-handleid\");\n            const validHandleResult = validator({\n                nodeId: handleNodeId,\n                id: handleId,\n                type: handleType\n            });\n            if (validHandleResult) {\n                const handle = handles.find((h)=>h.nodeId === handleNodeId && h.type === handleType && h.id === handleId);\n                return {\n                    handle: {\n                        id: handleId,\n                        type: handleType,\n                        nodeId: handleNodeId,\n                        x: handle?.x || pos.x,\n                        y: handle?.y || pos.y\n                    },\n                    validHandleResult\n                };\n            }\n        }\n    }\n    // if we couldn't find a handle below the mouse cursor we look for the closest distance based on the connectionRadius\n    let closestHandles = [];\n    let minDistance = Infinity;\n    handles.forEach((handle)=>{\n        const distance = Math.sqrt((handle.x - pos.x) ** 2 + (handle.y - pos.y) ** 2);\n        if (distance <= connectionRadius) {\n            const validHandleResult = validator(handle);\n            if (distance <= minDistance) {\n                if (distance < minDistance) {\n                    closestHandles = [\n                        {\n                            handle,\n                            validHandleResult\n                        }\n                    ];\n                } else if (distance === minDistance) {\n                    // when multiple handles are on the same distance we collect all of them\n                    closestHandles.push({\n                        handle,\n                        validHandleResult\n                    });\n                }\n                minDistance = distance;\n            }\n        }\n    });\n    if (!closestHandles.length) {\n        return {\n            handle: null,\n            validHandleResult: defaultResult()\n        };\n    }\n    if (closestHandles.length === 1) {\n        return closestHandles[0];\n    }\n    const hasValidHandle = closestHandles.some(({ validHandleResult })=>validHandleResult.isValid);\n    const hasTargetHandle = closestHandles.some(({ handle })=>handle.type === \"target\");\n    // if multiple handles are layouted on top of each other we prefer the one with type = target and the one that is valid\n    return closestHandles.find(({ handle, validHandleResult })=>hasTargetHandle ? handle.type === \"target\" : hasValidHandle ? validHandleResult.isValid : true) || closestHandles[0];\n}\nconst nullConnection = {\n    source: null,\n    target: null,\n    sourceHandle: null,\n    targetHandle: null\n};\nconst defaultResult = ()=>({\n        handleDomNode: null,\n        isValid: false,\n        connection: nullConnection,\n        endHandle: null\n    });\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(handle, connectionMode, fromNodeId, fromHandleId, fromType, isValidConnection, doc) {\n    const isTarget = fromType === \"target\";\n    const handleToCheck = doc.querySelector(`.react-flow__handle[data-id=\"${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`);\n    const result = {\n        ...defaultResult(),\n        handleDomNode: handleToCheck\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute(\"data-nodeid\");\n        const handleId = handleToCheck.getAttribute(\"data-handleid\");\n        const connectable = handleToCheck.classList.contains(\"connectable\");\n        const connectableEnd = handleToCheck.classList.contains(\"connectableend\");\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === \"source\" || !isTarget && handleType === \"target\" : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        if (isValid) {\n            result.endHandle = {\n                nodeId: handleNodeId,\n                handleId,\n                type: handleType\n            };\n            result.isValid = isValidConnection(connection);\n        }\n    }\n    return result;\n}\nfunction getHandleLookup({ nodes, nodeId, handleId, handleType }) {\n    return nodes.reduce((res, node)=>{\n        if (node[internalsSymbol]) {\n            const { handleBounds } = node[internalsSymbol];\n            let sourceHandles = [];\n            let targetHandles = [];\n            if (handleBounds) {\n                sourceHandles = getHandles(node, handleBounds, \"source\", `${nodeId}-${handleId}-${handleType}`);\n                targetHandles = getHandles(node, handleBounds, \"target\", `${nodeId}-${handleId}-${handleType}`);\n            }\n            res.push(...sourceHandles, ...targetHandles);\n        }\n        return res;\n    }, []);\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    } else if (handleDomNode?.classList.contains(\"target\")) {\n        return \"target\";\n    } else if (handleDomNode?.classList.contains(\"source\")) {\n        return \"source\";\n    }\n    return null;\n}\nfunction resetRecentHandle(handleDomNode) {\n    handleDomNode?.classList.remove(\"valid\", \"connecting\", \"react-flow__handle-valid\", \"react-flow__handle-connecting\");\n}\nfunction getConnectionStatus(isInsideConnectionRadius, isHandleValid) {\n    let connectionStatus = null;\n    if (isHandleValid) {\n        connectionStatus = \"valid\";\n    } else if (isInsideConnectionRadius && !isHandleValid) {\n        connectionStatus = \"invalid\";\n    }\n    return connectionStatus;\n}\nfunction handlePointerDown({ event, handleId, nodeId, onConnect, isTarget, getState, setState, isValidConnection, edgeUpdaterType, onEdgeUpdateEnd }) {\n    // when react-flow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    const { connectionMode, domNode, autoPanOnConnect, connectionRadius, onConnectStart, panBy, getNodes, cancelConnection } = getState();\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const clickedHandle = doc?.elementFromPoint(x, y);\n    const handleType = getHandleType(edgeUpdaterType, clickedHandle);\n    const containerBounds = domNode?.getBoundingClientRect();\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    let prevActiveHandle;\n    let connectionPosition = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let handleDomNode = null;\n    const handleLookup = getHandleLookup({\n        nodes: getNodes(),\n        nodeId,\n        handleId,\n        handleType\n    });\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    const autoPan = ()=>{\n        if (!autoPanOnConnect) {\n            return;\n        }\n        const [xMovement, yMovement] = calcAutoPan(connectionPosition, containerBounds);\n        panBy({\n            x: xMovement,\n            y: yMovement\n        });\n        autoPanId = requestAnimationFrame(autoPan);\n    };\n    setState({\n        connectionPosition,\n        connectionStatus: null,\n        // connectionNodeId etc will be removed in the next major in favor of connectionStartHandle\n        connectionNodeId: nodeId,\n        connectionHandleId: handleId,\n        connectionHandleType: handleType,\n        connectionStartHandle: {\n            nodeId,\n            handleId,\n            type: handleType\n        },\n        connectionEndHandle: null\n    });\n    onConnectStart?.(event, {\n        nodeId,\n        handleId,\n        handleType\n    });\n    function onPointerMove(event) {\n        const { transform } = getState();\n        connectionPosition = getEventPosition(event, containerBounds);\n        const { handle, validHandleResult } = getClosestHandle(event, doc, pointToRendererPoint(connectionPosition, transform, false, [\n            1,\n            1\n        ]), connectionRadius, handleLookup, (handle)=>isValidHandle(handle, connectionMode, nodeId, handleId, isTarget ? \"target\" : \"source\", isValidConnection, doc));\n        closestHandle = handle;\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        handleDomNode = validHandleResult.handleDomNode;\n        connection = validHandleResult.connection;\n        isValid = validHandleResult.isValid;\n        setState({\n            connectionPosition: closestHandle && isValid ? rendererPointToPoint({\n                x: closestHandle.x,\n                y: closestHandle.y\n            }, transform) : connectionPosition,\n            connectionStatus: getConnectionStatus(!!closestHandle, isValid),\n            connectionEndHandle: validHandleResult.endHandle\n        });\n        if (!closestHandle && !isValid && !handleDomNode) {\n            return resetRecentHandle(prevActiveHandle);\n        }\n        if (connection.source !== connection.target && handleDomNode) {\n            resetRecentHandle(prevActiveHandle);\n            prevActiveHandle = handleDomNode;\n            // @todo: remove the old class names \"react-flow__handle-\" in the next major version\n            handleDomNode.classList.add(\"connecting\", \"react-flow__handle-connecting\");\n            handleDomNode.classList.toggle(\"valid\", isValid);\n            handleDomNode.classList.toggle(\"react-flow__handle-valid\", isValid);\n        }\n    }\n    function onPointerUp(event) {\n        if ((closestHandle || handleDomNode) && connection && isValid) {\n            onConnect?.(connection);\n        }\n        // it's important to get a fresh reference from the store here\n        // in order to get the latest state of onConnectEnd\n        getState().onConnectEnd?.(event);\n        if (edgeUpdaterType) {\n            onEdgeUpdateEnd?.(event);\n        }\n        resetRecentHandle(prevActiveHandle);\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        handleDomNode = null;\n        doc.removeEventListener(\"mousemove\", onPointerMove);\n        doc.removeEventListener(\"mouseup\", onPointerUp);\n        doc.removeEventListener(\"touchmove\", onPointerMove);\n        doc.removeEventListener(\"touchend\", onPointerUp);\n    }\n    doc.addEventListener(\"mousemove\", onPointerMove);\n    doc.addEventListener(\"mouseup\", onPointerUp);\n    doc.addEventListener(\"touchmove\", onPointerMove);\n    doc.addEventListener(\"touchend\", onPointerUp);\n}\nconst alwaysValid = ()=>true;\nconst selector$f = (s)=>({\n        connectionStartHandle: s.connectionStartHandle,\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionStartHandle: startHandle, connectionEndHandle: endHandle, connectionClickStartHandle: clickHandle } = state;\n        return {\n            connecting: startHandle?.nodeId === nodeId && startHandle?.handleId === handleId && startHandle?.type === type || endHandle?.nodeId === nodeId && endHandle?.handleId === handleId && endHandle?.type === type,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.handleId === handleId && clickHandle?.type === type\n        };\n    };\nconst Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ type = \"source\", position = Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref)=>{\n    const handleId = id || null;\n    const isTarget = type === \"target\";\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const { connecting, clickConnecting } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.(\"010\", errorMessages[\"error010\"]());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges(addEdge(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = isMouseEvent(event);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            handlePointerDown({\n                event,\n                handleId,\n                nodeId,\n                onConnect: onConnectExtended,\n                isTarget,\n                getState: store.getState,\n                setState: store.setState,\n                isValidConnection: isValidConnection || store.getState().isValidConnection || alwaysValid\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    handleId\n                }\n            });\n            return;\n        }\n        const doc = getHostForElement(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore || alwaysValid;\n        const { connection, isValid } = isValidHandle({\n            nodeId,\n            id: handleId,\n            type\n        }, connectionMode, connectionClickStartHandle.nodeId, connectionClickStartHandle.handleId || null, connectionClickStartHandle.type, isValidConnectionHandler, doc);\n        if (isValid) {\n            onConnectExtended(connection);\n        }\n        onClickConnectEnd?.(event);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__handle\",\n            `react-flow__handle-${position}`,\n            \"nodrag\",\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                connecting: clickConnecting,\n                // this class is used to style the handle when the user is connecting\n                connectionindicator: isConnectable && (isConnectableStart && !connecting || isConnectableEnd && connecting)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest\n    }, children);\n});\nHandle.displayName = \"Handle\";\nvar Handle$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(Handle);\nconst DefaultNode = ({ data, isConnectable, targetPosition = Position.Top, sourcePosition = Position.Bottom })=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Handle$1, {\n        type: \"target\",\n        position: targetPosition,\n        isConnectable: isConnectable\n    }), data?.label, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Handle$1, {\n        type: \"source\",\n        position: sourcePosition,\n        isConnectable: isConnectable\n    }));\n};\nDefaultNode.displayName = \"DefaultNode\";\nvar DefaultNode$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(DefaultNode);\nconst InputNode = ({ data, isConnectable, sourcePosition = Position.Bottom })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, data?.label, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Handle$1, {\n        type: \"source\",\n        position: sourcePosition,\n        isConnectable: isConnectable\n    }));\nInputNode.displayName = \"InputNode\";\nvar InputNode$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(InputNode);\nconst OutputNode = ({ data, isConnectable, targetPosition = Position.Top })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Handle$1, {\n        type: \"target\",\n        position: targetPosition,\n        isConnectable: isConnectable\n    }), data?.label);\nOutputNode.displayName = \"OutputNode\";\nvar OutputNode$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(OutputNode);\nconst GroupNode = ()=>null;\nGroupNode.displayName = \"GroupNode\";\nconst selector$e = (s)=>({\n        selectedNodes: s.getNodes().filter((n)=>n.selected),\n        selectedEdges: s.edges.filter((e)=>e.selected)\n    });\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\n// This is just a helper component for calling the onSelectionChange listener.\n// @TODO: Now that we have the onNodesChange and on EdgesChange listeners, do we still need this component?\nconst SelectionListener = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ onSelectionChange })=>{\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$e, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const params = {\n            nodes: selectedNodes,\n            edges: selectedEdges\n        };\n        onSelectionChange?.(params);\n        store.getState().onSelectionChange.forEach((fn)=>fn(params));\n    }, [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n});\nSelectionListener.displayName = \"SelectionListener\";\nconst changeSelector = (s)=>!!s.onSelectionChange;\nfunction Wrapper$1({ onSelectionChange }) {\n    const storeHasSelectionChange = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChange) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SelectionListener, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst selector$d = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset\n    });\nfunction useStoreUpdater(value, setStoreState) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (typeof value !== \"undefined\") {\n            setStoreState(value);\n        }\n    }, [\n        value\n    ]);\n}\n// updates with values in store that don't have a dedicated setter function\nfunction useDirectStoreUpdater(key, value, setState) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (typeof value !== \"undefined\") {\n            setState({\n                [key]: value\n            });\n        }\n    }, [\n        value\n    ]);\n}\nconst StoreUpdater = ({ nodes, edges, defaultNodes, defaultEdges, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, nodesDraggable, nodesConnectable, nodesFocusable, edgesFocusable, edgesUpdatable, elevateNodesOnSelect, minZoom, maxZoom, nodeExtent, onNodesChange, onEdgesChange, elementsSelectable, connectionMode, snapGrid, snapToGrid, translateExtent, connectOnClick, defaultEdgeOptions, fitView, fitViewOptions, onNodesDelete, onEdgesDelete, onNodeDrag, onNodeDragStart, onNodeDragStop, onSelectionDrag, onSelectionDragStart, onSelectionDragStop, noPanClassName, nodeOrigin, rfId, autoPanOnConnect, autoPanOnNodeDrag, onError, connectionRadius, isValidConnection, nodeDragThreshold })=>{\n    const { setNodes, setEdges, setDefaultNodesAndEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset } = useStore(selector$d, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const edgesWithDefaults = defaultEdges?.map((e)=>({\n                ...e,\n                ...defaultEdgeOptions\n            }));\n        setDefaultNodesAndEdges(defaultNodes, edgesWithDefaults);\n        return ()=>{\n            reset();\n        };\n    }, []);\n    useDirectStoreUpdater(\"defaultEdgeOptions\", defaultEdgeOptions, store.setState);\n    useDirectStoreUpdater(\"connectionMode\", connectionMode, store.setState);\n    useDirectStoreUpdater(\"onConnect\", onConnect, store.setState);\n    useDirectStoreUpdater(\"onConnectStart\", onConnectStart, store.setState);\n    useDirectStoreUpdater(\"onConnectEnd\", onConnectEnd, store.setState);\n    useDirectStoreUpdater(\"onClickConnectStart\", onClickConnectStart, store.setState);\n    useDirectStoreUpdater(\"onClickConnectEnd\", onClickConnectEnd, store.setState);\n    useDirectStoreUpdater(\"nodesDraggable\", nodesDraggable, store.setState);\n    useDirectStoreUpdater(\"nodesConnectable\", nodesConnectable, store.setState);\n    useDirectStoreUpdater(\"nodesFocusable\", nodesFocusable, store.setState);\n    useDirectStoreUpdater(\"edgesFocusable\", edgesFocusable, store.setState);\n    useDirectStoreUpdater(\"edgesUpdatable\", edgesUpdatable, store.setState);\n    useDirectStoreUpdater(\"elementsSelectable\", elementsSelectable, store.setState);\n    useDirectStoreUpdater(\"elevateNodesOnSelect\", elevateNodesOnSelect, store.setState);\n    useDirectStoreUpdater(\"snapToGrid\", snapToGrid, store.setState);\n    useDirectStoreUpdater(\"snapGrid\", snapGrid, store.setState);\n    useDirectStoreUpdater(\"onNodesChange\", onNodesChange, store.setState);\n    useDirectStoreUpdater(\"onEdgesChange\", onEdgesChange, store.setState);\n    useDirectStoreUpdater(\"connectOnClick\", connectOnClick, store.setState);\n    useDirectStoreUpdater(\"fitViewOnInit\", fitView, store.setState);\n    useDirectStoreUpdater(\"fitViewOnInitOptions\", fitViewOptions, store.setState);\n    useDirectStoreUpdater(\"onNodesDelete\", onNodesDelete, store.setState);\n    useDirectStoreUpdater(\"onEdgesDelete\", onEdgesDelete, store.setState);\n    useDirectStoreUpdater(\"onNodeDrag\", onNodeDrag, store.setState);\n    useDirectStoreUpdater(\"onNodeDragStart\", onNodeDragStart, store.setState);\n    useDirectStoreUpdater(\"onNodeDragStop\", onNodeDragStop, store.setState);\n    useDirectStoreUpdater(\"onSelectionDrag\", onSelectionDrag, store.setState);\n    useDirectStoreUpdater(\"onSelectionDragStart\", onSelectionDragStart, store.setState);\n    useDirectStoreUpdater(\"onSelectionDragStop\", onSelectionDragStop, store.setState);\n    useDirectStoreUpdater(\"noPanClassName\", noPanClassName, store.setState);\n    useDirectStoreUpdater(\"nodeOrigin\", nodeOrigin, store.setState);\n    useDirectStoreUpdater(\"rfId\", rfId, store.setState);\n    useDirectStoreUpdater(\"autoPanOnConnect\", autoPanOnConnect, store.setState);\n    useDirectStoreUpdater(\"autoPanOnNodeDrag\", autoPanOnNodeDrag, store.setState);\n    useDirectStoreUpdater(\"onError\", onError, store.setState);\n    useDirectStoreUpdater(\"connectionRadius\", connectionRadius, store.setState);\n    useDirectStoreUpdater(\"isValidConnection\", isValidConnection, store.setState);\n    useDirectStoreUpdater(\"nodeDragThreshold\", nodeDragThreshold, store.setState);\n    useStoreUpdater(nodes, setNodes);\n    useStoreUpdater(edges, setEdges);\n    useStoreUpdater(minZoom, setMinZoom);\n    useStoreUpdater(maxZoom, setMaxZoom);\n    useStoreUpdater(translateExtent, setTranslateExtent);\n    useStoreUpdater(nodeExtent, setNodeExtent);\n    return null;\n};\nconst style = {\n    display: \"none\"\n};\nconst ariaLiveStyle = {\n    position: \"absolute\",\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: \"hidden\",\n    clip: \"rect(0px, 0px, 0px, 0px)\",\n    clipPath: \"inset(100%)\"\n};\nconst ARIA_NODE_DESC_KEY = \"react-flow__node-desc\";\nconst ARIA_EDGE_DESC_KEY = \"react-flow__edge-desc\";\nconst ARIA_LIVE_MESSAGE = \"react-flow__aria-live\";\nconst selector$c = (s)=>s.ariaLiveMessage;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(selector$c);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle\n    }, ariaLiveMessage);\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        style: style\n    }, \"Press enter or space to select a node.\", !disableKeyboardA11y && \"You can then use the arrow keys to move the node around.\", \" Press delete to remove it and escape to cancel.\", \" \"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n        style: style\n    }, \"Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.\"), !disableKeyboardA11y && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AriaLiveMessage, {\n        rfId: rfId\n    }));\n}\n// the keycode can be a string 'a' or an array of strings ['a', 'a+d']\n// a string means a single key 'a' or a combination when '+' is used 'a+d'\n// an array means different possibilities. Explainer: ['a', 'd+s'] here the\n// user can use the single key 'a' or the combination 'd' + 's'\nvar useKeyPress = (keyCode = null, options = {\n    actInsideInputWithModifier: true\n})=>{\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Set([]));\n    // keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n    // keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n    // used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n    // we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n    // and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n    // we can't find it in the list of keysToWatch.\n    const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (keyCode !== null) {\n            const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                keyCode\n            ];\n            const keys = keyCodeArr.filter((kc)=>typeof kc === \"string\").map((kc)=>kc.split(\"+\"));\n            const keysFlat = keys.reduce((res, item)=>res.concat(...item), []);\n            return [\n                keys,\n                keysFlat\n            ];\n        }\n        return [\n            [],\n            []\n        ];\n    }, [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const doc = typeof document !== \"undefined\" ? document : null;\n        const target = options?.target || doc;\n        if (keyCode !== null) {\n            const downHandler = (event)=>{\n                modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey;\n                const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && isInputDOMNode(event);\n                if (preventAction) {\n                    return false;\n                }\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                pressedKeys.current.add(event[keyOrCode]);\n                if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                    event.preventDefault();\n                    setKeyPressed(true);\n                }\n            };\n            const upHandler = (event)=>{\n                const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && isInputDOMNode(event);\n                if (preventAction) {\n                    return false;\n                }\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                    setKeyPressed(false);\n                    pressedKeys.current.clear();\n                } else {\n                    pressedKeys.current.delete(event[keyOrCode]);\n                }\n                // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                if (event.key === \"Meta\") {\n                    pressedKeys.current.clear();\n                }\n                modifierPressed.current = false;\n            };\n            const resetHandler = ()=>{\n                pressedKeys.current.clear();\n                setKeyPressed(false);\n            };\n            target?.addEventListener(\"keydown\", downHandler);\n            target?.addEventListener(\"keyup\", upHandler);\n            window.addEventListener(\"blur\", resetHandler);\n            return ()=>{\n                target?.removeEventListener(\"keydown\", downHandler);\n                target?.removeEventListener(\"keyup\", upHandler);\n                window.removeEventListener(\"blur\", resetHandler);\n            };\n        }\n    }, [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n};\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes// we only want to compare same sizes of keyCode definitions\n    // and pressed keys. When the user specified 'Meta' as a key somewhere\n    // this would also be truthy without this filter when user presses 'Meta' + 'r'\n    .filter((keys)=>isUp || keys.length === pressedKeys.size)// since we want to support multiple possibilities only one of the\n    // combinations need to be part of the pressed keys\n    .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? \"code\" : \"key\";\n}\nfunction calculateXYZPosition(node, nodeInternals, result, nodeOrigin) {\n    if (!node.parentNode) {\n        return result;\n    }\n    const parentNode = nodeInternals.get(node.parentNode);\n    const parentNodePosition = getNodePositionWithOrigin(parentNode, nodeOrigin);\n    return calculateXYZPosition(parentNode, nodeInternals, {\n        x: (result.x ?? 0) + parentNodePosition.x,\n        y: (result.y ?? 0) + parentNodePosition.y,\n        z: (parentNode[internalsSymbol]?.z ?? 0) > (result.z ?? 0) ? parentNode[internalsSymbol]?.z ?? 0 : result.z ?? 0\n    }, nodeOrigin);\n}\nfunction updateAbsoluteNodePositions(nodeInternals, nodeOrigin, parentNodes) {\n    nodeInternals.forEach((node)=>{\n        if (node.parentNode && !nodeInternals.has(node.parentNode)) {\n            throw new Error(`Parent node ${node.parentNode} not found`);\n        }\n        if (node.parentNode || parentNodes?.[node.id]) {\n            const { x, y, z } = calculateXYZPosition(node, nodeInternals, {\n                ...node.position,\n                z: node[internalsSymbol]?.z ?? 0\n            }, nodeOrigin);\n            node.positionAbsolute = {\n                x,\n                y\n            };\n            node[internalsSymbol].z = z;\n            if (parentNodes?.[node.id]) {\n                node[internalsSymbol].isParent = true;\n            }\n        }\n    });\n}\nfunction createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect) {\n    const nextNodeInternals = new Map();\n    const parentNodes = {};\n    const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;\n    nodes.forEach((node)=>{\n        const z = (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n        const currInternals = nodeInternals.get(node.id);\n        const internals = {\n            width: currInternals?.width,\n            height: currInternals?.height,\n            ...node,\n            positionAbsolute: {\n                x: node.position.x,\n                y: node.position.y\n            }\n        };\n        if (node.parentNode) {\n            internals.parentNode = node.parentNode;\n            parentNodes[node.parentNode] = true;\n        }\n        Object.defineProperty(internals, internalsSymbol, {\n            enumerable: false,\n            value: {\n                handleBounds: currInternals?.[internalsSymbol]?.handleBounds,\n                z\n            }\n        });\n        nextNodeInternals.set(node.id, internals);\n    });\n    updateAbsoluteNodePositions(nextNodeInternals, nodeOrigin, parentNodes);\n    return nextNodeInternals;\n}\nfunction fitView(get, options = {}) {\n    const { getNodes, width, height, minZoom, maxZoom, d3Zoom, d3Selection, fitViewOnInitDone, fitViewOnInit, nodeOrigin } = get();\n    const isInitialFitView = options.initial && !fitViewOnInitDone && fitViewOnInit;\n    const d3initialized = d3Zoom && d3Selection;\n    if (d3initialized && (isInitialFitView || !options.initial)) {\n        const nodes = getNodes().filter((n)=>{\n            const isVisible = options.includeHiddenNodes ? n.width && n.height : !n.hidden;\n            if (options.nodes?.length) {\n                return isVisible && options.nodes.some((optionNode)=>optionNode.id === n.id);\n            }\n            return isVisible;\n        });\n        const nodesInitialized = nodes.every((n)=>n.width && n.height);\n        if (nodes.length > 0 && nodesInitialized) {\n            const bounds = getNodesBounds(nodes, nodeOrigin);\n            const { x, y, zoom } = getViewportForBounds(bounds, width, height, options.minZoom ?? minZoom, options.maxZoom ?? maxZoom, options.padding ?? 0.1);\n            const nextTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(x, y).scale(zoom);\n            if (typeof options.duration === \"number\" && options.duration > 0) {\n                d3Zoom.transform(getD3Transition(d3Selection, options.duration), nextTransform);\n            } else {\n                d3Zoom.transform(d3Selection, nextTransform);\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction handleControlledNodeSelectionChange(nodeChanges, nodeInternals) {\n    nodeChanges.forEach((change)=>{\n        const node = nodeInternals.get(change.id);\n        if (node) {\n            nodeInternals.set(node.id, {\n                ...node,\n                [internalsSymbol]: node[internalsSymbol],\n                selected: change.selected\n            });\n        }\n    });\n    return new Map(nodeInternals);\n}\nfunction handleControlledEdgeSelectionChange(edgeChanges, edges) {\n    return edges.map((e)=>{\n        const change = edgeChanges.find((change)=>change.id === e.id);\n        if (change) {\n            e.selected = change.selected;\n        }\n        return e;\n    });\n}\nfunction updateNodesAndEdgesSelections({ changedNodes, changedEdges, get, set }) {\n    const { nodeInternals, edges, onNodesChange, onEdgesChange, hasDefaultNodes, hasDefaultEdges } = get();\n    if (changedNodes?.length) {\n        if (hasDefaultNodes) {\n            set({\n                nodeInternals: handleControlledNodeSelectionChange(changedNodes, nodeInternals)\n            });\n        }\n        onNodesChange?.(changedNodes);\n    }\n    if (changedEdges?.length) {\n        if (hasDefaultEdges) {\n            set({\n                edges: handleControlledEdgeSelectionChange(changedEdges, edges)\n            });\n        }\n        onEdgesChange?.(changedEdges);\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = ()=>{};\nconst initialViewportHelper = {\n    zoomIn: noop,\n    zoomOut: noop,\n    zoomTo: noop,\n    getZoom: ()=>1,\n    setViewport: noop,\n    getViewport: ()=>({\n            x: 0,\n            y: 0,\n            zoom: 1\n        }),\n    fitView: ()=>false,\n    setCenter: noop,\n    fitBounds: noop,\n    project: (position)=>position,\n    screenToFlowPosition: (position)=>position,\n    flowToScreenPosition: (position)=>position,\n    viewportInitialized: false\n};\nconst selector$b = (s)=>({\n        d3Zoom: s.d3Zoom,\n        d3Selection: s.d3Selection\n    });\nconst useViewportHelper = ()=>{\n    const store = useStoreApi();\n    const { d3Zoom, d3Selection } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const viewportHelperFunctions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (d3Selection && d3Zoom) {\n            return {\n                zoomIn: (options)=>d3Zoom.scaleBy(getD3Transition(d3Selection, options?.duration), 1.2),\n                zoomOut: (options)=>d3Zoom.scaleBy(getD3Transition(d3Selection, options?.duration), 1 / 1.2),\n                zoomTo: (zoomLevel, options)=>d3Zoom.scaleTo(getD3Transition(d3Selection, options?.duration), zoomLevel),\n                getZoom: ()=>store.getState().transform[2],\n                setViewport: (transform, options)=>{\n                    const [x, y, zoom] = store.getState().transform;\n                    const nextTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(transform.x ?? x, transform.y ?? y).scale(transform.zoom ?? zoom);\n                    d3Zoom.transform(getD3Transition(d3Selection, options?.duration), nextTransform);\n                },\n                getViewport: ()=>{\n                    const [x, y, zoom] = store.getState().transform;\n                    return {\n                        x,\n                        y,\n                        zoom\n                    };\n                },\n                fitView: (options)=>fitView(store.getState, options),\n                setCenter: (x, y, options)=>{\n                    const { width, height, maxZoom } = store.getState();\n                    const nextZoom = typeof options?.zoom !== \"undefined\" ? options.zoom : maxZoom;\n                    const centerX = width / 2 - x * nextZoom;\n                    const centerY = height / 2 - y * nextZoom;\n                    const transform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(centerX, centerY).scale(nextZoom);\n                    d3Zoom.transform(getD3Transition(d3Selection, options?.duration), transform);\n                },\n                fitBounds: (bounds, options)=>{\n                    const { width, height, minZoom, maxZoom } = store.getState();\n                    const { x, y, zoom } = getViewportForBounds(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                    const transform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(x, y).scale(zoom);\n                    d3Zoom.transform(getD3Transition(d3Selection, options?.duration), transform);\n                },\n                // @deprecated Use `screenToFlowPosition`.\n                project: (position)=>{\n                    const { transform, snapToGrid, snapGrid } = store.getState();\n                    console.warn(\"[DEPRECATED] `project` is deprecated. Instead use `screenToFlowPosition`. There is no need to subtract the react flow bounds anymore! https://reactflow.dev/api-reference/types/react-flow-instance#screen-to-flow-position\");\n                    return pointToRendererPoint(position, transform, snapToGrid, snapGrid);\n                },\n                screenToFlowPosition: (position)=>{\n                    const { transform, snapToGrid, snapGrid, domNode } = store.getState();\n                    if (!domNode) {\n                        return position;\n                    }\n                    const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                    const relativePosition = {\n                        x: position.x - domX,\n                        y: position.y - domY\n                    };\n                    return pointToRendererPoint(relativePosition, transform, snapToGrid, snapGrid);\n                },\n                flowToScreenPosition: (position)=>{\n                    const { transform, domNode } = store.getState();\n                    if (!domNode) {\n                        return position;\n                    }\n                    const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                    const rendererPosition = rendererPointToPoint(position, transform);\n                    return {\n                        x: rendererPosition.x + domX,\n                        y: rendererPosition.y + domY\n                    };\n                },\n                viewportInitialized: true\n            };\n        }\n        return initialViewportHelper;\n    }, [\n        d3Zoom,\n        d3Selection\n    ]);\n    return viewportHelperFunctions;\n};\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const getNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return store.getState().getNodes().map((n)=>({\n                ...n\n            }));\n    }, []);\n    const getNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        return store.getState().nodeInternals.get(id);\n    }, []);\n    const getEdges = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const { edges = [] } = store.getState();\n        return edges.map((e)=>({\n                ...e\n            }));\n    }, []);\n    const getEdge = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        const { edges = [] } = store.getState();\n        return edges.find((e)=>e.id === id);\n    }, []);\n    const setNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload)=>{\n        const { getNodes, setNodes, hasDefaultNodes, onNodesChange } = store.getState();\n        const nodes = getNodes();\n        const nextNodes = typeof payload === \"function\" ? payload(nodes) : payload;\n        if (hasDefaultNodes) {\n            setNodes(nextNodes);\n        } else if (onNodesChange) {\n            const changes = nextNodes.length === 0 ? nodes.map((node)=>({\n                    type: \"remove\",\n                    id: node.id\n                })) : nextNodes.map((node)=>({\n                    item: node,\n                    type: \"reset\"\n                }));\n            onNodesChange(changes);\n        }\n    }, []);\n    const setEdges = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload)=>{\n        const { edges = [], setEdges, hasDefaultEdges, onEdgesChange } = store.getState();\n        const nextEdges = typeof payload === \"function\" ? payload(edges) : payload;\n        if (hasDefaultEdges) {\n            setEdges(nextEdges);\n        } else if (onEdgesChange) {\n            const changes = nextEdges.length === 0 ? edges.map((edge)=>({\n                    type: \"remove\",\n                    id: edge.id\n                })) : nextEdges.map((edge)=>({\n                    item: edge,\n                    type: \"reset\"\n                }));\n            onEdgesChange(changes);\n        }\n    }, []);\n    const addNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload)=>{\n        const nodes = Array.isArray(payload) ? payload : [\n            payload\n        ];\n        const { getNodes, setNodes, hasDefaultNodes, onNodesChange } = store.getState();\n        if (hasDefaultNodes) {\n            const currentNodes = getNodes();\n            const nextNodes = [\n                ...currentNodes,\n                ...nodes\n            ];\n            setNodes(nextNodes);\n        } else if (onNodesChange) {\n            const changes = nodes.map((node)=>({\n                    item: node,\n                    type: \"add\"\n                }));\n            onNodesChange(changes);\n        }\n    }, []);\n    const addEdges = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload)=>{\n        const nextEdges = Array.isArray(payload) ? payload : [\n            payload\n        ];\n        const { edges = [], setEdges, hasDefaultEdges, onEdgesChange } = store.getState();\n        if (hasDefaultEdges) {\n            setEdges([\n                ...edges,\n                ...nextEdges\n            ]);\n        } else if (onEdgesChange) {\n            const changes = nextEdges.map((edge)=>({\n                    item: edge,\n                    type: \"add\"\n                }));\n            onEdgesChange(changes);\n        }\n    }, []);\n    const toObject = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const { getNodes, edges = [], transform } = store.getState();\n        const [x, y, zoom] = transform;\n        return {\n            nodes: getNodes().map((n)=>({\n                    ...n\n                })),\n            edges: edges.map((e)=>({\n                    ...e\n                })),\n            viewport: {\n                x,\n                y,\n                zoom\n            }\n        };\n    }, []);\n    const deleteElements = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ nodes: nodesDeleted, edges: edgesDeleted })=>{\n        const { nodeInternals, getNodes, edges, hasDefaultNodes, hasDefaultEdges, onNodesDelete, onEdgesDelete, onNodesChange, onEdgesChange } = store.getState();\n        const nodeIds = (nodesDeleted || []).map((node)=>node.id);\n        const edgeIds = (edgesDeleted || []).map((edge)=>edge.id);\n        const nodesToRemove = getNodes().reduce((res, node)=>{\n            const parentHit = !nodeIds.includes(node.id) && node.parentNode && res.find((n)=>n.id === node.parentNode);\n            const deletable = typeof node.deletable === \"boolean\" ? node.deletable : true;\n            if (deletable && (nodeIds.includes(node.id) || parentHit)) {\n                res.push(node);\n            }\n            return res;\n        }, []);\n        const deletableEdges = edges.filter((e)=>typeof e.deletable === \"boolean\" ? e.deletable : true);\n        const initialHitEdges = deletableEdges.filter((e)=>edgeIds.includes(e.id));\n        if (nodesToRemove || initialHitEdges) {\n            const connectedEdges = getConnectedEdges(nodesToRemove, deletableEdges);\n            const edgesToRemove = [\n                ...initialHitEdges,\n                ...connectedEdges\n            ];\n            const edgeIdsToRemove = edgesToRemove.reduce((res, edge)=>{\n                if (!res.includes(edge.id)) {\n                    res.push(edge.id);\n                }\n                return res;\n            }, []);\n            if (hasDefaultEdges || hasDefaultNodes) {\n                if (hasDefaultEdges) {\n                    store.setState({\n                        edges: edges.filter((e)=>!edgeIdsToRemove.includes(e.id))\n                    });\n                }\n                if (hasDefaultNodes) {\n                    nodesToRemove.forEach((node)=>{\n                        nodeInternals.delete(node.id);\n                    });\n                    store.setState({\n                        nodeInternals: new Map(nodeInternals)\n                    });\n                }\n            }\n            if (edgeIdsToRemove.length > 0) {\n                onEdgesDelete?.(edgesToRemove);\n                if (onEdgesChange) {\n                    onEdgesChange(edgeIdsToRemove.map((id)=>({\n                            id,\n                            type: \"remove\"\n                        })));\n                }\n            }\n            if (nodesToRemove.length > 0) {\n                onNodesDelete?.(nodesToRemove);\n                if (onNodesChange) {\n                    const nodeChanges = nodesToRemove.map((n)=>({\n                            id: n.id,\n                            type: \"remove\"\n                        }));\n                    onNodesChange(nodeChanges);\n                }\n            }\n        }\n    }, []);\n    const getNodeRect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodeOrRect)=>{\n        const isRect = isRectObject(nodeOrRect);\n        const node = isRect ? null : store.getState().nodeInternals.get(nodeOrRect.id);\n        const nodeRect = isRect ? nodeOrRect : nodeToRect(node);\n        return [\n            nodeRect,\n            node,\n            isRect\n        ];\n    }, []);\n    const getIntersectingNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodeOrRect, partially = true, nodes)=>{\n        const [nodeRect, node, isRect] = getNodeRect(nodeOrRect);\n        if (!nodeRect) {\n            return [];\n        }\n        return (nodes || store.getState().getNodes()).filter((n)=>{\n            if (!isRect && (n.id === node.id || !n.positionAbsolute)) {\n                return false;\n            }\n            const currNodeRect = nodeToRect(n);\n            const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);\n            const partiallyVisible = partially && overlappingArea > 0;\n            return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n        });\n    }, []);\n    const isNodeIntersecting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodeOrRect, area, partially = true)=>{\n        const [nodeRect] = getNodeRect(nodeOrRect);\n        if (!nodeRect) {\n            return false;\n        }\n        const overlappingArea = getOverlappingArea(nodeRect, area);\n        const partiallyVisible = partially && overlappingArea > 0;\n        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n    }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...viewportHelper,\n            getNodes,\n            getNode,\n            getEdges,\n            getEdge,\n            setNodes,\n            setEdges,\n            addNodes,\n            addEdges,\n            toObject,\n            deleteElements,\n            getIntersectingNodes,\n            isNodeIntersecting\n        };\n    }, [\n        viewportHelper,\n        getNodes,\n        getNode,\n        getEdges,\n        getEdge,\n        setNodes,\n        setEdges,\n        addNodes,\n        addEdges,\n        toObject,\n        deleteElements,\n        getIntersectingNodes,\n        isNodeIntersecting\n    ]);\n}\nconst deleteKeyOptions = {\n    actInsideInputWithModifier: false\n};\nvar useGlobalKeyHandler = ({ deleteKeyCode, multiSelectionKeyCode })=>{\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, deleteKeyOptions);\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (deleteKeyPressed) {\n            const { edges, getNodes } = store.getState();\n            const selectedNodes = getNodes().filter((node)=>node.selected);\n            const selectedEdges = edges.filter((edge)=>edge.selected);\n            deleteElements({\n                nodes: selectedNodes,\n                edges: selectedEdges\n            });\n            store.setState({\n                nodesSelectionActive: false\n            });\n        }\n    }, [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        store.setState({\n            multiSelectionActive: multiSelectionKeyPressed\n        });\n    }, [\n        multiSelectionKeyPressed\n    ]);\n};\nfunction useResizeHandler(rendererNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let resizeObserver;\n        const updateDimensions = ()=>{\n            if (!rendererNode.current) {\n                return;\n            }\n            const size = getDimensions(rendererNode.current);\n            if (size.height === 0 || size.width === 0) {\n                store.getState().onError?.(\"004\", errorMessages[\"error004\"]());\n            }\n            store.setState({\n                width: size.width || 500,\n                height: size.height || 500\n            });\n        };\n        updateDimensions();\n        window.addEventListener(\"resize\", updateDimensions);\n        if (rendererNode.current) {\n            resizeObserver = new ResizeObserver(()=>updateDimensions());\n            resizeObserver.observe(rendererNode.current);\n        }\n        return ()=>{\n            window.removeEventListener(\"resize\", updateDimensions);\n            if (resizeObserver && rendererNode.current) {\n                resizeObserver.unobserve(rendererNode.current);\n            }\n        };\n    }, []);\n}\nconst containerStyle = {\n    position: \"absolute\",\n    width: \"100%\",\n    height: \"100%\",\n    top: 0,\n    left: 0\n};\n/* eslint-disable @typescript-eslint/ban-ts-comment */ const viewChanged = (prevViewport, eventTransform)=>prevViewport.x !== eventTransform.x || prevViewport.y !== eventTransform.y || prevViewport.zoom !== eventTransform.k;\nconst eventToFlowTransform = (eventTransform)=>({\n        x: eventTransform.x,\n        y: eventTransform.y,\n        zoom: eventTransform.k\n    });\nconst isWrappedWithClass = (event, className)=>event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton)=>usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\nconst wheelDelta = (event)=>{\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\nconst selector$a = (s)=>({\n        d3Zoom: s.d3Zoom,\n        d3Selection: s.d3Selection,\n        d3ZoomHandler: s.d3ZoomHandler,\n        userSelectionActive: s.userSelectionActive\n    });\nconst ZoomPane = ({ onMove, onMoveStart, onMoveEnd, onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = true, elementsSelectable, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName })=>{\n    const timerId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const store = useStoreApi();\n    const isZoomingOrPanning = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const zoomedWithRightMouseButton = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const prevTransform = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0,\n        zoom: 0\n    });\n    const { d3Zoom, d3Selection, d3ZoomHandler, userSelectionActive } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const mouseButton = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const isPanScrolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const panScrollTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    useResizeHandler(zoomPane);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (zoomPane.current) {\n            const bbox = zoomPane.current.getBoundingClientRect();\n            const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoom)().scaleExtent([\n                minZoom,\n                maxZoom\n            ]).translateExtent(translateExtent);\n            const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(zoomPane.current).call(d3ZoomInstance);\n            const updatedTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(defaultViewport.x, defaultViewport.y).scale(clamp(defaultViewport.zoom, minZoom, maxZoom));\n            const extent = [\n                [\n                    0,\n                    0\n                ],\n                [\n                    bbox.width,\n                    bbox.height\n                ]\n            ];\n            const constrainedTransform = d3ZoomInstance.constrain()(updatedTransform, extent, translateExtent);\n            d3ZoomInstance.transform(selection, constrainedTransform);\n            d3ZoomInstance.wheelDelta(wheelDelta);\n            store.setState({\n                d3Zoom: d3ZoomInstance,\n                d3Selection: selection,\n                d3ZoomHandler: selection.on(\"wheel.zoom\"),\n                // we need to pass transform because zoom handler is not registered when we set the initial transform\n                transform: [\n                    constrainedTransform.x,\n                    constrainedTransform.y,\n                    constrainedTransform.k\n                ],\n                domNode: zoomPane.current.closest(\".react-flow\")\n            });\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (d3Selection && d3Zoom) {\n            if (panOnScroll && !zoomActivationKeyPressed && !userSelectionActive) {\n                d3Selection.on(\"wheel.zoom\", (event)=>{\n                    if (isWrappedWithClass(event, noWheelClassName)) {\n                        return false;\n                    }\n                    event.preventDefault();\n                    event.stopImmediatePropagation();\n                    const currentZoom = d3Selection.property(\"__zoom\").k || 1;\n                    const _isMacOs = isMacOs();\n                    // macos sets ctrlKey=true for pinch gesture on a trackpad\n                    if (event.ctrlKey && zoomOnPinch && _isMacOs) {\n                        const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(event);\n                        const pinchDelta = wheelDelta(event);\n                        const zoom = currentZoom * Math.pow(2, pinchDelta);\n                        // @ts-ignore\n                        d3Zoom.scaleTo(d3Selection, zoom, point, event);\n                        return;\n                    }\n                    // increase scroll speed in firefox\n                    // firefox: deltaMode === 1; chrome: deltaMode === 0\n                    const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n                    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n                    let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n                    // this enables vertical scrolling with shift + scroll on windows\n                    if (!_isMacOs && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n                        deltaX = event.deltaY * deltaNormalize;\n                        deltaY = 0;\n                    }\n                    d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, // @ts-ignore\n                    {\n                        internal: true\n                    });\n                    const nextViewport = eventToFlowTransform(d3Selection.property(\"__zoom\"));\n                    const { onViewportChangeStart, onViewportChange, onViewportChangeEnd } = store.getState();\n                    clearTimeout(panScrollTimeout.current);\n                    // for pan on scroll we need to handle the event calls on our own\n                    // we can't use the start, zoom and end events from d3-zoom\n                    // because start and move gets called on every scroll event and not once at the beginning\n                    if (!isPanScrolling.current) {\n                        isPanScrolling.current = true;\n                        onMoveStart?.(event, nextViewport);\n                        onViewportChangeStart?.(nextViewport);\n                    }\n                    if (isPanScrolling.current) {\n                        onMove?.(event, nextViewport);\n                        onViewportChange?.(nextViewport);\n                        panScrollTimeout.current = setTimeout(()=>{\n                            onMoveEnd?.(event, nextViewport);\n                            onViewportChangeEnd?.(nextViewport);\n                            isPanScrolling.current = false;\n                        }, 150);\n                    }\n                }, {\n                    passive: false\n                });\n            } else if (typeof d3ZoomHandler !== \"undefined\") {\n                d3Selection.on(\"wheel.zoom\", function(event, d) {\n                    if (!preventScrolling || isWrappedWithClass(event, noWheelClassName)) {\n                        return null;\n                    }\n                    event.preventDefault();\n                    d3ZoomHandler.call(this, event, d);\n                }, {\n                    passive: false\n                });\n            }\n        }\n    }, [\n        userSelectionActive,\n        panOnScroll,\n        panOnScrollMode,\n        d3Selection,\n        d3Zoom,\n        d3ZoomHandler,\n        zoomActivationKeyPressed,\n        zoomOnPinch,\n        preventScrolling,\n        noWheelClassName,\n        onMoveStart,\n        onMove,\n        onMoveEnd\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (d3Zoom) {\n            d3Zoom.on(\"start\", (event)=>{\n                if (!event.sourceEvent || event.sourceEvent.internal) {\n                    return null;\n                }\n                // we need to remember it here, because it's always 0 in the \"zoom\" event\n                mouseButton.current = event.sourceEvent?.button;\n                const { onViewportChangeStart } = store.getState();\n                const flowTransform = eventToFlowTransform(event.transform);\n                isZoomingOrPanning.current = true;\n                prevTransform.current = flowTransform;\n                if (event.sourceEvent?.type === \"mousedown\") {\n                    store.setState({\n                        paneDragging: true\n                    });\n                }\n                onViewportChangeStart?.(flowTransform);\n                onMoveStart?.(event.sourceEvent, flowTransform);\n            });\n        }\n    }, [\n        d3Zoom,\n        onMoveStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (d3Zoom) {\n            if (userSelectionActive && !isZoomingOrPanning.current) {\n                d3Zoom.on(\"zoom\", null);\n            } else if (!userSelectionActive) {\n                d3Zoom.on(\"zoom\", (event)=>{\n                    const { onViewportChange } = store.getState();\n                    store.setState({\n                        transform: [\n                            event.transform.x,\n                            event.transform.y,\n                            event.transform.k\n                        ]\n                    });\n                    zoomedWithRightMouseButton.current = !!(onPaneContextMenu && isRightClickPan(panOnDrag, mouseButton.current ?? 0));\n                    if ((onMove || onViewportChange) && !event.sourceEvent?.internal) {\n                        const flowTransform = eventToFlowTransform(event.transform);\n                        onViewportChange?.(flowTransform);\n                        onMove?.(event.sourceEvent, flowTransform);\n                    }\n                });\n            }\n        }\n    }, [\n        userSelectionActive,\n        d3Zoom,\n        onMove,\n        panOnDrag,\n        onPaneContextMenu\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (d3Zoom) {\n            d3Zoom.on(\"end\", (event)=>{\n                if (!event.sourceEvent || event.sourceEvent.internal) {\n                    return null;\n                }\n                const { onViewportChangeEnd } = store.getState();\n                isZoomingOrPanning.current = false;\n                store.setState({\n                    paneDragging: false\n                });\n                if (onPaneContextMenu && isRightClickPan(panOnDrag, mouseButton.current ?? 0) && !zoomedWithRightMouseButton.current) {\n                    onPaneContextMenu(event.sourceEvent);\n                }\n                zoomedWithRightMouseButton.current = false;\n                if ((onMoveEnd || onViewportChangeEnd) && viewChanged(prevTransform.current, event.transform)) {\n                    const flowTransform = eventToFlowTransform(event.transform);\n                    prevTransform.current = flowTransform;\n                    clearTimeout(timerId.current);\n                    timerId.current = setTimeout(()=>{\n                        onViewportChangeEnd?.(flowTransform);\n                        onMoveEnd?.(event.sourceEvent, flowTransform);\n                    }, panOnScroll ? 150 : 0);\n                }\n            });\n        }\n    }, [\n        d3Zoom,\n        panOnScroll,\n        panOnDrag,\n        onMoveEnd,\n        onPaneContextMenu\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (d3Zoom) {\n            d3Zoom.filter((event)=>{\n                const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n                const pinchZoom = zoomOnPinch && event.ctrlKey;\n                if ((panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(1)) && event.button === 1 && event.type === \"mousedown\" && (isWrappedWithClass(event, \"react-flow__node\") || isWrappedWithClass(event, \"react-flow__edge\"))) {\n                    return true;\n                }\n                // if all interactions are disabled, we prevent all zoom events\n                if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n                    return false;\n                }\n                // during a selection we prevent all other interactions\n                if (userSelectionActive) {\n                    return false;\n                }\n                // if zoom on double click is disabled, we prevent the double click event\n                if (!zoomOnDoubleClick && event.type === \"dblclick\") {\n                    return false;\n                }\n                // if the target element is inside an element with the nowheel class, we prevent zooming\n                if (isWrappedWithClass(event, noWheelClassName) && event.type === \"wheel\") {\n                    return false;\n                }\n                // if the target element is inside an element with the nopan class, we prevent panning\n                if (isWrappedWithClass(event, noPanClassName) && (event.type !== \"wheel\" || panOnScroll && event.type === \"wheel\" && !zoomActivationKeyPressed)) {\n                    return false;\n                }\n                if (!zoomOnPinch && event.ctrlKey && event.type === \"wheel\") {\n                    return false;\n                }\n                // when there is no scroll handling enabled, we prevent all wheel events\n                if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === \"wheel\") {\n                    return false;\n                }\n                // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n                if (!panOnDrag && (event.type === \"mousedown\" || event.type === \"touchstart\")) {\n                    return false;\n                }\n                // if the pane is only movable using allowed clicks\n                if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && (event.type === \"mousedown\" || event.type === \"touchstart\")) {\n                    return false;\n                }\n                // We only allow right clicks if pan on drag is set to right click\n                const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;\n                // default filter for d3-zoom\n                return (!event.ctrlKey || event.type === \"wheel\") && buttonAllowed;\n            });\n        }\n    }, [\n        userSelectionActive,\n        d3Zoom,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        zoomOnDoubleClick,\n        panOnDrag,\n        elementsSelectable,\n        zoomActivationKeyPressed\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle\n    }, children);\n};\nconst selector$9 = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$9, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nfunction handleParentExpand(res, updateItem) {\n    const parent = res.find((e)=>e.id === updateItem.parentNode);\n    if (parent) {\n        const extendWidth = updateItem.position.x + updateItem.width - parent.width;\n        const extendHeight = updateItem.position.y + updateItem.height - parent.height;\n        if (extendWidth > 0 || extendHeight > 0 || updateItem.position.x < 0 || updateItem.position.y < 0) {\n            parent.style = {\n                ...parent.style\n            } || {};\n            parent.style.width = parent.style.width ?? parent.width;\n            parent.style.height = parent.style.height ?? parent.height;\n            if (extendWidth > 0) {\n                parent.style.width += extendWidth;\n            }\n            if (extendHeight > 0) {\n                parent.style.height += extendHeight;\n            }\n            if (updateItem.position.x < 0) {\n                const xDiff = Math.abs(updateItem.position.x);\n                parent.position.x = parent.position.x - xDiff;\n                parent.style.width += xDiff;\n                updateItem.position.x = 0;\n            }\n            if (updateItem.position.y < 0) {\n                const yDiff = Math.abs(updateItem.position.y);\n                parent.position.y = parent.position.y - yDiff;\n                parent.style.height += yDiff;\n                updateItem.position.y = 0;\n            }\n            parent.width = parent.style.width;\n            parent.height = parent.style.height;\n        }\n    }\n}\nfunction applyChanges(changes, elements) {\n    // we need this hack to handle the setNodes and setEdges function of the useReactFlow hook for controlled flows\n    if (changes.some((c)=>c.type === \"reset\")) {\n        return changes.filter((c)=>c.type === \"reset\").map((c)=>c.item);\n    }\n    const initElements = changes.filter((c)=>c.type === \"add\").map((c)=>c.item);\n    return elements.reduce((res, item)=>{\n        const currentChanges = changes.filter((c)=>c.id === item.id);\n        if (currentChanges.length === 0) {\n            res.push(item);\n            return res;\n        }\n        const updateItem = {\n            ...item\n        };\n        for (const currentChange of currentChanges){\n            if (currentChange) {\n                switch(currentChange.type){\n                    case \"select\":\n                        {\n                            updateItem.selected = currentChange.selected;\n                            break;\n                        }\n                    case \"position\":\n                        {\n                            if (typeof currentChange.position !== \"undefined\") {\n                                updateItem.position = currentChange.position;\n                            }\n                            if (typeof currentChange.positionAbsolute !== \"undefined\") {\n                                updateItem.positionAbsolute = currentChange.positionAbsolute;\n                            }\n                            if (typeof currentChange.dragging !== \"undefined\") {\n                                updateItem.dragging = currentChange.dragging;\n                            }\n                            if (updateItem.expandParent) {\n                                handleParentExpand(res, updateItem);\n                            }\n                            break;\n                        }\n                    case \"dimensions\":\n                        {\n                            if (typeof currentChange.dimensions !== \"undefined\") {\n                                updateItem.width = currentChange.dimensions.width;\n                                updateItem.height = currentChange.dimensions.height;\n                            }\n                            if (typeof currentChange.updateStyle !== \"undefined\") {\n                                updateItem.style = {\n                                    ...updateItem.style || {},\n                                    ...currentChange.dimensions\n                                };\n                            }\n                            if (typeof currentChange.resizing === \"boolean\") {\n                                updateItem.resizing = currentChange.resizing;\n                            }\n                            if (updateItem.expandParent) {\n                                handleParentExpand(res, updateItem);\n                            }\n                            break;\n                        }\n                    case \"remove\":\n                        {\n                            return res;\n                        }\n                }\n            }\n        }\n        res.push(updateItem);\n        return res;\n    }, initElements);\n}\nfunction applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\nfunction applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nconst createSelectionChange = (id, selected)=>({\n        id,\n        type: \"select\",\n        selected\n    });\nfunction getSelectionChanges(items, selectedIds) {\n    return items.reduce((res, item)=>{\n        const willBeSelected = selectedIds.includes(item.id);\n        if (!item.selected && willBeSelected) {\n            item.selected = true;\n            res.push(createSelectionChange(item.id, true));\n        } else if (item.selected && !willBeSelected) {\n            item.selected = false;\n            res.push(createSelectionChange(item.id, false));\n        }\n        return res;\n    }, []);\n}\n/**\n * The user selection rectangle gets displayed when a user drags the mouse while pressing shift\n */ const wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$8 = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        dragging: s.paneDragging\n    });\nconst Pane = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({ isSelecting, selectionMode = SelectionMode.Full, panOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children })=>{\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const store = useStoreApi();\n    const prevSelectedNodesCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const prevSelectedEdgesCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const { userSelectionActive, elementsSelectable, dragging } = useStore(selector$8, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const resetUserSelection = ()=>{\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null\n        });\n        prevSelectedNodesCount.current = 0;\n        prevSelectedEdgesCount.current = 0;\n    };\n    const onClick = (event)=>{\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onMouseDown = (event)=>{\n        const { resetSelectedElements, domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container.current || !containerBounds.current) {\n            return;\n        }\n        const { x, y } = getEventPosition(event, containerBounds.current);\n        resetSelectedElements();\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        onSelectionStart?.(event);\n    };\n    const onMouseMove = (event)=>{\n        const { userSelectionRect, nodeInternals, edges, transform, onNodesChange, onEdgesChange, nodeOrigin, getNodes } = store.getState();\n        if (!isSelecting || !containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        store.setState({\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n        const mousePos = getEventPosition(event, containerBounds.current);\n        const startX = userSelectionRect.startX ?? 0;\n        const startY = userSelectionRect.startY ?? 0;\n        const nextUserSelectRect = {\n            ...userSelectionRect,\n            x: mousePos.x < startX ? mousePos.x : startX,\n            y: mousePos.y < startY ? mousePos.y : startY,\n            width: Math.abs(mousePos.x - startX),\n            height: Math.abs(mousePos.y - startY)\n        };\n        const nodes = getNodes();\n        const selectedNodes = getNodesInside(nodeInternals, nextUserSelectRect, transform, selectionMode === SelectionMode.Partial, true, nodeOrigin);\n        const selectedEdgeIds = getConnectedEdges(selectedNodes, edges).map((e)=>e.id);\n        const selectedNodeIds = selectedNodes.map((n)=>n.id);\n        if (prevSelectedNodesCount.current !== selectedNodeIds.length) {\n            prevSelectedNodesCount.current = selectedNodeIds.length;\n            const changes = getSelectionChanges(nodes, selectedNodeIds);\n            if (changes.length) {\n                onNodesChange?.(changes);\n            }\n        }\n        if (prevSelectedEdgesCount.current !== selectedEdgeIds.length) {\n            prevSelectedEdgesCount.current = selectedEdgeIds.length;\n            const changes = getSelectionChanges(edges, selectedEdgeIds);\n            if (changes.length) {\n                onEdgesChange?.(changes);\n            }\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect\n        });\n    };\n    const onMouseUp = (event)=>{\n        if (event.button !== 0) {\n            return;\n        }\n        const { userSelectionRect } = store.getState();\n        // We only want to trigger click functions when in selection mode if\n        // the user did not move the mouse.\n        if (!userSelectionActive && userSelectionRect && event.target === container.current) {\n            onClick?.(event);\n        }\n        store.setState({\n            nodesSelectionActive: prevSelectedNodesCount.current > 0\n        });\n        resetUserSelection();\n        onSelectionEnd?.(event);\n    };\n    const onMouseLeave = (event)=>{\n        if (userSelectionActive) {\n            store.setState({\n                nodesSelectionActive: prevSelectedNodesCount.current > 0\n            });\n            onSelectionEnd?.(event);\n        }\n        resetUserSelection();\n    };\n    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__pane\",\n            {\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onMouseEnter: hasActiveSelection ? undefined : onPaneMouseEnter,\n        onMouseDown: hasActiveSelection ? onMouseDown : undefined,\n        onMouseMove: hasActiveSelection ? onMouseMove : onPaneMouseMove,\n        onMouseUp: hasActiveSelection ? onMouseUp : undefined,\n        onMouseLeave: hasActiveSelection ? onMouseLeave : onPaneMouseLeave,\n        ref: container,\n        style: containerStyle\n    }, children, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(UserSelection, null));\n});\nPane.displayName = \"Pane\";\nfunction isParentSelected(node, nodeInternals) {\n    if (!node.parentNode) {\n        return false;\n    }\n    const parentNode = nodeInternals.get(node.parentNode);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeInternals);\n}\nfunction hasSelector(target, selector, nodeRef) {\n    let current = target;\n    do {\n        if (current?.matches(selector)) return true;\n        if (current === nodeRef.current) return false;\n        current = current.parentElement;\n    }while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeInternals, nodesDraggable, mousePos, nodeId) {\n    return Array.from(nodeInternals.values()).filter((n)=>(n.selected || n.id === nodeId) && (!n.parentNode || !isParentSelected(n, nodeInternals)) && (n.draggable || nodesDraggable && typeof n.draggable === \"undefined\")).map((n)=>({\n            id: n.id,\n            position: n.position || {\n                x: 0,\n                y: 0\n            },\n            positionAbsolute: n.positionAbsolute || {\n                x: 0,\n                y: 0\n            },\n            distance: {\n                x: mousePos.x - (n.positionAbsolute?.x ?? 0),\n                y: mousePos.y - (n.positionAbsolute?.y ?? 0)\n            },\n            delta: {\n                x: 0,\n                y: 0\n            },\n            extent: n.extent,\n            parentNode: n.parentNode,\n            width: n.width,\n            height: n.height,\n            expandParent: n.expandParent\n        }));\n}\nfunction clampNodeExtent(node, extent) {\n    if (!extent || extent === \"parent\") {\n        return extent;\n    }\n    return [\n        extent[0],\n        [\n            extent[1][0] - (node.width || 0),\n            extent[1][1] - (node.height || 0)\n        ]\n    ];\n}\nfunction calcNextPosition(node, nextPosition, nodeInternals, nodeExtent, nodeOrigin = [\n    0,\n    0\n], onError) {\n    const clampedNodeExtent = clampNodeExtent(node, node.extent || nodeExtent);\n    let currentExtent = clampedNodeExtent;\n    if (node.extent === \"parent\" && !node.expandParent) {\n        if (node.parentNode && node.width && node.height) {\n            const parent = nodeInternals.get(node.parentNode);\n            const { x: parentX, y: parentY } = getNodePositionWithOrigin(parent, nodeOrigin).positionAbsolute;\n            currentExtent = parent && isNumeric(parentX) && isNumeric(parentY) && isNumeric(parent.width) && isNumeric(parent.height) ? [\n                [\n                    parentX + node.width * nodeOrigin[0],\n                    parentY + node.height * nodeOrigin[1]\n                ],\n                [\n                    parentX + parent.width - node.width + node.width * nodeOrigin[0],\n                    parentY + parent.height - node.height + node.height * nodeOrigin[1]\n                ]\n            ] : currentExtent;\n        } else {\n            onError?.(\"005\", errorMessages[\"error005\"]());\n            currentExtent = clampedNodeExtent;\n        }\n    } else if (node.extent && node.parentNode && node.extent !== \"parent\") {\n        const parent = nodeInternals.get(node.parentNode);\n        const { x: parentX, y: parentY } = getNodePositionWithOrigin(parent, nodeOrigin).positionAbsolute;\n        currentExtent = [\n            [\n                node.extent[0][0] + parentX,\n                node.extent[0][1] + parentY\n            ],\n            [\n                node.extent[1][0] + parentX,\n                node.extent[1][1] + parentY\n            ]\n        ];\n    }\n    let parentPosition = {\n        x: 0,\n        y: 0\n    };\n    if (node.parentNode) {\n        const parentNode = nodeInternals.get(node.parentNode);\n        parentPosition = getNodePositionWithOrigin(parentNode, nodeOrigin).positionAbsolute;\n    }\n    const positionAbsolute = currentExtent && currentExtent !== \"parent\" ? clampPosition(nextPosition, currentExtent) : nextPosition;\n    return {\n        position: {\n            x: positionAbsolute.x - parentPosition.x,\n            y: positionAbsolute.y - parentPosition.y\n        },\n        positionAbsolute\n    };\n}\n// returns two params:\n// 1. the dragged node (or the first of the list, if we are dragging a node selection)\n// 2. array of selected nodes (for multi selections)\nfunction getEventHandlerParams({ nodeId, dragItems, nodeInternals }) {\n    const extentedDragItems = dragItems.map((n)=>{\n        const node = nodeInternals.get(n.id);\n        return {\n            ...node,\n            position: n.position,\n            positionAbsolute: n.positionAbsolute\n        };\n    });\n    return [\n        nodeId ? extentedDragItems.find((n)=>n.id === nodeId) : extentedDragItems[0],\n        extentedDragItems\n    ];\n}\nconst getHandleBounds = (selector, nodeElement, zoom, nodeOrigin)=>{\n    const handles = nodeElement.querySelectorAll(selector);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    const handlesArray = Array.from(handles);\n    const nodeBounds = nodeElement.getBoundingClientRect();\n    const nodeOffset = {\n        x: nodeBounds.width * nodeOrigin[0],\n        y: nodeBounds.height * nodeOrigin[1]\n    };\n    return handlesArray.map((handle)=>{\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute(\"data-handleid\"),\n            position: handle.getAttribute(\"data-handlepos\"),\n            x: (handleBounds.left - nodeBounds.left - nodeOffset.x) / zoom,\n            y: (handleBounds.top - nodeBounds.top - nodeOffset.y) / zoom,\n            ...getDimensions(handle)\n        };\n    });\n};\nfunction getMouseHandler(id, getState, handler) {\n    return handler === undefined ? handler : (event)=>{\n        const node = getState().nodeInternals.get(id);\n        if (node) {\n            handler(event, {\n                ...node\n            });\n        }\n    };\n}\n// this handler is called by\n// 1. the click handler when node is not draggable or selectNodesOnDrag = false\n// or\n// 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\nfunction handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeInternals, onError } = store.getState();\n    const node = nodeInternals.get(id);\n    if (!node) {\n        onError?.(\"012\", errorMessages[\"error012\"](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\nfunction useGetPointerPosition() {\n    const store = useStoreApi();\n    // returns the pointer position projected to the RF coordinate system\n    const getPointerPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ sourceEvent })=>{\n        const { transform, snapGrid, snapToGrid } = store.getState();\n        const x = sourceEvent.touches ? sourceEvent.touches[0].clientX : sourceEvent.clientX;\n        const y = sourceEvent.touches ? sourceEvent.touches[0].clientY : sourceEvent.clientY;\n        const pointerPos = {\n            x: (x - transform[0]) / transform[2],\n            y: (y - transform[1]) / transform[2]\n        };\n        // we need the snapped position in order to be able to skip unnecessary drag events\n        return {\n            xSnapped: snapToGrid ? snapGrid[0] * Math.round(pointerPos.x / snapGrid[0]) : pointerPos.x,\n            ySnapped: snapToGrid ? snapGrid[1] * Math.round(pointerPos.y / snapGrid[1]) : pointerPos.y,\n            ...pointerPos\n        };\n    }, []);\n    return getPointerPosition;\n}\nfunction wrapSelectionDragFunc(selectionFunc) {\n    return (event, _, nodes)=>selectionFunc?.(event, nodes);\n}\nfunction useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, selectNodesOnDrag }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const dragItems = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const lastPos = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: null,\n        y: null\n    });\n    const autoPanId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const mousePosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const dragEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const autoPanStarted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const dragStarted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const getPointerPosition = useGetPointerPosition();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (nodeRef?.current) {\n            const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(nodeRef.current);\n            const updateNodes = ({ x, y })=>{\n                const { nodeInternals, onNodeDrag, onSelectionDrag, updateNodePositions, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onError } = store.getState();\n                lastPos.current = {\n                    x,\n                    y\n                };\n                let hasChange = false;\n                let nodesBox = {\n                    x: 0,\n                    y: 0,\n                    x2: 0,\n                    y2: 0\n                };\n                if (dragItems.current.length > 1 && nodeExtent) {\n                    const rect = getNodesBounds(dragItems.current, nodeOrigin);\n                    nodesBox = rectToBox(rect);\n                }\n                dragItems.current = dragItems.current.map((n)=>{\n                    const nextPosition = {\n                        x: x - n.distance.x,\n                        y: y - n.distance.y\n                    };\n                    if (snapToGrid) {\n                        nextPosition.x = snapGrid[0] * Math.round(nextPosition.x / snapGrid[0]);\n                        nextPosition.y = snapGrid[1] * Math.round(nextPosition.y / snapGrid[1]);\n                    }\n                    // if there is selection with multiple nodes and a node extent is set, we need to adjust the node extent for each node\n                    // based on its position so that the node stays at it's position relative to the selection.\n                    const adjustedNodeExtent = [\n                        [\n                            nodeExtent[0][0],\n                            nodeExtent[0][1]\n                        ],\n                        [\n                            nodeExtent[1][0],\n                            nodeExtent[1][1]\n                        ]\n                    ];\n                    if (dragItems.current.length > 1 && nodeExtent && !n.extent) {\n                        adjustedNodeExtent[0][0] = n.positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                        adjustedNodeExtent[1][0] = n.positionAbsolute.x + (n.width ?? 0) - nodesBox.x2 + nodeExtent[1][0];\n                        adjustedNodeExtent[0][1] = n.positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                        adjustedNodeExtent[1][1] = n.positionAbsolute.y + (n.height ?? 0) - nodesBox.y2 + nodeExtent[1][1];\n                    }\n                    const updatedPos = calcNextPosition(n, nextPosition, nodeInternals, adjustedNodeExtent, nodeOrigin, onError);\n                    // we want to make sure that we only fire a change event when there is a change\n                    hasChange = hasChange || n.position.x !== updatedPos.position.x || n.position.y !== updatedPos.position.y;\n                    n.position = updatedPos.position;\n                    n.positionAbsolute = updatedPos.positionAbsolute;\n                    return n;\n                });\n                if (!hasChange) {\n                    return;\n                }\n                updateNodePositions(dragItems.current, true, true);\n                setDragging(true);\n                const onDrag = nodeId ? onNodeDrag : wrapSelectionDragFunc(onSelectionDrag);\n                if (onDrag && dragEvent.current) {\n                    const [currentNode, nodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems: dragItems.current,\n                        nodeInternals\n                    });\n                    onDrag(dragEvent.current, currentNode, nodes);\n                }\n            };\n            const autoPan = ()=>{\n                if (!containerBounds.current) {\n                    return;\n                }\n                const [xMovement, yMovement] = calcAutoPan(mousePosition.current, containerBounds.current);\n                if (xMovement !== 0 || yMovement !== 0) {\n                    const { transform, panBy } = store.getState();\n                    lastPos.current.x = (lastPos.current.x ?? 0) - xMovement / transform[2];\n                    lastPos.current.y = (lastPos.current.y ?? 0) - yMovement / transform[2];\n                    if (panBy({\n                        x: xMovement,\n                        y: yMovement\n                    })) {\n                        updateNodes(lastPos.current);\n                    }\n                }\n                autoPanId.current = requestAnimationFrame(autoPan);\n            };\n            const startDrag = (event)=>{\n                const { nodeInternals, multiSelectionActive, nodesDraggable, unselectNodesAndEdges, onNodeDragStart, onSelectionDragStart } = store.getState();\n                dragStarted.current = true;\n                const onStart = nodeId ? onNodeDragStart : wrapSelectionDragFunc(onSelectionDragStart);\n                if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                    if (!nodeInternals.get(nodeId)?.selected) {\n                        // we need to reset selected nodes when selectNodesOnDrag=false\n                        unselectNodesAndEdges();\n                    }\n                }\n                if (nodeId && isSelectable && selectNodesOnDrag) {\n                    handleNodeClick({\n                        id: nodeId,\n                        store,\n                        nodeRef: nodeRef\n                    });\n                }\n                const pointerPos = getPointerPosition(event);\n                lastPos.current = pointerPos;\n                dragItems.current = getDragItems(nodeInternals, nodesDraggable, pointerPos, nodeId);\n                if (onStart && dragItems.current) {\n                    const [currentNode, nodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems: dragItems.current,\n                        nodeInternals\n                    });\n                    onStart(event.sourceEvent, currentNode, nodes);\n                }\n            };\n            if (disabled) {\n                selection.on(\".drag\", null);\n            } else {\n                const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_8__[\"default\"])().on(\"start\", (event)=>{\n                    const { domNode, nodeDragThreshold } = store.getState();\n                    if (nodeDragThreshold === 0) {\n                        startDrag(event);\n                    }\n                    const pointerPos = getPointerPosition(event);\n                    lastPos.current = pointerPos;\n                    containerBounds.current = domNode?.getBoundingClientRect() || null;\n                    mousePosition.current = getEventPosition(event.sourceEvent, containerBounds.current);\n                }).on(\"drag\", (event)=>{\n                    const pointerPos = getPointerPosition(event);\n                    const { autoPanOnNodeDrag, nodeDragThreshold } = store.getState();\n                    if (!autoPanStarted.current && dragStarted.current && autoPanOnNodeDrag) {\n                        autoPanStarted.current = true;\n                        autoPan();\n                    }\n                    if (!dragStarted.current) {\n                        const x = pointerPos.xSnapped - (lastPos?.current?.x ?? 0);\n                        const y = pointerPos.ySnapped - (lastPos?.current?.y ?? 0);\n                        const distance = Math.sqrt(x * x + y * y);\n                        if (distance > nodeDragThreshold) {\n                            startDrag(event);\n                        }\n                    }\n                    // skip events without movement\n                    if ((lastPos.current.x !== pointerPos.xSnapped || lastPos.current.y !== pointerPos.ySnapped) && dragItems.current && dragStarted.current) {\n                        dragEvent.current = event.sourceEvent;\n                        mousePosition.current = getEventPosition(event.sourceEvent, containerBounds.current);\n                        updateNodes(pointerPos);\n                    }\n                }).on(\"end\", (event)=>{\n                    if (!dragStarted.current) {\n                        return;\n                    }\n                    setDragging(false);\n                    autoPanStarted.current = false;\n                    dragStarted.current = false;\n                    cancelAnimationFrame(autoPanId.current);\n                    if (dragItems.current) {\n                        const { updateNodePositions, nodeInternals, onNodeDragStop, onSelectionDragStop } = store.getState();\n                        const onStop = nodeId ? onNodeDragStop : wrapSelectionDragFunc(onSelectionDragStop);\n                        updateNodePositions(dragItems.current, false, false);\n                        if (onStop) {\n                            const [currentNode, nodes] = getEventHandlerParams({\n                                nodeId,\n                                dragItems: dragItems.current,\n                                nodeInternals\n                            });\n                            onStop(event.sourceEvent, currentNode, nodes);\n                        }\n                    }\n                }).filter((event)=>{\n                    const target = event.target;\n                    const isDraggable = !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, nodeRef)) && (!handleSelector || hasSelector(target, handleSelector, nodeRef));\n                    return isDraggable;\n                });\n                selection.call(dragHandler);\n                return ()=>{\n                    selection.on(\".drag\", null);\n                };\n            }\n        }\n    }, [\n        nodeRef,\n        disabled,\n        noDragClassName,\n        handleSelector,\n        isSelectable,\n        store,\n        nodeId,\n        selectNodesOnDrag,\n        getPointerPosition\n    ]);\n    return dragging;\n}\nfunction useUpdateNodePositions() {\n    const store = useStoreApi();\n    const updatePositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((params)=>{\n        const { nodeInternals, nodeExtent, updateNodePositions, getNodes, snapToGrid, snapGrid, onError, nodesDraggable } = store.getState();\n        const selectedNodes = getNodes().filter((n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === \"undefined\"));\n        // by default a node moves 5px on each key press, or 20px if shift is pressed\n        // if snap grid is enabled, we use that for the velocity.\n        const xVelo = snapToGrid ? snapGrid[0] : 5;\n        const yVelo = snapToGrid ? snapGrid[1] : 5;\n        const factor = params.isShiftPressed ? 4 : 1;\n        const positionDiffX = params.x * xVelo * factor;\n        const positionDiffY = params.y * yVelo * factor;\n        const nodeUpdates = selectedNodes.map((n)=>{\n            if (n.positionAbsolute) {\n                const nextPosition = {\n                    x: n.positionAbsolute.x + positionDiffX,\n                    y: n.positionAbsolute.y + positionDiffY\n                };\n                if (snapToGrid) {\n                    nextPosition.x = snapGrid[0] * Math.round(nextPosition.x / snapGrid[0]);\n                    nextPosition.y = snapGrid[1] * Math.round(nextPosition.y / snapGrid[1]);\n                }\n                const { positionAbsolute, position } = calcNextPosition(n, nextPosition, nodeInternals, nodeExtent, undefined, onError);\n                n.position = position;\n                n.positionAbsolute = positionAbsolute;\n            }\n            return n;\n        });\n        updateNodePositions(nodeUpdates, true, false);\n    }, []);\n    return updatePositions;\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nvar wrapNode = (NodeComponent)=>{\n    const NodeWrapper = ({ id, type, data, xPos, yPos, xPosOrigin, yPosOrigin, selected, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, style, className, isDraggable, isSelectable, isConnectable, isFocusable, selectNodesOnDrag, sourcePosition, targetPosition, hidden, resizeObserver, dragHandle, zIndex, isParent, noDragClassName, noPanClassName, initialized, disableKeyboardA11y, ariaLabel, rfId })=>{\n        const store = useStoreApi();\n        const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n        const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(sourcePosition);\n        const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(targetPosition);\n        const prevType = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(type);\n        const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n        const updatePositions = useUpdateNodePositions();\n        const onMouseEnterHandler = getMouseHandler(id, store.getState, onMouseEnter);\n        const onMouseMoveHandler = getMouseHandler(id, store.getState, onMouseMove);\n        const onMouseLeaveHandler = getMouseHandler(id, store.getState, onMouseLeave);\n        const onContextMenuHandler = getMouseHandler(id, store.getState, onContextMenu);\n        const onDoubleClickHandler = getMouseHandler(id, store.getState, onDoubleClick);\n        const onSelectNodeHandler = (event)=>{\n            const { nodeDragThreshold } = store.getState();\n            if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n                // this handler gets called within the drag start event when selectNodesOnDrag=true\n                handleNodeClick({\n                    id,\n                    store,\n                    nodeRef\n                });\n            }\n            if (onClick) {\n                const node = store.getState().nodeInternals.get(id);\n                if (node) {\n                    onClick(event, {\n                        ...node\n                    });\n                }\n            }\n        };\n        const onKeyDown = (event)=>{\n            if (isInputDOMNode(event)) {\n                return;\n            }\n            if (elementSelectionKeys.includes(event.key) && isSelectable) {\n                const unselect = event.key === \"Escape\";\n                handleNodeClick({\n                    id,\n                    store,\n                    unselect,\n                    nodeRef\n                });\n            } else if (!disableKeyboardA11y && isDraggable && selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n                store.setState({\n                    ariaLiveMessage: `Moved selected node ${event.key.replace(\"Arrow\", \"\").toLowerCase()}. New position, x: ${~~xPos}, y: ${~~yPos}`\n                });\n                updatePositions({\n                    x: arrowKeyDiffs[event.key].x,\n                    y: arrowKeyDiffs[event.key].y,\n                    isShiftPressed: event.shiftKey\n                });\n            }\n        };\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            if (nodeRef.current && !hidden) {\n                const currNode = nodeRef.current;\n                resizeObserver?.observe(currNode);\n                return ()=>resizeObserver?.unobserve(currNode);\n            }\n        }, [\n            hidden\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            // when the user programmatically changes the source or handle position, we re-initialize the node\n            const typeChanged = prevType.current !== type;\n            const sourcePosChanged = prevSourcePosition.current !== sourcePosition;\n            const targetPosChanged = prevTargetPosition.current !== targetPosition;\n            if (nodeRef.current && (typeChanged || sourcePosChanged || targetPosChanged)) {\n                if (typeChanged) {\n                    prevType.current = type;\n                }\n                if (sourcePosChanged) {\n                    prevSourcePosition.current = sourcePosition;\n                }\n                if (targetPosChanged) {\n                    prevTargetPosition.current = targetPosition;\n                }\n                store.getState().updateNodeDimensions([\n                    {\n                        id,\n                        nodeElement: nodeRef.current,\n                        forceUpdate: true\n                    }\n                ]);\n            }\n        }, [\n            id,\n            type,\n            sourcePosition,\n            targetPosition\n        ]);\n        const dragging = useDrag({\n            nodeRef,\n            disabled: hidden || !isDraggable,\n            noDragClassName,\n            handleSelector: dragHandle,\n            nodeId: id,\n            isSelectable,\n            selectNodesOnDrag\n        });\n        if (hidden) {\n            return null;\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                \"react-flow__node\",\n                `react-flow__node-${type}`,\n                {\n                    // this is overwritable by passing `nopan` as a class name\n                    [noPanClassName]: isDraggable\n                },\n                className,\n                {\n                    selected,\n                    selectable: isSelectable,\n                    parent: isParent,\n                    dragging\n                }\n            ]),\n            ref: nodeRef,\n            style: {\n                zIndex,\n                transform: `translate(${xPosOrigin}px,${yPosOrigin}px)`,\n                pointerEvents: hasPointerEvents ? \"all\" : \"none\",\n                visibility: initialized ? \"visible\" : \"hidden\",\n                ...style\n            },\n            \"data-id\": id,\n            \"data-testid\": `rf__node-${id}`,\n            onMouseEnter: onMouseEnterHandler,\n            onMouseMove: onMouseMoveHandler,\n            onMouseLeave: onMouseLeaveHandler,\n            onContextMenu: onContextMenuHandler,\n            onClick: onSelectNodeHandler,\n            onDoubleClick: onDoubleClickHandler,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: isFocusable ? \"button\" : undefined,\n            \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n            \"aria-label\": ariaLabel\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider, {\n            value: id\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodeComponent, {\n            id: id,\n            data: data,\n            type: type,\n            xPos: xPos,\n            yPos: yPos,\n            selected: selected,\n            isConnectable: isConnectable,\n            sourcePosition: sourcePosition,\n            targetPosition: targetPosition,\n            dragging: dragging,\n            dragHandle: dragHandle,\n            zIndex: zIndex\n        })));\n    };\n    NodeWrapper.displayName = \"NodeWrapper\";\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(NodeWrapper);\n};\n/**\n * The nodes selection rectangle gets displayed when a user\n * made a selection with on or several nodes\n */ const selector$7 = (s)=>{\n    const selectedNodes = s.getNodes().filter((n)=>n.selected);\n    return {\n        ...getNodesBounds(selectedNodes, s.nodeOrigin),\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, x: left, y: top, transformString, userSelectionActive } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const updatePositions = useUpdateNodePositions();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!disableKeyboardA11y) {\n            nodeRef.current?.focus({\n                preventScroll: true\n            });\n        }\n    }, [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().getNodes().filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            updatePositions({\n                x: arrowKeyDiffs[event.key].x,\n                y: arrowKeyDiffs[event.key].y,\n                isShiftPressed: event.shiftKey\n            });\n        }\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__nodesselection\",\n            \"react-flow__container\",\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: nodeRef,\n        className: \"react-flow__nodesselection-rect\",\n        onContextMenu: onContextMenu,\n        tabIndex: disableKeyboardA11y ? undefined : -1,\n        onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n        style: {\n            width,\n            height,\n            top,\n            left\n        }\n    }));\n}\nvar NodesSelection$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(NodesSelection);\nconst selector$6 = (s)=>s.nodesSelectionActive;\nconst FlowRenderer = ({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, deleteKeyCode, onMove, onMoveStart, onMoveEnd, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y })=>{\n    const nodesSelectionActive = useStore(selector$6);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode);\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode);\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const isSelecting = selectionKeyPressed || selectionOnDrag && panOnDrag !== true;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ZoomPane, {\n        onMove: onMove,\n        onMoveStart: onMoveStart,\n        onMoveEnd: onMoveEnd,\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Pane, {\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        panOnDrag: panOnDrag,\n        isSelecting: !!isSelecting,\n        selectionMode: selectionMode\n    }, children, nodesSelectionActive && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodesSelection$1, {\n        onSelectionContextMenu: onSelectionContextMenu,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y\n    })));\n};\nFlowRenderer.displayName = \"FlowRenderer\";\nvar FlowRenderer$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(FlowRenderer);\nfunction useVisibleNodes(onlyRenderVisible) {\n    const nodes = useStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((s)=>onlyRenderVisible ? getNodesInside(s.nodeInternals, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true) : s.getNodes(), [\n        onlyRenderVisible\n    ]));\n    return nodes;\n}\nfunction createNodeTypes(nodeTypes) {\n    const standardTypes = {\n        input: wrapNode(nodeTypes.input || InputNode$1),\n        default: wrapNode(nodeTypes.default || DefaultNode$1),\n        output: wrapNode(nodeTypes.output || OutputNode$1),\n        group: wrapNode(nodeTypes.group || GroupNode)\n    };\n    const wrappedTypes = {};\n    const specialTypes = Object.keys(nodeTypes).filter((k)=>![\n            \"input\",\n            \"default\",\n            \"output\",\n            \"group\"\n        ].includes(k)).reduce((res, key)=>{\n        res[key] = wrapNode(nodeTypes[key] || DefaultNode$1);\n        return res;\n    }, wrappedTypes);\n    return {\n        ...standardTypes,\n        ...specialTypes\n    };\n}\nconst getPositionWithOrigin = ({ x, y, width, height, origin })=>{\n    if (!width || !height) {\n        return {\n            x,\n            y\n        };\n    }\n    if (origin[0] < 0 || origin[1] < 0 || origin[0] > 1 || origin[1] > 1) {\n        return {\n            x,\n            y\n        };\n    }\n    return {\n        x: x - width * origin[0],\n        y: y - height * origin[1]\n    };\n};\nconst selector$5 = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        updateNodeDimensions: s.updateNodeDimensions,\n        onError: s.onError\n    });\nconst NodeRenderer = (props)=>{\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, updateNodeDimensions, onError } = useStore(selector$5, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const nodes = useVisibleNodes(props.onlyRenderVisibleElements);\n    const resizeObserverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const resizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof ResizeObserver === \"undefined\") {\n            return null;\n        }\n        const observer = new ResizeObserver((entries)=>{\n            const updates = entries.map((entry)=>({\n                    id: entry.target.getAttribute(\"data-id\"),\n                    nodeElement: entry.target,\n                    forceUpdate: true\n                }));\n            updateNodeDimensions(updates);\n        });\n        resizeObserverRef.current = observer;\n        return observer;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            resizeObserverRef?.current?.disconnect();\n        };\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle\n    }, nodes.map((node)=>{\n        let nodeType = node.type || \"default\";\n        if (!props.nodeTypes[nodeType]) {\n            onError?.(\"003\", errorMessages[\"error003\"](nodeType));\n            nodeType = \"default\";\n        }\n        const NodeComponent = props.nodeTypes[nodeType] || props.nodeTypes.default;\n        const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === \"undefined\");\n        const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === \"undefined\");\n        const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === \"undefined\");\n        const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === \"undefined\");\n        const clampedPosition = props.nodeExtent ? clampPosition(node.positionAbsolute, props.nodeExtent) : node.positionAbsolute;\n        const posX = clampedPosition?.x ?? 0;\n        const posY = clampedPosition?.y ?? 0;\n        const posOrigin = getPositionWithOrigin({\n            x: posX,\n            y: posY,\n            width: node.width ?? 0,\n            height: node.height ?? 0,\n            origin: props.nodeOrigin\n        });\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodeComponent, {\n            key: node.id,\n            id: node.id,\n            className: node.className,\n            style: node.style,\n            type: nodeType,\n            data: node.data,\n            sourcePosition: node.sourcePosition || Position.Bottom,\n            targetPosition: node.targetPosition || Position.Top,\n            hidden: node.hidden,\n            xPos: posX,\n            yPos: posY,\n            xPosOrigin: posOrigin.x,\n            yPosOrigin: posOrigin.y,\n            selectNodesOnDrag: props.selectNodesOnDrag,\n            onClick: props.onNodeClick,\n            onMouseEnter: props.onNodeMouseEnter,\n            onMouseMove: props.onNodeMouseMove,\n            onMouseLeave: props.onNodeMouseLeave,\n            onContextMenu: props.onNodeContextMenu,\n            onDoubleClick: props.onNodeDoubleClick,\n            selected: !!node.selected,\n            isDraggable: isDraggable,\n            isSelectable: isSelectable,\n            isConnectable: isConnectable,\n            isFocusable: isFocusable,\n            resizeObserver: resizeObserver,\n            dragHandle: node.dragHandle,\n            zIndex: node[internalsSymbol]?.z ?? 0,\n            isParent: !!node[internalsSymbol]?.isParent,\n            noDragClassName: props.noDragClassName,\n            noPanClassName: props.noPanClassName,\n            initialized: !!node.width && !!node.height,\n            rfId: props.rfId,\n            disableKeyboardA11y: props.disableKeyboardA11y,\n            ariaLabel: node.ariaLabel\n        });\n    }));\n};\nNodeRenderer.displayName = \"NodeRenderer\";\nvar NodeRenderer$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(NodeRenderer);\nconst shiftX = (x, shift, position)=>{\n    if (position === Position.Left) return x - shift;\n    if (position === Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === Position.Top) return y - shift;\n    if (position === Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = \"react-flow__edgeupdater\";\nconst EdgeAnchor = ({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\nconst alwaysValidConnection = ()=>true;\nvar wrapEdge = (EdgeComponent)=>{\n    const EdgeWrapper = ({ id, className, type, data, onClick, onEdgeDoubleClick, selected, animated, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, source, target, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, elementsSelectable, hidden, sourceHandleId, targetHandleId, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, edgeUpdaterRadius, onEdgeUpdate, onEdgeUpdateStart, onEdgeUpdateEnd, markerEnd, markerStart, rfId, ariaLabel, isFocusable, isUpdatable, pathOptions, interactionWidth })=>{\n        const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n        const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n        const [updating, setUpdating] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n        const store = useStoreApi();\n        const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`url(#${getMarkerId(markerStart, rfId)})`, [\n            markerStart,\n            rfId\n        ]);\n        const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`url(#${getMarkerId(markerEnd, rfId)})`, [\n            markerEnd,\n            rfId\n        ]);\n        if (hidden) {\n            return null;\n        }\n        const onEdgeClick = (event)=>{\n            const { edges, addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n            const edge = edges.find((e)=>e.id === id);\n            if (!edge) {\n                return;\n            }\n            if (elementsSelectable) {\n                store.setState({\n                    nodesSelectionActive: false\n                });\n                if (edge.selected && multiSelectionActive) {\n                    unselectNodesAndEdges({\n                        nodes: [],\n                        edges: [\n                            edge\n                        ]\n                    });\n                    edgeRef.current?.blur();\n                } else {\n                    addSelectedEdges([\n                        id\n                    ]);\n                }\n            }\n            if (onClick) {\n                onClick(event, edge);\n            }\n        };\n        const onEdgeDoubleClickHandler = getMouseHandler$1(id, store.getState, onEdgeDoubleClick);\n        const onEdgeContextMenu = getMouseHandler$1(id, store.getState, onContextMenu);\n        const onEdgeMouseEnter = getMouseHandler$1(id, store.getState, onMouseEnter);\n        const onEdgeMouseMove = getMouseHandler$1(id, store.getState, onMouseMove);\n        const onEdgeMouseLeave = getMouseHandler$1(id, store.getState, onMouseLeave);\n        const handleEdgeUpdater = (event, isSourceHandle)=>{\n            // avoid triggering edge updater if mouse btn is not left\n            if (event.button !== 0) {\n                return;\n            }\n            const { edges, isValidConnection: isValidConnectionStore } = store.getState();\n            const nodeId = isSourceHandle ? target : source;\n            const handleId = (isSourceHandle ? targetHandleId : sourceHandleId) || null;\n            const handleType = isSourceHandle ? \"target\" : \"source\";\n            const isValidConnection = isValidConnectionStore || alwaysValidConnection;\n            const isTarget = isSourceHandle;\n            const edge = edges.find((e)=>e.id === id);\n            setUpdating(true);\n            onEdgeUpdateStart?.(event, edge, handleType);\n            const _onEdgeUpdateEnd = (evt)=>{\n                setUpdating(false);\n                onEdgeUpdateEnd?.(evt, edge, handleType);\n            };\n            const onConnectEdge = (connection)=>onEdgeUpdate?.(edge, connection);\n            handlePointerDown({\n                event,\n                handleId,\n                nodeId,\n                onConnect: onConnectEdge,\n                isTarget,\n                getState: store.getState,\n                setState: store.setState,\n                isValidConnection,\n                edgeUpdaterType: handleType,\n                onEdgeUpdateEnd: _onEdgeUpdateEnd\n            });\n        };\n        const onEdgeUpdaterSourceMouseDown = (event)=>handleEdgeUpdater(event, true);\n        const onEdgeUpdaterTargetMouseDown = (event)=>handleEdgeUpdater(event, false);\n        const onEdgeUpdaterMouseEnter = ()=>setUpdateHover(true);\n        const onEdgeUpdaterMouseOut = ()=>setUpdateHover(false);\n        const inactive = !elementsSelectable && !onClick;\n        const onKeyDown = (event)=>{\n            if (elementSelectionKeys.includes(event.key) && elementsSelectable) {\n                const { unselectNodesAndEdges, addSelectedEdges, edges } = store.getState();\n                const unselect = event.key === \"Escape\";\n                if (unselect) {\n                    edgeRef.current?.blur();\n                    unselectNodesAndEdges({\n                        edges: [\n                            edges.find((e)=>e.id === id)\n                        ]\n                    });\n                } else {\n                    addSelectedEdges([\n                        id\n                    ]);\n                }\n            }\n        };\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                \"react-flow__edge\",\n                `react-flow__edge-${type}`,\n                className,\n                {\n                    selected,\n                    animated,\n                    inactive,\n                    updating: updateHover\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClickHandler,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: isFocusable ? \"button\" : \"img\",\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": ariaLabel === null ? undefined : ariaLabel ? ariaLabel : `Edge from ${source} to ${target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef\n        }, !updating && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeComponent, {\n            id: id,\n            source: source,\n            target: target,\n            selected: selected,\n            animated: animated,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            data: data,\n            style: style,\n            sourceX: sourceX,\n            sourceY: sourceY,\n            targetX: targetX,\n            targetY: targetY,\n            sourcePosition: sourcePosition,\n            targetPosition: targetPosition,\n            sourceHandleId: sourceHandleId,\n            targetHandleId: targetHandleId,\n            markerStart: markerStartUrl,\n            markerEnd: markerEndUrl,\n            pathOptions: pathOptions,\n            interactionWidth: interactionWidth\n        }), isUpdatable && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (isUpdatable === \"source\" || isUpdatable === true) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeAnchor, {\n            position: sourcePosition,\n            centerX: sourceX,\n            centerY: sourceY,\n            radius: edgeUpdaterRadius,\n            onMouseDown: onEdgeUpdaterSourceMouseDown,\n            onMouseEnter: onEdgeUpdaterMouseEnter,\n            onMouseOut: onEdgeUpdaterMouseOut,\n            type: \"source\"\n        }), (isUpdatable === \"target\" || isUpdatable === true) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeAnchor, {\n            position: targetPosition,\n            centerX: targetX,\n            centerY: targetY,\n            radius: edgeUpdaterRadius,\n            onMouseDown: onEdgeUpdaterTargetMouseDown,\n            onMouseEnter: onEdgeUpdaterMouseEnter,\n            onMouseOut: onEdgeUpdaterMouseOut,\n            type: \"target\"\n        })));\n    };\n    EdgeWrapper.displayName = \"EdgeWrapper\";\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(EdgeWrapper);\n};\nfunction createEdgeTypes(edgeTypes) {\n    const standardTypes = {\n        default: wrapEdge(edgeTypes.default || BezierEdge),\n        straight: wrapEdge(edgeTypes.bezier || StraightEdge),\n        step: wrapEdge(edgeTypes.step || StepEdge),\n        smoothstep: wrapEdge(edgeTypes.step || SmoothStepEdge),\n        simplebezier: wrapEdge(edgeTypes.simplebezier || SimpleBezierEdge)\n    };\n    const wrappedTypes = {};\n    const specialTypes = Object.keys(edgeTypes).filter((k)=>![\n            \"default\",\n            \"bezier\"\n        ].includes(k)).reduce((res, key)=>{\n        res[key] = wrapEdge(edgeTypes[key] || BezierEdge);\n        return res;\n    }, wrappedTypes);\n    return {\n        ...standardTypes,\n        ...specialTypes\n    };\n}\nfunction getHandlePosition(position, nodeRect, handle = null) {\n    const x = (handle?.x || 0) + nodeRect.x;\n    const y = (handle?.y || 0) + nodeRect.y;\n    const width = handle?.width || nodeRect.width;\n    const height = handle?.height || nodeRect.height;\n    switch(position){\n        case Position.Top:\n            return {\n                x: x + width / 2,\n                y\n            };\n        case Position.Right:\n            return {\n                x: x + width,\n                y: y + height / 2\n            };\n        case Position.Bottom:\n            return {\n                x: x + width / 2,\n                y: y + height\n            };\n        case Position.Left:\n            return {\n                x,\n                y: y + height / 2\n            };\n    }\n}\nfunction getHandle(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    if (bounds.length === 1 || !handleId) {\n        return bounds[0];\n    } else if (handleId) {\n        return bounds.find((d)=>d.id === handleId) || null;\n    }\n    return null;\n}\nconst getEdgePositions = (sourceNodeRect, sourceHandle, sourcePosition, targetNodeRect, targetHandle, targetPosition)=>{\n    const sourceHandlePos = getHandlePosition(sourcePosition, sourceNodeRect, sourceHandle);\n    const targetHandlePos = getHandlePosition(targetPosition, targetNodeRect, targetHandle);\n    return {\n        sourceX: sourceHandlePos.x,\n        sourceY: sourceHandlePos.y,\n        targetX: targetHandlePos.x,\n        targetY: targetHandlePos.y\n    };\n};\nfunction isEdgeVisible({ sourcePos, targetPos, sourceWidth, sourceHeight, targetWidth, targetHeight, width, height, transform }) {\n    const edgeBox = {\n        x: Math.min(sourcePos.x, targetPos.x),\n        y: Math.min(sourcePos.y, targetPos.y),\n        x2: Math.max(sourcePos.x + sourceWidth, targetPos.x + targetWidth),\n        y2: Math.max(sourcePos.y + sourceHeight, targetPos.y + targetHeight)\n    };\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewBox = rectToBox({\n        x: (0 - transform[0]) / transform[2],\n        y: (0 - transform[1]) / transform[2],\n        width: width / transform[2],\n        height: height / transform[2]\n    });\n    const xOverlap = Math.max(0, Math.min(viewBox.x2, edgeBox.x2) - Math.max(viewBox.x, edgeBox.x));\n    const yOverlap = Math.max(0, Math.min(viewBox.y2, edgeBox.y2) - Math.max(viewBox.y, edgeBox.y));\n    const overlappingArea = Math.ceil(xOverlap * yOverlap);\n    return overlappingArea > 0;\n}\nfunction getNodeData(node) {\n    const handleBounds = node?.[internalsSymbol]?.handleBounds || null;\n    const isValid = handleBounds && node?.width && node?.height && typeof node?.positionAbsolute?.x !== \"undefined\" && typeof node?.positionAbsolute?.y !== \"undefined\";\n    return [\n        {\n            x: node?.positionAbsolute?.x || 0,\n            y: node?.positionAbsolute?.y || 0,\n            width: node?.width || 0,\n            height: node?.height || 0\n        },\n        handleBounds,\n        !!isValid\n    ];\n}\nconst defaultEdgeTree = [\n    {\n        level: 0,\n        isMaxLevel: true,\n        edges: []\n    }\n];\nfunction groupEdgesByZLevel(edges, nodeInternals, elevateEdgesOnSelect = false) {\n    let maxLevel = -1;\n    const levelLookup = edges.reduce((tree, edge)=>{\n        const hasZIndex = isNumeric(edge.zIndex);\n        let z = hasZIndex ? edge.zIndex : 0;\n        if (elevateEdgesOnSelect) {\n            const targetNode = nodeInternals.get(edge.target);\n            const sourceNode = nodeInternals.get(edge.source);\n            const edgeOrConnectedNodeSelected = edge.selected || targetNode?.selected || sourceNode?.selected;\n            const selectedZIndex = Math.max(sourceNode?.[internalsSymbol]?.z || 0, targetNode?.[internalsSymbol]?.z || 0, 1000);\n            z = (hasZIndex ? edge.zIndex : 0) + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);\n        }\n        if (tree[z]) {\n            tree[z].push(edge);\n        } else {\n            tree[z] = [\n                edge\n            ];\n        }\n        maxLevel = z > maxLevel ? z : maxLevel;\n        return tree;\n    }, {});\n    const edgeTree = Object.entries(levelLookup).map(([key, edges])=>{\n        const level = +key;\n        return {\n            edges,\n            level,\n            isMaxLevel: level === maxLevel\n        };\n    });\n    if (edgeTree.length === 0) {\n        return defaultEdgeTree;\n    }\n    return edgeTree;\n}\nfunction useVisibleEdges(onlyRenderVisible, nodeInternals, elevateEdgesOnSelect) {\n    const edges = useStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((s)=>{\n        if (!onlyRenderVisible) {\n            return s.edges;\n        }\n        return s.edges.filter((e)=>{\n            const sourceNode = nodeInternals.get(e.source);\n            const targetNode = nodeInternals.get(e.target);\n            return sourceNode?.width && sourceNode?.height && targetNode?.width && targetNode?.height && isEdgeVisible({\n                sourcePos: sourceNode.positionAbsolute || {\n                    x: 0,\n                    y: 0\n                },\n                targetPos: targetNode.positionAbsolute || {\n                    x: 0,\n                    y: 0\n                },\n                sourceWidth: sourceNode.width,\n                sourceHeight: sourceNode.height,\n                targetWidth: targetNode.width,\n                targetHeight: targetNode.height,\n                width: s.width,\n                height: s.height,\n                transform: s.transform\n            });\n        });\n    }, [\n        onlyRenderVisible,\n        nodeInternals\n    ]));\n    return groupEdgesByZLevel(edges, nodeInternals, elevateEdgesOnSelect);\n}\nconst ArrowSymbol = ({ color = \"none\", strokeWidth = 1 })=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"polyline\", {\n        style: {\n            stroke: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        fill: \"none\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = \"none\", strokeWidth = 1 })=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"polyline\", {\n        style: {\n            stroke: color,\n            fill: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [MarkerType.Arrow]: ArrowSymbol,\n    [MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n        if (!symbolExists) {\n            store.getState().onError?.(\"009\", errorMessages[\"error009\"](type));\n            return null;\n        }\n        return MarkerSymbols[type];\n    }, [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = \"strokeWidth\", strokeWidth, orient = \"auto-start-reverse\" })=>{\n    const Symbol1 = useMarkerSymbol(type);\n    if (!Symbol1) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Symbol1, {\n        color: color,\n        strokeWidth: strokeWidth\n    }));\n};\nconst markerSelector = ({ defaultColor, rfId })=>(s)=>{\n        const ids = [];\n        return s.edges.reduce((markers, edge)=>{\n            [\n                edge.markerStart,\n                edge.markerEnd\n            ].forEach((marker)=>{\n                if (marker && typeof marker === \"object\") {\n                    const markerId = getMarkerId(marker, rfId);\n                    if (!ids.includes(markerId)) {\n                        markers.push({\n                            id: markerId,\n                            color: marker.color || defaultColor,\n                            ...marker\n                        });\n                        ids.push(markerId);\n                    }\n                }\n            });\n            return markers;\n        }, []).sort((a, b)=>a.id.localeCompare(b.id));\n    };\n// when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n// when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n// that we can then use for creating our unique marker ids\nconst MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const markers = useStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(markerSelector({\n        defaultColor,\n        rfId\n    }), [\n        defaultColor,\n        rfId\n    ]), // the id includes all marker options, so we just need to look at that part of the marker\n    (a, b)=>!(a.length !== b.length || a.some((m, i)=>m.id !== b[i].id)));\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null, markers.map((marker)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Marker, {\n            id: marker.id,\n            key: marker.id,\n            type: marker.type,\n            color: marker.color,\n            width: marker.width,\n            height: marker.height,\n            markerUnits: marker.markerUnits,\n            strokeWidth: marker.strokeWidth,\n            orient: marker.orient\n        })));\n};\nMarkerDefinitions.displayName = \"MarkerDefinitions\";\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MarkerDefinitions);\nconst selector$4 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        edgesFocusable: s.edgesFocusable,\n        edgesUpdatable: s.edgesUpdatable,\n        elementsSelectable: s.elementsSelectable,\n        width: s.width,\n        height: s.height,\n        connectionMode: s.connectionMode,\n        nodeInternals: s.nodeInternals,\n        onError: s.onError\n    });\nconst EdgeRenderer = ({ defaultMarkerColor, onlyRenderVisibleElements, elevateEdgesOnSelect, rfId, edgeTypes, noPanClassName, onEdgeUpdate, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, edgeUpdaterRadius, onEdgeDoubleClick, onEdgeUpdateStart, onEdgeUpdateEnd, children })=>{\n    const { edgesFocusable, edgesUpdatable, elementsSelectable, width, height, connectionMode, nodeInternals, onError } = useStore(selector$4, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const edgeTree = useVisibleEdges(onlyRenderVisibleElements, nodeInternals, elevateEdgesOnSelect);\n    if (!width) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, edgeTree.map(({ level, edges, isMaxLevel })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n            key: level,\n            style: {\n                zIndex: level\n            },\n            width: width,\n            height: height,\n            className: \"react-flow__edges react-flow__container\"\n        }, isMaxLevel && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkerDefinitions$1, {\n            defaultColor: defaultMarkerColor,\n            rfId: rfId\n        }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", null, edges.map((edge)=>{\n            const [sourceNodeRect, sourceHandleBounds, sourceIsValid] = getNodeData(nodeInternals.get(edge.source));\n            const [targetNodeRect, targetHandleBounds, targetIsValid] = getNodeData(nodeInternals.get(edge.target));\n            if (!sourceIsValid || !targetIsValid) {\n                return null;\n            }\n            let edgeType = edge.type || \"default\";\n            if (!edgeTypes[edgeType]) {\n                onError?.(\"011\", errorMessages[\"error011\"](edgeType));\n                edgeType = \"default\";\n            }\n            const EdgeComponent = edgeTypes[edgeType] || edgeTypes.default;\n            // when connection type is loose we can define all handles as sources and connect source -> source\n            const targetNodeHandles = connectionMode === ConnectionMode.Strict ? targetHandleBounds.target : (targetHandleBounds.target ?? []).concat(targetHandleBounds.source ?? []);\n            const sourceHandle = getHandle(sourceHandleBounds.source, edge.sourceHandle);\n            const targetHandle = getHandle(targetNodeHandles, edge.targetHandle);\n            const sourcePosition = sourceHandle?.position || Position.Bottom;\n            const targetPosition = targetHandle?.position || Position.Top;\n            const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === \"undefined\");\n            const isUpdatable = typeof onEdgeUpdate !== \"undefined\" && (edge.updatable || edgesUpdatable && typeof edge.updatable === \"undefined\");\n            if (!sourceHandle || !targetHandle) {\n                onError?.(\"008\", errorMessages[\"error008\"](sourceHandle, edge));\n                return null;\n            }\n            const { sourceX, sourceY, targetX, targetY } = getEdgePositions(sourceNodeRect, sourceHandle, sourcePosition, targetNodeRect, targetHandle, targetPosition);\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeComponent, {\n                key: edge.id,\n                id: edge.id,\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                    edge.className,\n                    noPanClassName\n                ]),\n                type: edgeType,\n                data: edge.data,\n                selected: !!edge.selected,\n                animated: !!edge.animated,\n                hidden: !!edge.hidden,\n                label: edge.label,\n                labelStyle: edge.labelStyle,\n                labelShowBg: edge.labelShowBg,\n                labelBgStyle: edge.labelBgStyle,\n                labelBgPadding: edge.labelBgPadding,\n                labelBgBorderRadius: edge.labelBgBorderRadius,\n                style: edge.style,\n                source: edge.source,\n                target: edge.target,\n                sourceHandleId: edge.sourceHandle,\n                targetHandleId: edge.targetHandle,\n                markerEnd: edge.markerEnd,\n                markerStart: edge.markerStart,\n                sourceX: sourceX,\n                sourceY: sourceY,\n                targetX: targetX,\n                targetY: targetY,\n                sourcePosition: sourcePosition,\n                targetPosition: targetPosition,\n                elementsSelectable: elementsSelectable,\n                onEdgeUpdate: onEdgeUpdate,\n                onContextMenu: onEdgeContextMenu,\n                onMouseEnter: onEdgeMouseEnter,\n                onMouseMove: onEdgeMouseMove,\n                onMouseLeave: onEdgeMouseLeave,\n                onClick: onEdgeClick,\n                edgeUpdaterRadius: edgeUpdaterRadius,\n                onEdgeDoubleClick: onEdgeDoubleClick,\n                onEdgeUpdateStart: onEdgeUpdateStart,\n                onEdgeUpdateEnd: onEdgeUpdateEnd,\n                rfId: rfId,\n                ariaLabel: edge.ariaLabel,\n                isFocusable: isFocusable,\n                isUpdatable: isUpdatable,\n                pathOptions: \"pathOptions\" in edge ? edge.pathOptions : undefined,\n                interactionWidth: edge.interactionWidth\n            });\n        })))), children);\n};\nEdgeRenderer.displayName = \"EdgeRenderer\";\nvar EdgeRenderer$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(EdgeRenderer);\nconst selector$3 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$3);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"react-flow__viewport react-flow__container\",\n        style: {\n            transform\n        }\n    }, children);\n}\nfunction useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n            setTimeout(()=>onInit(rfInstance), 1);\n            isInitialized.current = true;\n        }\n    }, [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top\n};\nconst ConnectionLine = ({ nodeId, handleType, style, type = ConnectionLineType.Bezier, CustomComponent, connectionStatus })=>{\n    const { fromNode, handleId, toX, toY, connectionMode } = useStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((s)=>({\n            fromNode: s.nodeInternals.get(nodeId),\n            handleId: s.connectionHandleId,\n            toX: (s.connectionPosition.x - s.transform[0]) / s.transform[2],\n            toY: (s.connectionPosition.y - s.transform[1]) / s.transform[2],\n            connectionMode: s.connectionMode\n        }), [\n        nodeId\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const fromHandleBounds = fromNode?.[internalsSymbol]?.handleBounds;\n    let handleBounds = fromHandleBounds?.[handleType];\n    if (connectionMode === ConnectionMode.Loose) {\n        handleBounds = handleBounds ? handleBounds : fromHandleBounds?.[handleType === \"source\" ? \"target\" : \"source\"];\n    }\n    if (!fromNode || !handleBounds) {\n        return null;\n    }\n    const fromHandle = handleId ? handleBounds.find((d)=>d.id === handleId) : handleBounds[0];\n    const fromHandleX = fromHandle ? fromHandle.x + fromHandle.width / 2 : (fromNode.width ?? 0) / 2;\n    const fromHandleY = fromHandle ? fromHandle.y + fromHandle.height / 2 : fromNode.height ?? 0;\n    const fromX = (fromNode.positionAbsolute?.x ?? 0) + fromHandleX;\n    const fromY = (fromNode.positionAbsolute?.y ?? 0) + fromHandleY;\n    const fromPosition = fromHandle?.position;\n    const toPosition = fromPosition ? oppositePosition[fromPosition] : null;\n    if (!fromPosition || !toPosition) {\n        return null;\n    }\n    if (CustomComponent) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: fromX,\n            fromY: fromY,\n            toX: toX,\n            toY: toY,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: connectionStatus\n        });\n    }\n    let dAttr = \"\";\n    const pathParams = {\n        sourceX: fromX,\n        sourceY: fromY,\n        sourcePosition: fromPosition,\n        targetX: toX,\n        targetY: toY,\n        targetPosition: toPosition\n    };\n    if (type === ConnectionLineType.Bezier) {\n        // we assume the destination position is opposite to the source position\n        [dAttr] = getBezierPath(pathParams);\n    } else if (type === ConnectionLineType.Step) {\n        [dAttr] = getSmoothStepPath({\n            ...pathParams,\n            borderRadius: 0\n        });\n    } else if (type === ConnectionLineType.SmoothStep) {\n        [dAttr] = getSmoothStepPath(pathParams);\n    } else if (type === ConnectionLineType.SimpleBezier) {\n        [dAttr] = getSimpleBezierPath(pathParams);\n    } else {\n        dAttr = `M${fromX},${fromY} ${toX},${toY}`;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: dAttr,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = \"ConnectionLine\";\nconst selector$2 = (s)=>({\n        nodeId: s.connectionNodeId,\n        handleType: s.connectionHandleType,\n        nodesConnectable: s.nodesConnectable,\n        connectionStatus: s.connectionStatus,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodeId, handleType, nodesConnectable, width, height, connectionStatus } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    const isValid = !!(nodeId && handleType && width && nodesConnectable);\n    if (!isValid) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__edges react-flow__connectionline react-flow__container\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__connection\",\n            connectionStatus\n        ])\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConnectionLine, {\n        nodeId: nodeId,\n        handleType: handleType,\n        style: style,\n        type: type,\n        CustomComponent: component,\n        connectionStatus: connectionStatus\n    })));\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypes(nodeOrEdgeTypes, createTypes) {\n    const typesKeysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const store = useStoreApi();\n    const typesParsed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (true) {\n            const typeKeys = Object.keys(nodeOrEdgeTypes);\n            if ((0,zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow)(typesKeysRef.current, typeKeys)) {\n                store.getState().onError?.(\"002\", errorMessages[\"error002\"]());\n            }\n            typesKeysRef.current = typeKeys;\n        }\n        return createTypes(nodeOrEdgeTypes);\n    }, [\n        nodeOrEdgeTypes\n    ]);\n    return typesParsed;\n}\nconst GraphView = ({ nodeTypes, edgeTypes, onMove, onMoveStart, onMoveEnd, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, selectNodesOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, onEdgeUpdate, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, edgeUpdaterRadius, onEdgeUpdateStart, onEdgeUpdateEnd, noDragClassName, noWheelClassName, noPanClassName, elevateEdgesOnSelect, disableKeyboardA11y, nodeOrigin, nodeExtent, rfId })=>{\n    const nodeTypesWrapped = useNodeOrEdgeTypes(nodeTypes, createNodeTypes);\n    const edgeTypesWrapped = useNodeOrEdgeTypes(edgeTypes, createEdgeTypes);\n    useOnInitHandler(onInit);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FlowRenderer$1, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        onMove: onMove,\n        onMoveStart: onMoveStart,\n        onMoveEnd: onMoveEnd,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Viewport, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EdgeRenderer$1, {\n        edgeTypes: edgeTypesWrapped,\n        onEdgeClick: onEdgeClick,\n        onEdgeDoubleClick: onEdgeDoubleClick,\n        onEdgeUpdate: onEdgeUpdate,\n        onlyRenderVisibleElements: onlyRenderVisibleElements,\n        onEdgeContextMenu: onEdgeContextMenu,\n        onEdgeMouseEnter: onEdgeMouseEnter,\n        onEdgeMouseMove: onEdgeMouseMove,\n        onEdgeMouseLeave: onEdgeMouseLeave,\n        onEdgeUpdateStart: onEdgeUpdateStart,\n        onEdgeUpdateEnd: onEdgeUpdateEnd,\n        edgeUpdaterRadius: edgeUpdaterRadius,\n        defaultMarkerColor: defaultMarkerColor,\n        noPanClassName: noPanClassName,\n        elevateEdgesOnSelect: !!elevateEdgesOnSelect,\n        disableKeyboardA11y: disableKeyboardA11y,\n        rfId: rfId\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConnectionLineWrapper, {\n        style: connectionLineStyle,\n        type: connectionLineType,\n        component: connectionLineComponent,\n        containerStyle: connectionLineContainerStyle\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"react-flow__edgelabel-renderer\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodeRenderer$1, {\n        nodeTypes: nodeTypesWrapped,\n        onNodeClick: onNodeClick,\n        onNodeDoubleClick: onNodeDoubleClick,\n        onNodeMouseEnter: onNodeMouseEnter,\n        onNodeMouseMove: onNodeMouseMove,\n        onNodeMouseLeave: onNodeMouseLeave,\n        onNodeContextMenu: onNodeContextMenu,\n        selectNodesOnDrag: selectNodesOnDrag,\n        onlyRenderVisibleElements: onlyRenderVisibleElements,\n        noPanClassName: noPanClassName,\n        noDragClassName: noDragClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        rfId: rfId\n    })));\n};\nGraphView.displayName = \"GraphView\";\nvar GraphView$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(GraphView);\nconst infiniteExtent = [\n    [\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY\n    ],\n    [\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n    ]\n];\nconst initialState = {\n    rfId: \"1\",\n    width: 0,\n    height: 0,\n    transform: [\n        0,\n        0,\n        1\n    ],\n    nodeInternals: new Map(),\n    edges: [],\n    onNodesChange: null,\n    onEdgesChange: null,\n    hasDefaultNodes: false,\n    hasDefaultEdges: false,\n    d3Zoom: null,\n    d3Selection: null,\n    d3ZoomHandler: undefined,\n    minZoom: 0.5,\n    maxZoom: 2,\n    translateExtent: infiniteExtent,\n    nodeExtent: infiniteExtent,\n    nodesSelectionActive: false,\n    userSelectionActive: false,\n    userSelectionRect: null,\n    connectionNodeId: null,\n    connectionHandleId: null,\n    connectionHandleType: \"source\",\n    connectionPosition: {\n        x: 0,\n        y: 0\n    },\n    connectionStatus: null,\n    connectionMode: ConnectionMode.Strict,\n    domNode: null,\n    paneDragging: false,\n    noPanClassName: \"nopan\",\n    nodeOrigin: [\n        0,\n        0\n    ],\n    nodeDragThreshold: 0,\n    snapGrid: [\n        15,\n        15\n    ],\n    snapToGrid: false,\n    nodesDraggable: true,\n    nodesConnectable: true,\n    nodesFocusable: true,\n    edgesFocusable: true,\n    edgesUpdatable: true,\n    elementsSelectable: true,\n    elevateNodesOnSelect: true,\n    fitViewOnInit: false,\n    fitViewOnInitDone: false,\n    fitViewOnInitOptions: undefined,\n    onSelectionChange: [],\n    multiSelectionActive: false,\n    connectionStartHandle: null,\n    connectionEndHandle: null,\n    connectionClickStartHandle: null,\n    connectOnClick: true,\n    ariaLiveMessage: \"\",\n    autoPanOnConnect: true,\n    autoPanOnNodeDrag: true,\n    connectionRadius: 20,\n    onError: devWarn,\n    isValidConnection: undefined\n};\nconst createRFStore = ()=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_4__.createWithEqualityFn)((set, get)=>({\n            ...initialState,\n            setNodes: (nodes)=>{\n                const { nodeInternals, nodeOrigin, elevateNodesOnSelect } = get();\n                set({\n                    nodeInternals: createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect)\n                });\n            },\n            getNodes: ()=>{\n                return Array.from(get().nodeInternals.values());\n            },\n            setEdges: (edges)=>{\n                const { defaultEdgeOptions = {} } = get();\n                set({\n                    edges: edges.map((e)=>({\n                            ...defaultEdgeOptions,\n                            ...e\n                        }))\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                const hasDefaultNodes = typeof nodes !== \"undefined\";\n                const hasDefaultEdges = typeof edges !== \"undefined\";\n                const nodeInternals = hasDefaultNodes ? createNodeInternals(nodes, new Map(), get().nodeOrigin, get().elevateNodesOnSelect) : new Map();\n                const nextEdges = hasDefaultEdges ? edges : [];\n                set({\n                    nodeInternals,\n                    edges: nextEdges,\n                    hasDefaultNodes,\n                    hasDefaultEdges\n                });\n            },\n            updateNodeDimensions: (updates)=>{\n                const { onNodesChange, nodeInternals, fitViewOnInit, fitViewOnInitDone, fitViewOnInitOptions, domNode, nodeOrigin } = get();\n                const viewportNode = domNode?.querySelector(\".react-flow__viewport\");\n                if (!viewportNode) {\n                    return;\n                }\n                const style = window.getComputedStyle(viewportNode);\n                const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n                const changes = updates.reduce((res, update)=>{\n                    const node = nodeInternals.get(update.id);\n                    if (node) {\n                        const dimensions = getDimensions(update.nodeElement);\n                        const doUpdate = !!(dimensions.width && dimensions.height && (node.width !== dimensions.width || node.height !== dimensions.height || update.forceUpdate));\n                        if (doUpdate) {\n                            nodeInternals.set(node.id, {\n                                ...node,\n                                [internalsSymbol]: {\n                                    ...node[internalsSymbol],\n                                    handleBounds: {\n                                        source: getHandleBounds(\".source\", update.nodeElement, zoom, nodeOrigin),\n                                        target: getHandleBounds(\".target\", update.nodeElement, zoom, nodeOrigin)\n                                    }\n                                },\n                                ...dimensions\n                            });\n                            res.push({\n                                id: node.id,\n                                type: \"dimensions\",\n                                dimensions\n                            });\n                        }\n                    }\n                    return res;\n                }, []);\n                updateAbsoluteNodePositions(nodeInternals, nodeOrigin);\n                const nextFitViewOnInitDone = fitViewOnInitDone || fitViewOnInit && !fitViewOnInitDone && fitView(get, {\n                    initial: true,\n                    ...fitViewOnInitOptions\n                });\n                set({\n                    nodeInternals: new Map(nodeInternals),\n                    fitViewOnInitDone: nextFitViewOnInitDone\n                });\n                if (changes?.length > 0) {\n                    onNodesChange?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, positionChanged = true, dragging = false)=>{\n                const { triggerNodeChanges } = get();\n                const changes = nodeDragItems.map((node)=>{\n                    const change = {\n                        id: node.id,\n                        type: \"position\",\n                        dragging\n                    };\n                    if (positionChanged) {\n                        change.positionAbsolute = node.positionAbsolute;\n                        change.position = node.position;\n                    }\n                    return change;\n                });\n                triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, nodeInternals, hasDefaultNodes, nodeOrigin, getNodes, elevateNodesOnSelect } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const nodes = applyNodeChanges(changes, getNodes());\n                        const nextNodeInternals = createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect);\n                        set({\n                            nodeInternals: nextNodeInternals\n                        });\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edges, getNodes } = get();\n                let changedNodes;\n                let changedEdges = null;\n                if (multiSelectionActive) {\n                    changedNodes = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                } else {\n                    changedNodes = getSelectionChanges(getNodes(), selectedNodeIds);\n                    changedEdges = getSelectionChanges(edges, []);\n                }\n                updateNodesAndEdgesSelections({\n                    changedNodes,\n                    changedEdges,\n                    get,\n                    set\n                });\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edges, getNodes } = get();\n                let changedEdges;\n                let changedNodes = null;\n                if (multiSelectionActive) {\n                    changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                } else {\n                    changedEdges = getSelectionChanges(edges, selectedEdgeIds);\n                    changedNodes = getSelectionChanges(getNodes(), []);\n                }\n                updateNodesAndEdgesSelections({\n                    changedNodes,\n                    changedEdges,\n                    get,\n                    set\n                });\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, getNodes } = get();\n                const nodesToUnselect = nodes ? nodes : getNodes();\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const changedNodes = nodesToUnselect.map((n)=>{\n                    n.selected = false;\n                    return createSelectionChange(n.id, false);\n                });\n                const changedEdges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                updateNodesAndEdgesSelections({\n                    changedNodes,\n                    changedEdges,\n                    get,\n                    set\n                });\n            },\n            setMinZoom: (minZoom)=>{\n                const { d3Zoom, maxZoom } = get();\n                d3Zoom?.scaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { d3Zoom, minZoom } = get();\n                d3Zoom?.scaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().d3Zoom?.translateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            resetSelectedElements: ()=>{\n                const { edges, getNodes } = get();\n                const nodes = getNodes();\n                const nodesToUnselect = nodes.filter((e)=>e.selected).map((n)=>createSelectionChange(n.id, false));\n                const edgesToUnselect = edges.filter((e)=>e.selected).map((e)=>createSelectionChange(e.id, false));\n                updateNodesAndEdgesSelections({\n                    changedNodes: nodesToUnselect,\n                    changedEdges: edgesToUnselect,\n                    get,\n                    set\n                });\n            },\n            setNodeExtent: (nodeExtent)=>{\n                const { nodeInternals } = get();\n                nodeInternals.forEach((node)=>{\n                    node.positionAbsolute = clampPosition(node.position, nodeExtent);\n                });\n                set({\n                    nodeExtent,\n                    nodeInternals: new Map(nodeInternals)\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, d3Zoom, d3Selection, translateExtent } = get();\n                if (!d3Zoom || !d3Selection || !delta.x && !delta.y) {\n                    return false;\n                }\n                const nextTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(transform[0] + delta.x, transform[1] + delta.y).scale(transform[2]);\n                const extent = [\n                    [\n                        0,\n                        0\n                    ],\n                    [\n                        width,\n                        height\n                    ]\n                ];\n                const constrainedTransform = d3Zoom?.constrain()(nextTransform, extent, translateExtent);\n                d3Zoom.transform(d3Selection, constrainedTransform);\n                const transformChanged = transform[0] !== constrainedTransform.x || transform[1] !== constrainedTransform.y || transform[2] !== constrainedTransform.k;\n                return transformChanged;\n            },\n            cancelConnection: ()=>set({\n                    connectionNodeId: initialState.connectionNodeId,\n                    connectionHandleId: initialState.connectionHandleId,\n                    connectionHandleType: initialState.connectionHandleType,\n                    connectionStatus: initialState.connectionStatus,\n                    connectionStartHandle: initialState.connectionStartHandle,\n                    connectionEndHandle: initialState.connectionEndHandle\n                }),\n            reset: ()=>set({\n                    ...initialState\n                })\n        }), Object.is);\nconst ReactFlowProvider = ({ children })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (!storeRef.current) {\n        storeRef.current = createRFStore();\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider$1, {\n        value: storeRef.current\n    }, children);\n};\nReactFlowProvider.displayName = \"ReactFlowProvider\";\nconst Wrapper = ({ children })=>{\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    if (isWrapped) {\n        // we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ReactFlowProvider, null, children);\n};\nWrapper.displayName = \"ReactFlowWrapper\";\nconst defaultNodeTypes = {\n    input: InputNode$1,\n    default: DefaultNode$1,\n    output: OutputNode$1,\n    group: GroupNode\n};\nconst defaultEdgeTypes = {\n    default: BezierEdge,\n    straight: StraightEdge,\n    step: StepEdge,\n    smoothstep: SmoothStepEdge,\n    simplebezier: SimpleBezierEdge\n};\nconst initNodeOrigin = [\n    0,\n    0\n];\nconst initSnapGrid = [\n    15,\n    15\n];\nconst initDefaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\nconst wrapperStyle = {\n    width: \"100%\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    position: \"relative\",\n    zIndex: 0\n};\nconst ReactFlow = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes = defaultNodeTypes, edgeTypes = defaultEdgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionMode = ConnectionMode.Strict, connectionLineType = ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = \"Backspace\", selectionKeyCode = \"Shift\", selectionOnDrag = false, selectionMode = SelectionMode.Full, panActivationKeyCode = \"Space\", multiSelectionKeyCode = isMacOs() ? \"Meta\" : \"Control\", zoomActivationKeyCode = isMacOs() ? \"Meta\" : \"Control\", snapToGrid = false, snapGrid = initSnapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag = true, nodesDraggable, nodesConnectable, nodesFocusable, nodeOrigin = initNodeOrigin, edgesFocusable, edgesUpdatable, elementsSelectable, defaultViewport = initDefaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = \"#b1b1b7\", zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, children, onEdgeUpdate, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeUpdateStart, onEdgeUpdateEnd, edgeUpdaterRadius = 10, onNodesChange, onEdgesChange, noDragClassName = \"nodrag\", noWheelClassName = \"nowheel\", noPanClassName = \"nopan\", fitView = false, fitViewOptions, connectOnClick = true, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect = true, elevateEdgesOnSelect = false, disableKeyboardA11y = false, autoPanOnConnect = true, autoPanOnNodeDrag = true, connectionRadius = 20, isValidConnection, onError, style, id, nodeDragThreshold, ...rest }, ref)=>{\n    const rfId = id || \"1\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...rest,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow\",\n            className\n        ]),\n        \"data-testid\": \"rf__wrapper\",\n        id: id\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GraphView$1, {\n        onInit: onInit,\n        onMove: onMove,\n        onMoveStart: onMoveStart,\n        onMoveEnd: onMoveEnd,\n        onNodeClick: onNodeClick,\n        onEdgeClick: onEdgeClick,\n        onNodeMouseEnter: onNodeMouseEnter,\n        onNodeMouseMove: onNodeMouseMove,\n        onNodeMouseLeave: onNodeMouseLeave,\n        onNodeContextMenu: onNodeContextMenu,\n        onNodeDoubleClick: onNodeDoubleClick,\n        nodeTypes: nodeTypes,\n        edgeTypes: edgeTypes,\n        connectionLineType: connectionLineType,\n        connectionLineStyle: connectionLineStyle,\n        connectionLineComponent: connectionLineComponent,\n        connectionLineContainerStyle: connectionLineContainerStyle,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        deleteKeyCode: deleteKeyCode,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        onlyRenderVisibleElements: onlyRenderVisibleElements,\n        selectNodesOnDrag: selectNodesOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        preventScrolling: preventScrolling,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneScroll: onPaneScroll,\n        onPaneContextMenu: onPaneContextMenu,\n        onSelectionContextMenu: onSelectionContextMenu,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        onEdgeUpdate: onEdgeUpdate,\n        onEdgeContextMenu: onEdgeContextMenu,\n        onEdgeDoubleClick: onEdgeDoubleClick,\n        onEdgeMouseEnter: onEdgeMouseEnter,\n        onEdgeMouseMove: onEdgeMouseMove,\n        onEdgeMouseLeave: onEdgeMouseLeave,\n        onEdgeUpdateStart: onEdgeUpdateStart,\n        onEdgeUpdateEnd: onEdgeUpdateEnd,\n        edgeUpdaterRadius: edgeUpdaterRadius,\n        defaultMarkerColor: defaultMarkerColor,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        elevateEdgesOnSelect: elevateEdgesOnSelect,\n        rfId: rfId,\n        disableKeyboardA11y: disableKeyboardA11y,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(StoreUpdater, {\n        nodes: nodes,\n        edges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        onConnect: onConnect,\n        onConnectStart: onConnectStart,\n        onConnectEnd: onConnectEnd,\n        onClickConnectStart: onClickConnectStart,\n        onClickConnectEnd: onClickConnectEnd,\n        nodesDraggable: nodesDraggable,\n        nodesConnectable: nodesConnectable,\n        nodesFocusable: nodesFocusable,\n        edgesFocusable: edgesFocusable,\n        edgesUpdatable: edgesUpdatable,\n        elementsSelectable: elementsSelectable,\n        elevateNodesOnSelect: elevateNodesOnSelect,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        nodeExtent: nodeExtent,\n        onNodesChange: onNodesChange,\n        onEdgesChange: onEdgesChange,\n        snapToGrid: snapToGrid,\n        snapGrid: snapGrid,\n        connectionMode: connectionMode,\n        translateExtent: translateExtent,\n        connectOnClick: connectOnClick,\n        defaultEdgeOptions: defaultEdgeOptions,\n        fitView: fitView,\n        fitViewOptions: fitViewOptions,\n        onNodesDelete: onNodesDelete,\n        onEdgesDelete: onEdgesDelete,\n        onNodeDragStart: onNodeDragStart,\n        onNodeDrag: onNodeDrag,\n        onNodeDragStop: onNodeDragStop,\n        onSelectionDrag: onSelectionDrag,\n        onSelectionDragStart: onSelectionDragStart,\n        onSelectionDragStop: onSelectionDragStop,\n        noPanClassName: noPanClassName,\n        nodeOrigin: nodeOrigin,\n        rfId: rfId,\n        autoPanOnConnect: autoPanOnConnect,\n        autoPanOnNodeDrag: autoPanOnNodeDrag,\n        onError: onError,\n        connectionRadius: connectionRadius,\n        isValidConnection: isValidConnection,\n        nodeDragThreshold: nodeDragThreshold\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper$1, {\n        onSelectionChange: onSelectionChange\n    }), children, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Attribution, {\n        proOptions: proOptions,\n        position: attributionPosition\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(A11yDescriptions, {\n        rfId: rfId,\n        disableKeyboardA11y: disableKeyboardA11y\n    })));\n});\nReactFlow.displayName = \"ReactFlow\";\nconst selector$1 = (s)=>s.domNode?.querySelector(\".react-flow__edgelabel-renderer\");\nfunction EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$1);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal)(children, edgeLabelRenderer);\n}\nfunction useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        const { domNode, updateNodeDimensions } = store.getState();\n        const updateIds = Array.isArray(id) ? id : [\n            id\n        ];\n        const updates = updateIds.reduce((res, updateId)=>{\n            const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n            if (nodeElement) {\n                res.push({\n                    id: updateId,\n                    nodeElement,\n                    forceUpdate: true\n                });\n            }\n            return res;\n        }, []);\n        requestAnimationFrame(()=>updateNodeDimensions(updates));\n    }, []);\n}\nconst nodesSelector = (state)=>state.getNodes();\nfunction useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\nfunction useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\nfunction useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.shallow);\n    return viewport;\n}\n/* eslint-disable @typescript-eslint/no-explicit-any */ function createUseItemsState(applyChanges) {\n    return (initialItems)=>{\n        const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialItems);\n        const onItemsChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((changes)=>setItems((items)=>applyChanges(changes, items)), []);\n        return [\n            items,\n            setItems,\n            onItemsChange\n        ];\n    };\n}\nconst useNodesState = createUseItemsState(applyNodeChanges);\nconst useEdgesState = createUseItemsState(applyEdgeChanges);\nfunction useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        store.setState({\n            onViewportChangeStart: onStart\n        });\n    }, [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        store.setState({\n            onViewportChange: onChange\n        });\n    }, [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        store.setState({\n            onViewportChangeEnd: onEnd\n        });\n    }, [\n        onEnd\n    ]);\n}\nfunction useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const nextSelectionChangeHandlers = [\n            ...store.getState().onSelectionChange,\n            onChange\n        ];\n        store.setState({\n            onSelectionChange: nextSelectionChangeHandlers\n        });\n        return ()=>{\n            const nextHandlers = store.getState().onSelectionChange.filter((fn)=>fn !== onChange);\n            store.setState({\n                onSelectionChange: nextHandlers\n            });\n        };\n    }, [\n        onChange\n    ]);\n}\nconst selector = (options)=>(s)=>{\n        if (s.nodeInternals.size === 0) {\n            return false;\n        }\n        return s.getNodes().filter((n)=>options.includeHiddenNodes ? true : !n.hidden).every((n)=>n[internalsSymbol]?.handleBounds !== undefined);\n    };\nconst defaultOptions = {\n    includeHiddenNodes: false\n};\nfunction useNodesInitialized(options = defaultOptions) {\n    const initialized = useStore(selector(options));\n    return initialized;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0Zmxvdy9jb3JlL2Rpc3QvZXNtL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThIO0FBQ3BHO0FBQ3lEO0FBQ3pDO0FBQ0c7QUFDRTtBQUNoQjtBQUNVO0FBRXpDLE1BQU1vQiw2QkFBZW5CLG9EQUFhQSxDQUFDO0FBQ25DLE1BQU1vQixhQUFhRCxhQUFhRSxRQUFRO0FBRXhDLE1BQU1DLGdCQUFnQjtJQUNsQkMsVUFBVSxJQUFNO0lBQ2hCQyxVQUFVLElBQU07SUFDaEJDLFVBQVUsQ0FBQ0MsV0FBYSxDQUFDLFdBQVcsRUFBRUEsU0FBUywyQ0FBMkMsQ0FBQztJQUMzRkMsVUFBVSxJQUFNO0lBQ2hCQyxVQUFVLElBQU07SUFDaEJDLFVBQVUsSUFBTTtJQUNoQkMsVUFBVSxDQUFDQyxLQUFPLENBQUMscUJBQXFCLEVBQUVBLEdBQUcsZ0JBQWdCLENBQUM7SUFDOURDLFVBQVUsQ0FBQ0MsT0FBUyxDQUFDLGFBQWEsRUFBRUEsS0FBSyxnQkFBZ0IsQ0FBQztJQUMxREMsVUFBVSxDQUFDQyxjQUFjQyxPQUFTLENBQUMseUJBQXlCLEVBQUUsQ0FBQ0QsZUFBZSxXQUFXLFNBQVMsYUFBYSxFQUFFLENBQUNBLGVBQWVDLEtBQUtELFlBQVksR0FBR0MsS0FBS0MsWUFBWSxDQUFDLFlBQVksRUFBRUQsS0FBS0wsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMvTE8sVUFBVSxJQUFNO0lBQ2hCQyxVQUFVLENBQUNDLFdBQWEsQ0FBQyxXQUFXLEVBQUVBLFNBQVMsMkNBQTJDLENBQUM7SUFDM0ZDLFVBQVUsQ0FBQ1YsS0FBTyxDQUFDLGNBQWMsRUFBRUEsR0FBRyw4SEFBOEgsQ0FBQztBQUN6SztBQUVBLE1BQU1XLHNCQUFzQnBCLGFBQWEsQ0FBQyxXQUFXO0FBQ3JELFNBQVNxQixTQUFTQyxRQUFRLEVBQUVDLFVBQVU7SUFDbEMsTUFBTUMsUUFBUTdDLGlEQUFVQSxDQUFDa0I7SUFDekIsSUFBSTJCLFVBQVUsTUFBTTtRQUNoQixNQUFNLElBQUlDLE1BQU1MO0lBQ3BCO0lBQ0EsT0FBT2hDLDJFQUFzQkEsQ0FBQ29DLE9BQU9GLFVBQVVDO0FBQ25EO0FBQ0EsTUFBTUcsY0FBYztJQUNoQixNQUFNRixRQUFRN0MsaURBQVVBLENBQUNrQjtJQUN6QixJQUFJMkIsVUFBVSxNQUFNO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTUw7SUFDcEI7SUFDQSxPQUFPeEMsOENBQU9BLENBQUMsSUFBTztZQUNsQitDLFVBQVVILE1BQU1HLFFBQVE7WUFDeEJDLFVBQVVKLE1BQU1JLFFBQVE7WUFDeEJDLFdBQVdMLE1BQU1LLFNBQVM7WUFDMUJDLFNBQVNOLE1BQU1NLE9BQU87UUFDMUIsSUFBSTtRQUFDTjtLQUFNO0FBQ2Y7QUFFQSxNQUFNTyxhQUFhLENBQUNDLElBQU9BLEVBQUVDLG1CQUFtQixHQUFHLFNBQVM7QUFDNUQsU0FBU0MsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxLQUFLLEVBQUUsR0FBR0MsTUFBTTtJQUM1RCxNQUFNQyxnQkFBZ0JuQixTQUFTVTtJQUMvQixNQUFNVSxrQkFBa0IsQ0FBQyxFQUFFTixTQUFTLENBQUMsQ0FBQ08sS0FBSyxDQUFDO0lBQzVDLHFCQUFRakUsZ0RBQW1CLENBQUMsT0FBTztRQUFFNEQsV0FBV2xELG9EQUFFQSxDQUFDO1lBQUM7WUFBcUJrRDtlQUFjSTtTQUFnQjtRQUFHSCxPQUFPO1lBQUUsR0FBR0EsS0FBSztZQUFFRTtRQUFjO1FBQUcsR0FBR0QsSUFBSTtJQUFDLEdBQUdIO0FBQzdKO0FBRUEsU0FBU1EsWUFBWSxFQUFFQyxVQUFVLEVBQUVWLFdBQVcsY0FBYyxFQUFFO0lBQzFELElBQUlVLFlBQVlDLGlCQUFpQjtRQUM3QixPQUFPO0lBQ1g7SUFDQSxxQkFBUXJFLGdEQUFtQixDQUFDeUQsT0FBTztRQUFFQyxVQUFVQTtRQUFVRSxXQUFXO1FBQTJCLGdCQUFnQjtJQUF5RyxpQkFDcE41RCxnREFBbUIsQ0FBQyxLQUFLO1FBQUVzRSxNQUFNO1FBQXlCQyxRQUFRO1FBQVVDLEtBQUs7UUFBdUIsY0FBYztJQUF5QixHQUFHO0FBQzFKO0FBRUEsTUFBTUMsV0FBVyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxLQUFLLEVBQUVDLGFBQWEsQ0FBQyxDQUFDLEVBQUVDLGNBQWMsSUFBSSxFQUFFQyxlQUFlLENBQUMsQ0FBQyxFQUFFQyxpQkFBaUI7SUFBQztJQUFHO0NBQUUsRUFBRUMsc0JBQXNCLENBQUMsRUFBRXRCLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEdBQUdFLE1BQU07SUFDckssTUFBTW9CLFVBQVU3RSw2Q0FBTUEsQ0FBQztJQUN2QixNQUFNLENBQUM4RSxjQUFjQyxnQkFBZ0IsR0FBRzlFLCtDQUFRQSxDQUFDO1FBQUVvRSxHQUFHO1FBQUdDLEdBQUc7UUFBR1UsT0FBTztRQUFHQyxRQUFRO0lBQUU7SUFDbkYsTUFBTUMsa0JBQWtCN0Usb0RBQUVBLENBQUM7UUFBQztRQUFnQ2tEO0tBQVU7SUFDdEVyRCxnREFBU0EsQ0FBQztRQUNOLElBQUkyRSxRQUFRTSxPQUFPLEVBQUU7WUFDakIsTUFBTUMsV0FBV1AsUUFBUU0sT0FBTyxDQUFDRSxPQUFPO1lBQ3hDTixnQkFBZ0I7Z0JBQ1pWLEdBQUdlLFNBQVNmLENBQUM7Z0JBQ2JDLEdBQUdjLFNBQVNkLENBQUM7Z0JBQ2JVLE9BQU9JLFNBQVNKLEtBQUs7Z0JBQ3JCQyxRQUFRRyxTQUFTSCxNQUFNO1lBQzNCO1FBQ0o7SUFDSixHQUFHO1FBQUNWO0tBQU07SUFDVixJQUFJLE9BQU9BLFVBQVUsZUFBZSxDQUFDQSxPQUFPO1FBQ3hDLE9BQU87SUFDWDtJQUNBLHFCQUFRNUUsZ0RBQW1CLENBQUMsS0FBSztRQUFFMkYsV0FBVyxDQUFDLFVBQVUsRUFBRWpCLElBQUlTLGFBQWFFLEtBQUssR0FBRyxFQUFFLENBQUMsRUFBRVYsSUFBSVEsYUFBYUcsTUFBTSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQUUxQixXQUFXMkI7UUFBaUJLLFlBQVlULGFBQWFFLEtBQUssR0FBRyxZQUFZO1FBQVUsR0FBR3ZCLElBQUk7SUFBQyxHQUNoTmdCLDZCQUFnQjlFLGdEQUFtQixDQUFDLFFBQVE7UUFBRXFGLE9BQU9GLGFBQWFFLEtBQUssR0FBRyxJQUFJTCxjQUFjLENBQUMsRUFBRTtRQUFFTixHQUFHLENBQUNNLGNBQWMsQ0FBQyxFQUFFO1FBQUVMLEdBQUcsQ0FBQ0ssY0FBYyxDQUFDLEVBQUU7UUFBRU0sUUFBUUgsYUFBYUcsTUFBTSxHQUFHLElBQUlOLGNBQWMsQ0FBQyxFQUFFO1FBQUVwQixXQUFXO1FBQTJCQyxPQUFPa0I7UUFBY2MsSUFBSVo7UUFBcUJhLElBQUliO0lBQW9CLGtCQUNoVGpGLGdEQUFtQixDQUFDLFFBQVE7UUFBRTRELFdBQVc7UUFBeUJlLEdBQUdRLGFBQWFHLE1BQU0sR0FBRztRQUFHUyxJQUFJO1FBQVNDLEtBQUtkO1FBQVNyQixPQUFPZ0I7SUFBVyxHQUFHRCxRQUM5SWpCO0FBQ1I7QUFDQSxJQUFJc0MsMkJBQWE3RiwyQ0FBSUEsQ0FBQ3FFO0FBRXRCLE1BQU15QixnQkFBZ0IsQ0FBQ0MsT0FBVTtRQUM3QmQsT0FBT2MsS0FBS0MsV0FBVztRQUN2QmQsUUFBUWEsS0FBS0UsWUFBWTtJQUM3QjtBQUNBLE1BQU1DLFFBQVEsQ0FBQ0MsS0FBS0MsTUFBTSxDQUFDLEVBQUVDLE1BQU0sQ0FBQyxHQUFLQyxLQUFLRixHQUFHLENBQUNFLEtBQUtELEdBQUcsQ0FBQ0YsS0FBS0MsTUFBTUM7QUFDdEUsTUFBTUUsZ0JBQWdCLENBQUNqRCxXQUFXO0lBQUVnQixHQUFHO0lBQUdDLEdBQUc7QUFBRSxDQUFDLEVBQUVpQyxTQUFZO1FBQzFEbEMsR0FBRzRCLE1BQU01QyxTQUFTZ0IsQ0FBQyxFQUFFa0MsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUMvQ2pDLEdBQUcyQixNQUFNNUMsU0FBU2lCLENBQUMsRUFBRWlDLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDbkQ7QUFDQSxnRkFBZ0Y7QUFDaEYsb0RBQW9EO0FBQ3BELE1BQU1DLHNCQUFzQixDQUFDQyxPQUFPTixLQUFLQztJQUNyQyxJQUFJSyxRQUFRTixLQUFLO1FBQ2IsT0FBT0YsTUFBTUksS0FBS0ssR0FBRyxDQUFDRCxRQUFRTixNQUFNLEdBQUcsTUFBTTtJQUNqRCxPQUNLLElBQUlNLFFBQVFMLEtBQUs7UUFDbEIsT0FBTyxDQUFDSCxNQUFNSSxLQUFLSyxHQUFHLENBQUNELFFBQVFMLE1BQU0sR0FBRyxNQUFNO0lBQ2xEO0lBQ0EsT0FBTztBQUNYO0FBQ0EsTUFBTU8sY0FBYyxDQUFDQyxLQUFLQztJQUN0QixNQUFNQyxZQUFZTixvQkFBb0JJLElBQUl2QyxDQUFDLEVBQUUsSUFBSXdDLE9BQU83QixLQUFLLEdBQUcsTUFBTTtJQUN0RSxNQUFNK0IsWUFBWVAsb0JBQW9CSSxJQUFJdEMsQ0FBQyxFQUFFLElBQUl1QyxPQUFPNUIsTUFBTSxHQUFHLE1BQU07SUFDdkUsT0FBTztRQUFDNkI7UUFBV0M7S0FBVTtBQUNqQztBQUNBLE1BQU1DLG9CQUFvQixDQUFDQyxVQUFZQSxRQUFRQyxXQUFXLFFBQVFDLFFBQVFDO0FBQzFFLE1BQU1DLG1CQUFtQixDQUFDQyxNQUFNQyxPQUFVO1FBQ3RDbEQsR0FBR2dDLEtBQUtGLEdBQUcsQ0FBQ21CLEtBQUtqRCxDQUFDLEVBQUVrRCxLQUFLbEQsQ0FBQztRQUMxQkMsR0FBRytCLEtBQUtGLEdBQUcsQ0FBQ21CLEtBQUtoRCxDQUFDLEVBQUVpRCxLQUFLakQsQ0FBQztRQUMxQmtELElBQUluQixLQUFLRCxHQUFHLENBQUNrQixLQUFLRSxFQUFFLEVBQUVELEtBQUtDLEVBQUU7UUFDN0JDLElBQUlwQixLQUFLRCxHQUFHLENBQUNrQixLQUFLRyxFQUFFLEVBQUVGLEtBQUtFLEVBQUU7SUFDakM7QUFDQSxNQUFNQyxZQUFZLENBQUMsRUFBRXJELENBQUMsRUFBRUMsQ0FBQyxFQUFFVSxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFNO1FBQzVDWjtRQUNBQztRQUNBa0QsSUFBSW5ELElBQUlXO1FBQ1J5QyxJQUFJbkQsSUFBSVc7SUFDWjtBQUNBLE1BQU0wQyxZQUFZLENBQUMsRUFBRXRELENBQUMsRUFBRUMsQ0FBQyxFQUFFa0QsRUFBRSxFQUFFQyxFQUFFLEVBQUUsR0FBTTtRQUNyQ3BEO1FBQ0FDO1FBQ0FVLE9BQU93QyxLQUFLbkQ7UUFDWlksUUFBUXdDLEtBQUtuRDtJQUNqQjtBQUNBLE1BQU1zRCxhQUFhLENBQUM5QixPQUFVO1FBQzFCLEdBQUlBLEtBQUsrQixnQkFBZ0IsSUFBSTtZQUFFeEQsR0FBRztZQUFHQyxHQUFHO1FBQUUsQ0FBQztRQUMzQ1UsT0FBT2MsS0FBS2QsS0FBSyxJQUFJO1FBQ3JCQyxRQUFRYSxLQUFLYixNQUFNLElBQUk7SUFDM0I7QUFDQSxNQUFNNkMsbUJBQW1CLENBQUNDLE9BQU9DLFFBQVVMLFVBQVVOLGlCQUFpQkssVUFBVUssUUFBUUwsVUFBVU07QUFDbEcsTUFBTUMscUJBQXFCLENBQUNDLE9BQU9DO0lBQy9CLE1BQU1DLFdBQVcvQixLQUFLRCxHQUFHLENBQUMsR0FBR0MsS0FBS0YsR0FBRyxDQUFDK0IsTUFBTTdELENBQUMsR0FBRzZELE1BQU1sRCxLQUFLLEVBQUVtRCxNQUFNOUQsQ0FBQyxHQUFHOEQsTUFBTW5ELEtBQUssSUFBSXFCLEtBQUtELEdBQUcsQ0FBQzhCLE1BQU03RCxDQUFDLEVBQUU4RCxNQUFNOUQsQ0FBQztJQUMvRyxNQUFNZ0UsV0FBV2hDLEtBQUtELEdBQUcsQ0FBQyxHQUFHQyxLQUFLRixHQUFHLENBQUMrQixNQUFNNUQsQ0FBQyxHQUFHNEQsTUFBTWpELE1BQU0sRUFBRWtELE1BQU03RCxDQUFDLEdBQUc2RCxNQUFNbEQsTUFBTSxJQUFJb0IsS0FBS0QsR0FBRyxDQUFDOEIsTUFBTTVELENBQUMsRUFBRTZELE1BQU03RCxDQUFDO0lBQ2pILE9BQU8rQixLQUFLaUMsSUFBSSxDQUFDRixXQUFXQztBQUNoQztBQUNBLDhEQUE4RDtBQUM5RCxNQUFNRSxlQUFlLENBQUNDLE1BQVFDLFVBQVVELElBQUl4RCxLQUFLLEtBQUt5RCxVQUFVRCxJQUFJdkQsTUFBTSxLQUFLd0QsVUFBVUQsSUFBSW5FLENBQUMsS0FBS29FLFVBQVVELElBQUlsRSxDQUFDO0FBQ2xILCtEQUErRCxHQUMvRCxNQUFNbUUsWUFBWSxDQUFDQyxJQUFNLENBQUNDLE1BQU1ELE1BQU1FLFNBQVNGO0FBQy9DLE1BQU1HLGtCQUFrQkMsT0FBT0MsR0FBRyxDQUFDO0FBQ25DLHVEQUF1RDtBQUN2RCxNQUFNQyx1QkFBdUI7SUFBQztJQUFTO0lBQUs7Q0FBUztBQUNyRCxNQUFNQyxVQUFVLENBQUN0SCxJQUFJdUg7SUFDakIsSUFBSUMsSUFBeUIsRUFBZTtRQUN4Q0MsUUFBUUMsSUFBSSxDQUFDLENBQUMsY0FBYyxFQUFFSCxRQUFRLG1DQUFtQyxFQUFFdkgsR0FBRyxDQUFDO0lBQ25GO0FBQ0o7QUFDQSxNQUFNMkgsdUJBQXVCLENBQUNDLFFBQVUsaUJBQWlCQTtBQUN6RCxTQUFTQyxlQUFlRCxLQUFLO0lBQ3pCLE1BQU1FLFVBQVVILHFCQUFxQkMsU0FBU0EsTUFBTUcsV0FBVyxHQUFHSDtJQUNsRSw4Q0FBOEM7SUFDOUMsTUFBTXJGLFNBQVV1RixRQUFRRSxZQUFZLE1BQU0sQ0FBQyxFQUFFLElBQUlKLE1BQU1yRixNQUFNO0lBQzdELE1BQU0wRixVQUFVO1FBQUM7UUFBUztRQUFVO0tBQVcsQ0FBQ0MsUUFBUSxDQUFDM0YsUUFBUTRGLGFBQWE1RixRQUFRNkYsYUFBYTtJQUNuRyx3RkFBd0Y7SUFDeEYsT0FBT0gsV0FBVyxDQUFDLENBQUMxRixRQUFROEYsUUFBUTtBQUN4QztBQUNBLE1BQU1DLGVBQWUsQ0FBQ1YsUUFBVSxhQUFhQTtBQUM3QyxNQUFNVyxtQkFBbUIsQ0FBQ1gsT0FBTzFDO0lBQzdCLE1BQU1zRCxtQkFBbUJGLGFBQWFWO0lBQ3RDLE1BQU1hLE9BQU9ELG1CQUFtQlosTUFBTWMsT0FBTyxHQUFHZCxNQUFNZSxPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUNEO0lBQ25FLE1BQU1FLE9BQU9KLG1CQUFtQlosTUFBTWlCLE9BQU8sR0FBR2pCLE1BQU1lLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQ0U7SUFDbkUsT0FBTztRQUNIbkcsR0FBRytGLE9BQVF2RCxDQUFBQSxRQUFRNEQsUUFBUTtRQUMzQm5HLEdBQUdpRyxPQUFRMUQsQ0FBQUEsUUFBUTZELE9BQU87SUFDOUI7QUFDSjtBQUNBLE1BQU1DLFVBQVUsSUFBTSxPQUFPQyxjQUFjLGVBQWVBLFdBQVdDLFdBQVdDLFFBQVEsVUFBVTtBQUVsRyxNQUFNQyxXQUFXLENBQUMsRUFBRXBKLEVBQUUsRUFBRXFKLElBQUksRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUUzRyxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUVDLGNBQWMsRUFBRUMsbUJBQW1CLEVBQUVwQixLQUFLLEVBQUUySCxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsbUJBQW1CLEVBQUUsRUFBRztJQUNwTCxxQkFBUTFMLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLG9CQUN4Q0EsZ0RBQW1CLENBQUMsUUFBUTtRQUFFZ0MsSUFBSUE7UUFBSTZCLE9BQU9BO1FBQU8rSCxHQUFHUDtRQUFNUSxNQUFNO1FBQVFqSSxXQUFXO1FBQXlCNEgsV0FBV0E7UUFBV0MsYUFBYUE7SUFBWSxJQUM5SkMsa0NBQXFCMUwsZ0RBQW1CLENBQUMsUUFBUTtRQUFFNEwsR0FBR1A7UUFBTVEsTUFBTTtRQUFRQyxlQUFlO1FBQUdDLGFBQWFMO1FBQWtCOUgsV0FBVztJQUErQixJQUNyS2dCLFNBQVNrRSxVQUFVd0MsV0FBV3hDLFVBQVV5Qyx3QkFBV3ZMLGdEQUFtQixDQUFDaUcsWUFBWTtRQUFFdkIsR0FBRzRHO1FBQVEzRyxHQUFHNEc7UUFBUTNHLE9BQU9BO1FBQU9DLFlBQVlBO1FBQVlDLGFBQWFBO1FBQWFDLGNBQWNBO1FBQWNDLGdCQUFnQkE7UUFBZ0JDLHFCQUFxQkE7SUFBb0IsS0FBTTtBQUM5UjtBQUNBbUcsU0FBU1ksV0FBVyxHQUFHO0FBRXZCLE1BQU1DLGVBQWUsQ0FBQ0MsWUFBWUM7SUFDOUIsSUFBSSxPQUFPQSxnQkFBZ0IsZUFBZUEsYUFBYTtRQUNuRCxPQUFPLENBQUMsS0FBSyxFQUFFQSxZQUFZLENBQUMsQ0FBQztJQUNqQztJQUNBLE9BQU8sT0FBT0QsZUFBZSxjQUFjLENBQUMsaUJBQWlCLEVBQUVBLFdBQVcsQ0FBQyxDQUFDLEdBQUc7QUFDbkY7QUFDQSxTQUFTRSxrQkFBa0JwSyxFQUFFLEVBQUVrQixRQUFRLEVBQUVtSixPQUFPO0lBQzVDLE9BQU9BLFlBQVlDLFlBQ2JELFVBQ0EsQ0FBQ3pDO1FBQ0MsTUFBTXZILE9BQU9hLFdBQVdxSixLQUFLLENBQUNDLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxFQUFFekssRUFBRSxLQUFLQTtRQUNuRCxJQUFJSyxNQUFNO1lBQ05nSyxRQUFRekMsT0FBTztnQkFBRSxHQUFHdkgsSUFBSTtZQUFDO1FBQzdCO0lBQ0o7QUFDUjtBQUNBLG1GQUFtRjtBQUNuRixTQUFTcUssY0FBYyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUc7SUFDMUQsTUFBTUMsVUFBVXJHLEtBQUtLLEdBQUcsQ0FBQzhGLFVBQVVGLFdBQVc7SUFDOUMsTUFBTUssVUFBVUgsVUFBVUYsVUFBVUUsVUFBVUUsVUFBVUYsVUFBVUU7SUFDbEUsTUFBTUUsVUFBVXZHLEtBQUtLLEdBQUcsQ0FBQytGLFVBQVVGLFdBQVc7SUFDOUMsTUFBTU0sVUFBVUosVUFBVUYsVUFBVUUsVUFBVUcsVUFBVUgsVUFBVUc7SUFDbEUsT0FBTztRQUFDRDtRQUFTRTtRQUFTSDtRQUFTRTtLQUFRO0FBQy9DO0FBQ0EsU0FBU0Usb0JBQW9CLEVBQUVSLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRU0sY0FBYyxFQUFFQyxjQUFjLEVBQUVDLGNBQWMsRUFBRUMsY0FBYyxFQUFHO0lBQ2hJLGdGQUFnRjtJQUNoRiw4RkFBOEY7SUFDOUYsTUFBTVAsVUFBVUwsVUFBVSxRQUFRUyxpQkFBaUIsUUFBUUUsaUJBQWlCLFFBQVFULFVBQVU7SUFDOUYsTUFBTUssVUFBVU4sVUFBVSxRQUFRUyxpQkFBaUIsUUFBUUUsaUJBQWlCLFFBQVFULFVBQVU7SUFDOUYsTUFBTVUsVUFBVTlHLEtBQUtLLEdBQUcsQ0FBQ2lHLFVBQVVMO0lBQ25DLE1BQU1jLFVBQVUvRyxLQUFLSyxHQUFHLENBQUNtRyxVQUFVTjtJQUNuQyxPQUFPO1FBQUNJO1FBQVNFO1FBQVNNO1FBQVNDO0tBQVE7QUFDL0M7QUFFQSxJQUFJQztBQUNILFVBQVVBLGNBQWM7SUFDckJBLGNBQWMsQ0FBQyxTQUFTLEdBQUc7SUFDM0JBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7QUFDOUIsR0FBR0Esa0JBQW1CQSxDQUFBQSxpQkFBaUIsQ0FBQztBQUN4QyxJQUFJQztBQUNILFVBQVVBLGVBQWU7SUFDdEJBLGVBQWUsQ0FBQyxPQUFPLEdBQUc7SUFDMUJBLGVBQWUsQ0FBQyxXQUFXLEdBQUc7SUFDOUJBLGVBQWUsQ0FBQyxhQUFhLEdBQUc7QUFDcEMsR0FBR0EsbUJBQW9CQSxDQUFBQSxrQkFBa0IsQ0FBQztBQUMxQyxJQUFJQztBQUNILFVBQVVBLGFBQWE7SUFDcEJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7QUFDNUIsR0FBR0EsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztBQUV0QyxJQUFJQztBQUNILFVBQVVBLGtCQUFrQjtJQUN6QkEsa0JBQWtCLENBQUMsU0FBUyxHQUFHO0lBQy9CQSxrQkFBa0IsQ0FBQyxXQUFXLEdBQUc7SUFDakNBLGtCQUFrQixDQUFDLE9BQU8sR0FBRztJQUM3QkEsa0JBQWtCLENBQUMsYUFBYSxHQUFHO0lBQ25DQSxrQkFBa0IsQ0FBQyxlQUFlLEdBQUc7QUFDekMsR0FBR0Esc0JBQXVCQSxDQUFBQSxxQkFBcUIsQ0FBQztBQUNoRCxJQUFJQztBQUNILFVBQVVBLFVBQVU7SUFDakJBLFVBQVUsQ0FBQyxRQUFRLEdBQUc7SUFDdEJBLFVBQVUsQ0FBQyxjQUFjLEdBQUc7QUFDaEMsR0FBR0EsY0FBZUEsQ0FBQUEsYUFBYSxDQUFDO0FBRWhDLElBQUlDO0FBQ0gsVUFBVUEsUUFBUTtJQUNmQSxRQUFRLENBQUMsT0FBTyxHQUFHO0lBQ25CQSxRQUFRLENBQUMsTUFBTSxHQUFHO0lBQ2xCQSxRQUFRLENBQUMsUUFBUSxHQUFHO0lBQ3BCQSxRQUFRLENBQUMsU0FBUyxHQUFHO0FBQ3pCLEdBQUdBLFlBQWFBLENBQUFBLFdBQVcsQ0FBQztBQUU1QixTQUFTQyxXQUFXLEVBQUUvRyxHQUFHLEVBQUVnSCxFQUFFLEVBQUVDLEVBQUUsRUFBRXJHLEVBQUUsRUFBRUMsRUFBRSxFQUFFO0lBQ3ZDLElBQUliLFFBQVE4RyxTQUFTSSxJQUFJLElBQUlsSCxRQUFROEcsU0FBU0ssS0FBSyxFQUFFO1FBQ2pELE9BQU87WUFBQyxNQUFPSCxDQUFBQSxLQUFLcEcsRUFBQztZQUFJcUc7U0FBRztJQUNoQztJQUNBLE9BQU87UUFBQ0Q7UUFBSSxNQUFPQyxDQUFBQSxLQUFLcEcsRUFBQztLQUFHO0FBQ2hDO0FBQ0EsU0FBU3VHLG9CQUFvQixFQUFFMUIsT0FBTyxFQUFFQyxPQUFPLEVBQUUwQixpQkFBaUJQLFNBQVNRLE1BQU0sRUFBRTFCLE9BQU8sRUFBRUMsT0FBTyxFQUFFMEIsaUJBQWlCVCxTQUFTVSxHQUFHLEVBQUc7SUFDakksTUFBTSxDQUFDckIsZ0JBQWdCQyxlQUFlLEdBQUdXLFdBQVc7UUFDaEQvRyxLQUFLcUg7UUFDTEwsSUFBSXRCO1FBQ0p1QixJQUFJdEI7UUFDSi9FLElBQUlnRjtRQUNKL0UsSUFBSWdGO0lBQ1I7SUFDQSxNQUFNLENBQUNRLGdCQUFnQkMsZUFBZSxHQUFHUyxXQUFXO1FBQ2hEL0csS0FBS3VIO1FBQ0xQLElBQUlwQjtRQUNKcUIsSUFBSXBCO1FBQ0pqRixJQUFJOEU7UUFDSjdFLElBQUk4RTtJQUNSO0lBQ0EsTUFBTSxDQUFDdEIsUUFBUUMsUUFBUWlDLFNBQVNDLFFBQVEsR0FBR04sb0JBQW9CO1FBQzNEUjtRQUNBQztRQUNBQztRQUNBQztRQUNBTTtRQUNBQztRQUNBQztRQUNBQztJQUNKO0lBQ0EsT0FBTztRQUNILENBQUMsQ0FBQyxFQUFFWixRQUFRLENBQUMsRUFBRUMsUUFBUSxFQUFFLEVBQUVRLGVBQWUsQ0FBQyxFQUFFQyxlQUFlLENBQUMsRUFBRUMsZUFBZSxDQUFDLEVBQUVDLGVBQWUsQ0FBQyxFQUFFVixRQUFRLENBQUMsRUFBRUMsUUFBUSxDQUFDO1FBQ3ZIeEI7UUFDQUM7UUFDQWlDO1FBQ0FDO0tBQ0g7QUFDTDtBQUNBLE1BQU1pQixpQ0FBbUJ0TywyQ0FBSUEsQ0FBQyxDQUFDLEVBQUV1TSxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUV3QixpQkFBaUJQLFNBQVNRLE1BQU0sRUFBRUMsaUJBQWlCVCxTQUFTVSxHQUFHLEVBQUU3SixLQUFLLEVBQUVDLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUVDLGNBQWMsRUFBRUMsbUJBQW1CLEVBQUVwQixLQUFLLEVBQUUySCxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsZ0JBQWdCLEVBQUc7SUFDdlEsTUFBTSxDQUFDTCxNQUFNQyxRQUFRQyxPQUFPLEdBQUc4QyxvQkFBb0I7UUFDL0MxQjtRQUNBQztRQUNBMEI7UUFDQXpCO1FBQ0FDO1FBQ0EwQjtJQUNKO0lBQ0EscUJBQVF4TyxnREFBbUIsQ0FBQ29MLFVBQVU7UUFBRUMsTUFBTUE7UUFBTUMsUUFBUUE7UUFBUUMsUUFBUUE7UUFBUTNHLE9BQU9BO1FBQU9DLFlBQVlBO1FBQVlDLGFBQWFBO1FBQWFDLGNBQWNBO1FBQWNDLGdCQUFnQkE7UUFBZ0JDLHFCQUFxQkE7UUFBcUJwQixPQUFPQTtRQUFPMkgsV0FBV0E7UUFBV0MsYUFBYUE7UUFBYUMsa0JBQWtCQTtJQUFpQjtBQUMvVjtBQUNBZ0QsaUJBQWlCMUMsV0FBVyxHQUFHO0FBRS9CLE1BQU0yQyxtQkFBbUI7SUFDckIsQ0FBQ1osU0FBU0ksSUFBSSxDQUFDLEVBQUU7UUFBRXpKLEdBQUcsQ0FBQztRQUFHQyxHQUFHO0lBQUU7SUFDL0IsQ0FBQ29KLFNBQVNLLEtBQUssQ0FBQyxFQUFFO1FBQUUxSixHQUFHO1FBQUdDLEdBQUc7SUFBRTtJQUMvQixDQUFDb0osU0FBU1UsR0FBRyxDQUFDLEVBQUU7UUFBRS9KLEdBQUc7UUFBR0MsR0FBRyxDQUFDO0lBQUU7SUFDOUIsQ0FBQ29KLFNBQVNRLE1BQU0sQ0FBQyxFQUFFO1FBQUU3SixHQUFHO1FBQUdDLEdBQUc7SUFBRTtBQUNwQztBQUNBLE1BQU1pSyxlQUFlLENBQUMsRUFBRUMsTUFBTSxFQUFFUCxpQkFBaUJQLFNBQVNRLE1BQU0sRUFBRWhLLE1BQU0sRUFBRztJQUN2RSxJQUFJK0osbUJBQW1CUCxTQUFTSSxJQUFJLElBQUlHLG1CQUFtQlAsU0FBU0ssS0FBSyxFQUFFO1FBQ3ZFLE9BQU9TLE9BQU9uSyxDQUFDLEdBQUdILE9BQU9HLENBQUMsR0FBRztZQUFFQSxHQUFHO1lBQUdDLEdBQUc7UUFBRSxJQUFJO1lBQUVELEdBQUcsQ0FBQztZQUFHQyxHQUFHO1FBQUU7SUFDaEU7SUFDQSxPQUFPa0ssT0FBT2xLLENBQUMsR0FBR0osT0FBT0ksQ0FBQyxHQUFHO1FBQUVELEdBQUc7UUFBR0MsR0FBRztJQUFFLElBQUk7UUFBRUQsR0FBRztRQUFHQyxHQUFHLENBQUM7SUFBRTtBQUNoRTtBQUNBLE1BQU1tSyxXQUFXLENBQUNDLEdBQUdDLElBQU10SSxLQUFLdUksSUFBSSxDQUFDdkksS0FBS3dJLEdBQUcsQ0FBQ0YsRUFBRXRLLENBQUMsR0FBR3FLLEVBQUVySyxDQUFDLEVBQUUsS0FBS2dDLEtBQUt3SSxHQUFHLENBQUNGLEVBQUVySyxDQUFDLEdBQUdvSyxFQUFFcEssQ0FBQyxFQUFFO0FBQ2xGLHdFQUF3RTtBQUN4RSxpSUFBaUk7QUFDakksU0FBU3dLLFVBQVUsRUFBRU4sTUFBTSxFQUFFUCxpQkFBaUJQLFNBQVNRLE1BQU0sRUFBRWhLLE1BQU0sRUFBRWlLLGlCQUFpQlQsU0FBU1UsR0FBRyxFQUFFVyxNQUFNLEVBQUVDLE1BQU0sRUFBRztJQUNuSCxNQUFNQyxZQUFZWCxnQkFBZ0IsQ0FBQ0wsZUFBZTtJQUNsRCxNQUFNaUIsWUFBWVosZ0JBQWdCLENBQUNILGVBQWU7SUFDbEQsTUFBTWdCLGVBQWU7UUFBRTlLLEdBQUdtSyxPQUFPbkssQ0FBQyxHQUFHNEssVUFBVTVLLENBQUMsR0FBRzJLO1FBQVExSyxHQUFHa0ssT0FBT2xLLENBQUMsR0FBRzJLLFVBQVUzSyxDQUFDLEdBQUcwSztJQUFPO0lBQzlGLE1BQU1JLGVBQWU7UUFBRS9LLEdBQUdILE9BQU9HLENBQUMsR0FBRzZLLFVBQVU3SyxDQUFDLEdBQUcySztRQUFRMUssR0FBR0osT0FBT0ksQ0FBQyxHQUFHNEssVUFBVTVLLENBQUMsR0FBRzBLO0lBQU87SUFDOUYsTUFBTUssTUFBTWQsYUFBYTtRQUNyQkMsUUFBUVc7UUFDUmxCO1FBQ0EvSixRQUFRa0w7SUFDWjtJQUNBLE1BQU1FLGNBQWNELElBQUloTCxDQUFDLEtBQUssSUFBSSxNQUFNO0lBQ3hDLE1BQU1rTCxVQUFVRixHQUFHLENBQUNDLFlBQVk7SUFDaEMsSUFBSUUsU0FBUyxFQUFFO0lBQ2YsSUFBSTdDLFNBQVNFO0lBQ2IsTUFBTTRDLGtCQUFrQjtRQUFFcEwsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFDckMsTUFBTW9MLGtCQUFrQjtRQUFFckwsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFDckMsTUFBTSxDQUFDcUwsZ0JBQWdCQyxnQkFBZ0JDLGdCQUFnQkMsZUFBZSxHQUFHekQsY0FBYztRQUNuRkMsU0FBU2tDLE9BQU9uSyxDQUFDO1FBQ2pCa0ksU0FBU2lDLE9BQU9sSyxDQUFDO1FBQ2pCa0ksU0FBU3RJLE9BQU9HLENBQUM7UUFDakJvSSxTQUFTdkksT0FBT0ksQ0FBQztJQUNyQjtJQUNBLDBDQUEwQztJQUMxQyxJQUFJMkssU0FBUyxDQUFDSyxZQUFZLEdBQUdKLFNBQVMsQ0FBQ0ksWUFBWSxLQUFLLENBQUMsR0FBRztRQUN4RDNDLFVBQVVvQyxPQUFPMUssQ0FBQyxJQUFJc0w7UUFDdEI5QyxVQUFVa0MsT0FBT3pLLENBQUMsSUFBSXNMO1FBQ3RCLFVBQVU7UUFDVixPQUFPO1FBQ1AsT0FBTztRQUNQLE1BQU1HLGdCQUFnQjtZQUNsQjtnQkFBRTFMLEdBQUdzSTtnQkFBU3JJLEdBQUc2SyxhQUFhN0ssQ0FBQztZQUFDO1lBQ2hDO2dCQUFFRCxHQUFHc0k7Z0JBQVNySSxHQUFHOEssYUFBYTlLLENBQUM7WUFBQztTQUNuQztRQUNELE9BQU87UUFDUCxPQUFPO1FBQ1AsS0FBSztRQUNMLE1BQU0wTCxrQkFBa0I7WUFDcEI7Z0JBQUUzTCxHQUFHOEssYUFBYTlLLENBQUM7Z0JBQUVDLEdBQUd1STtZQUFRO1lBQ2hDO2dCQUFFeEksR0FBRytLLGFBQWEvSyxDQUFDO2dCQUFFQyxHQUFHdUk7WUFBUTtTQUNuQztRQUNELElBQUlvQyxTQUFTLENBQUNLLFlBQVksS0FBS0MsU0FBUztZQUNwQ0MsU0FBU0YsZ0JBQWdCLE1BQU1TLGdCQUFnQkM7UUFDbkQsT0FDSztZQUNEUixTQUFTRixnQkFBZ0IsTUFBTVUsa0JBQWtCRDtRQUNyRDtJQUNKLE9BQ0s7UUFDRCwyRkFBMkY7UUFDM0YsTUFBTUUsZUFBZTtZQUFDO2dCQUFFNUwsR0FBRzhLLGFBQWE5SyxDQUFDO2dCQUFFQyxHQUFHOEssYUFBYTlLLENBQUM7WUFBQztTQUFFO1FBQy9ELE1BQU00TCxlQUFlO1lBQUM7Z0JBQUU3TCxHQUFHK0ssYUFBYS9LLENBQUM7Z0JBQUVDLEdBQUc2SyxhQUFhN0ssQ0FBQztZQUFDO1NBQUU7UUFDL0QsZ0RBQWdEO1FBQ2hELElBQUlnTCxnQkFBZ0IsS0FBSztZQUNyQkUsU0FBU1AsVUFBVTVLLENBQUMsS0FBS2tMLFVBQVVXLGVBQWVEO1FBQ3RELE9BQ0s7WUFDRFQsU0FBU1AsVUFBVTNLLENBQUMsS0FBS2lMLFVBQVVVLGVBQWVDO1FBQ3REO1FBQ0EsSUFBSWpDLG1CQUFtQkUsZ0JBQWdCO1lBQ25DLE1BQU1nQyxPQUFPOUosS0FBS0ssR0FBRyxDQUFDOEgsTUFBTSxDQUFDYyxZQUFZLEdBQUdwTCxNQUFNLENBQUNvTCxZQUFZO1lBQy9ELGdUQUFnVDtZQUNoVCxJQUFJYSxRQUFRbkIsUUFBUTtnQkFDaEIsTUFBTW9CLFlBQVkvSixLQUFLRixHQUFHLENBQUM2SSxTQUFTLEdBQUdBLFNBQVNtQjtnQkFDaEQsSUFBSWxCLFNBQVMsQ0FBQ0ssWUFBWSxLQUFLQyxTQUFTO29CQUNwQ0UsZUFBZSxDQUFDSCxZQUFZLEdBQUcsQ0FBQ0gsWUFBWSxDQUFDRyxZQUFZLEdBQUdkLE1BQU0sQ0FBQ2MsWUFBWSxHQUFHLENBQUMsSUFBSSxLQUFLYztnQkFDaEcsT0FDSztvQkFDRFYsZUFBZSxDQUFDSixZQUFZLEdBQUcsQ0FBQ0YsWUFBWSxDQUFDRSxZQUFZLEdBQUdwTCxNQUFNLENBQUNvTCxZQUFZLEdBQUcsQ0FBQyxJQUFJLEtBQUtjO2dCQUNoRztZQUNKO1FBQ0o7UUFDQSw0RkFBNEY7UUFDNUYsSUFBSW5DLG1CQUFtQkUsZ0JBQWdCO1lBQ25DLE1BQU1rQyxzQkFBc0JmLGdCQUFnQixNQUFNLE1BQU07WUFDeEQsTUFBTWdCLFlBQVlyQixTQUFTLENBQUNLLFlBQVksS0FBS0osU0FBUyxDQUFDbUIsb0JBQW9CO1lBQzNFLE1BQU1FLHFCQUFxQnBCLFlBQVksQ0FBQ2tCLG9CQUFvQixHQUFHakIsWUFBWSxDQUFDaUIsb0JBQW9CO1lBQ2hHLE1BQU1HLHFCQUFxQnJCLFlBQVksQ0FBQ2tCLG9CQUFvQixHQUFHakIsWUFBWSxDQUFDaUIsb0JBQW9CO1lBQ2hHLE1BQU1JLG1CQUFtQixTQUFVLENBQUNuQixZQUFZLEtBQUssS0FBTSxFQUFFZ0IsYUFBYUMsc0JBQXdCRCxhQUFhRSxrQkFBa0IsS0FDNUh2QixTQUFTLENBQUNLLFlBQVksS0FBSyxLQUFNLEVBQUVnQixhQUFhRSxzQkFBd0JGLGFBQWFDLGtCQUFrQjtZQUM1RyxJQUFJRSxrQkFBa0I7Z0JBQ2xCakIsU0FBU0YsZ0JBQWdCLE1BQU1XLGVBQWVDO1lBQ2xEO1FBQ0o7UUFDQSxNQUFNUSxpQkFBaUI7WUFBRXJNLEdBQUc4SyxhQUFhOUssQ0FBQyxHQUFHb0wsZ0JBQWdCcEwsQ0FBQztZQUFFQyxHQUFHNkssYUFBYTdLLENBQUMsR0FBR21MLGdCQUFnQm5MLENBQUM7UUFBQztRQUN0RyxNQUFNcU0saUJBQWlCO1lBQUV0TSxHQUFHK0ssYUFBYS9LLENBQUMsR0FBR3FMLGdCQUFnQnJMLENBQUM7WUFBRUMsR0FBRzhLLGFBQWE5SyxDQUFDLEdBQUdvTCxnQkFBZ0JwTCxDQUFDO1FBQUM7UUFDdEcsTUFBTXNNLGVBQWV2SyxLQUFLRCxHQUFHLENBQUNDLEtBQUtLLEdBQUcsQ0FBQ2dLLGVBQWVyTSxDQUFDLEdBQUdtTCxNQUFNLENBQUMsRUFBRSxDQUFDbkwsQ0FBQyxHQUFHZ0MsS0FBS0ssR0FBRyxDQUFDaUssZUFBZXRNLENBQUMsR0FBR21MLE1BQU0sQ0FBQyxFQUFFLENBQUNuTCxDQUFDO1FBQy9HLE1BQU13TSxlQUFleEssS0FBS0QsR0FBRyxDQUFDQyxLQUFLSyxHQUFHLENBQUNnSyxlQUFlcE0sQ0FBQyxHQUFHa0wsTUFBTSxDQUFDLEVBQUUsQ0FBQ2xMLENBQUMsR0FBRytCLEtBQUtLLEdBQUcsQ0FBQ2lLLGVBQWVyTSxDQUFDLEdBQUdrTCxNQUFNLENBQUMsRUFBRSxDQUFDbEwsQ0FBQztRQUMvRyxnRUFBZ0U7UUFDaEUsSUFBSXNNLGdCQUFnQkMsY0FBYztZQUM5QmxFLFVBQVUsQ0FBQytELGVBQWVyTSxDQUFDLEdBQUdzTSxlQUFldE0sQ0FBQyxJQUFJO1lBQ2xEd0ksVUFBVTJDLE1BQU0sQ0FBQyxFQUFFLENBQUNsTCxDQUFDO1FBQ3pCLE9BQ0s7WUFDRHFJLFVBQVU2QyxNQUFNLENBQUMsRUFBRSxDQUFDbkwsQ0FBQztZQUNyQndJLFVBQVUsQ0FBQzZELGVBQWVwTSxDQUFDLEdBQUdxTSxlQUFlck0sQ0FBQyxJQUFJO1FBQ3REO0lBQ0o7SUFDQSxNQUFNd00sYUFBYTtRQUNmdEM7UUFDQTtZQUFFbkssR0FBRzhLLGFBQWE5SyxDQUFDLEdBQUdvTCxnQkFBZ0JwTCxDQUFDO1lBQUVDLEdBQUc2SyxhQUFhN0ssQ0FBQyxHQUFHbUwsZ0JBQWdCbkwsQ0FBQztRQUFDO1dBQzVFa0w7UUFDSDtZQUFFbkwsR0FBRytLLGFBQWEvSyxDQUFDLEdBQUdxTCxnQkFBZ0JyTCxDQUFDO1lBQUVDLEdBQUc4SyxhQUFhOUssQ0FBQyxHQUFHb0wsZ0JBQWdCcEwsQ0FBQztRQUFDO1FBQy9FSjtLQUNIO0lBQ0QsT0FBTztRQUFDNE07UUFBWW5FO1FBQVNFO1FBQVNnRDtRQUFnQkM7S0FBZTtBQUN6RTtBQUNBLFNBQVNpQixRQUFRckMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVxQyxDQUFDLEVBQUVDLElBQUk7SUFDMUIsTUFBTUMsV0FBVzdLLEtBQUtGLEdBQUcsQ0FBQ3NJLFNBQVNDLEdBQUdDLEtBQUssR0FBR0YsU0FBU0UsR0FBR3FDLEtBQUssR0FBR0M7SUFDbEUsTUFBTSxFQUFFNU0sQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBR3FLO0lBQ2pCLFVBQVU7SUFDVixJQUFJLEVBQUd0SyxDQUFDLEtBQUtBLEtBQUtBLE1BQU0yTSxFQUFFM00sQ0FBQyxJQUFNcUssRUFBRXBLLENBQUMsS0FBS0EsS0FBS0EsTUFBTTBNLEVBQUUxTSxDQUFDLEVBQUc7UUFDdEQsT0FBTyxDQUFDLENBQUMsRUFBRUQsRUFBRSxDQUFDLEVBQUVDLEVBQUUsQ0FBQztJQUN2QjtJQUNBLDhCQUE4QjtJQUM5QixJQUFJb0ssRUFBRXBLLENBQUMsS0FBS0EsR0FBRztRQUNYLE1BQU02TSxPQUFPekMsRUFBRXJLLENBQUMsR0FBRzJNLEVBQUUzTSxDQUFDLEdBQUcsQ0FBQyxJQUFJO1FBQzlCLE1BQU0rTSxPQUFPMUMsRUFBRXBLLENBQUMsR0FBRzBNLEVBQUUxTSxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQzlCLE9BQU8sQ0FBQyxFQUFFLEVBQUVELElBQUk2TSxXQUFXQyxLQUFLLENBQUMsRUFBRTdNLEVBQUUsRUFBRSxFQUFFRCxFQUFFLENBQUMsRUFBRUMsRUFBRSxDQUFDLEVBQUVELEVBQUUsQ0FBQyxFQUFFQyxJQUFJNE0sV0FBV0UsS0FBSyxDQUFDO0lBQ2pGO0lBQ0EsTUFBTUQsT0FBT3pDLEVBQUVySyxDQUFDLEdBQUcyTSxFQUFFM00sQ0FBQyxHQUFHLElBQUksQ0FBQztJQUM5QixNQUFNK00sT0FBTzFDLEVBQUVwSyxDQUFDLEdBQUcwTSxFQUFFMU0sQ0FBQyxHQUFHLENBQUMsSUFBSTtJQUM5QixPQUFPLENBQUMsRUFBRSxFQUFFRCxFQUFFLENBQUMsRUFBRUMsSUFBSTRNLFdBQVdFLEtBQUssRUFBRSxFQUFFL00sRUFBRSxDQUFDLEVBQUVDLEVBQUUsQ0FBQyxFQUFFRCxJQUFJNk0sV0FBV0MsS0FBSyxDQUFDLEVBQUU3TSxFQUFFLENBQUM7QUFDakY7QUFDQSxTQUFTK00sa0JBQWtCLEVBQUUvRSxPQUFPLEVBQUVDLE9BQU8sRUFBRTBCLGlCQUFpQlAsU0FBU1EsTUFBTSxFQUFFMUIsT0FBTyxFQUFFQyxPQUFPLEVBQUUwQixpQkFBaUJULFNBQVNVLEdBQUcsRUFBRWtELGVBQWUsQ0FBQyxFQUFFM0UsT0FBTyxFQUFFRSxPQUFPLEVBQUVtQyxTQUFTLEVBQUUsRUFBRztJQUNoTCxNQUFNLENBQUNRLFFBQVF2RSxRQUFRQyxRQUFRaUMsU0FBU0MsUUFBUSxHQUFHMEIsVUFBVTtRQUN6RE4sUUFBUTtZQUFFbkssR0FBR2lJO1lBQVNoSSxHQUFHaUk7UUFBUTtRQUNqQzBCO1FBQ0EvSixRQUFRO1lBQUVHLEdBQUdtSTtZQUFTbEksR0FBR21JO1FBQVE7UUFDakMwQjtRQUNBWSxRQUFRO1lBQUUxSyxHQUFHc0k7WUFBU3JJLEdBQUd1STtRQUFRO1FBQ2pDbUM7SUFDSjtJQUNBLE1BQU1oRSxPQUFPd0UsT0FBTytCLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxHQUFHQztRQUNoQyxJQUFJQyxVQUFVO1FBQ2QsSUFBSUQsSUFBSSxLQUFLQSxJQUFJbEMsT0FBT29DLE1BQU0sR0FBRyxHQUFHO1lBQ2hDRCxVQUFVWixRQUFRdkIsTUFBTSxDQUFDa0MsSUFBSSxFQUFFLEVBQUVELEdBQUdqQyxNQUFNLENBQUNrQyxJQUFJLEVBQUUsRUFBRUo7UUFDdkQsT0FDSztZQUNESyxVQUFVLENBQUMsRUFBRUQsTUFBTSxJQUFJLE1BQU0sSUFBSSxFQUFFRCxFQUFFcE4sQ0FBQyxDQUFDLENBQUMsRUFBRW9OLEVBQUVuTixDQUFDLENBQUMsQ0FBQztRQUNuRDtRQUNBa04sT0FBT0c7UUFDUCxPQUFPSDtJQUNYLEdBQUc7SUFDSCxPQUFPO1FBQUN4RztRQUFNQztRQUFRQztRQUFRaUM7UUFBU0M7S0FBUTtBQUNuRDtBQUNBLE1BQU15RSwrQkFBaUI5UiwyQ0FBSUEsQ0FBQyxDQUFDLEVBQUV1TSxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVsSSxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUVDLGNBQWMsRUFBRUMsbUJBQW1CLEVBQUVwQixLQUFLLEVBQUV5SyxpQkFBaUJQLFNBQVNRLE1BQU0sRUFBRUMsaUJBQWlCVCxTQUFTVSxHQUFHLEVBQUVqRCxTQUFTLEVBQUVDLFdBQVcsRUFBRTBHLFdBQVcsRUFBRXpHLGdCQUFnQixFQUFHO0lBQ2xSLE1BQU0sQ0FBQ0wsTUFBTUMsUUFBUUMsT0FBTyxHQUFHbUcsa0JBQWtCO1FBQzdDL0U7UUFDQUM7UUFDQTBCO1FBQ0F6QjtRQUNBQztRQUNBMEI7UUFDQW1ELGNBQWNRLGFBQWFSO1FBQzNCdEMsUUFBUThDLGFBQWE5QztJQUN6QjtJQUNBLHFCQUFRclAsZ0RBQW1CLENBQUNvTCxVQUFVO1FBQUVDLE1BQU1BO1FBQU1DLFFBQVFBO1FBQVFDLFFBQVFBO1FBQVEzRyxPQUFPQTtRQUFPQyxZQUFZQTtRQUFZQyxhQUFhQTtRQUFhQyxjQUFjQTtRQUFjQyxnQkFBZ0JBO1FBQWdCQyxxQkFBcUJBO1FBQXFCcEIsT0FBT0E7UUFBTzJILFdBQVdBO1FBQVdDLGFBQWFBO1FBQWFDLGtCQUFrQkE7SUFBaUI7QUFDL1Y7QUFDQXdHLGVBQWVsRyxXQUFXLEdBQUc7QUFFN0IsTUFBTW9HLHlCQUFXaFMsMkNBQUlBLENBQUMsQ0FBQ2lTLHNCQUFXclMsZ0RBQW1CLENBQUNrUyxnQkFBZ0I7UUFBRSxHQUFHRyxLQUFLO1FBQUVGLGFBQWFoUyw4Q0FBT0EsQ0FBQyxJQUFPO2dCQUFFd1IsY0FBYztnQkFBR3RDLFFBQVFnRCxNQUFNRixXQUFXLEVBQUU5QztZQUFPLElBQUk7WUFBQ2dELE1BQU1GLFdBQVcsRUFBRTlDO1NBQU87SUFBRTtBQUNwTStDLFNBQVNwRyxXQUFXLEdBQUc7QUFFdkIsU0FBU3NHLGdCQUFnQixFQUFFM0YsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFHO0lBQzVELE1BQU0sQ0FBQ3hCLFFBQVFDLFFBQVFpQyxTQUFTQyxRQUFRLEdBQUdmLGNBQWM7UUFDckRDO1FBQ0FDO1FBQ0FDO1FBQ0FDO0lBQ0o7SUFDQSxPQUFPO1FBQUMsQ0FBQyxFQUFFLEVBQUVILFFBQVEsQ0FBQyxFQUFFQyxRQUFRLEVBQUUsRUFBRUMsUUFBUSxDQUFDLEVBQUVDLFFBQVEsQ0FBQztRQUFFeEI7UUFBUUM7UUFBUWlDO1FBQVNDO0tBQVE7QUFDL0Y7QUFDQSxNQUFNOEUsNkJBQWVuUywyQ0FBSUEsQ0FBQyxDQUFDLEVBQUV1TSxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVsSSxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUVDLGNBQWMsRUFBRUMsbUJBQW1CLEVBQUVwQixLQUFLLEVBQUUySCxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsZ0JBQWdCLEVBQUc7SUFDbE0sTUFBTSxDQUFDTCxNQUFNQyxRQUFRQyxPQUFPLEdBQUcrRyxnQkFBZ0I7UUFBRTNGO1FBQVNDO1FBQVNDO1FBQVNDO0lBQVE7SUFDcEYscUJBQVE5TSxnREFBbUIsQ0FBQ29MLFVBQVU7UUFBRUMsTUFBTUE7UUFBTUMsUUFBUUE7UUFBUUMsUUFBUUE7UUFBUTNHLE9BQU9BO1FBQU9DLFlBQVlBO1FBQVlDLGFBQWFBO1FBQWFDLGNBQWNBO1FBQWNDLGdCQUFnQkE7UUFBZ0JDLHFCQUFxQkE7UUFBcUJwQixPQUFPQTtRQUFPMkgsV0FBV0E7UUFBV0MsYUFBYUE7UUFBYUMsa0JBQWtCQTtJQUFpQjtBQUMvVjtBQUNBNkcsYUFBYXZHLFdBQVcsR0FBRztBQUUzQixTQUFTd0csdUJBQXVCMUQsUUFBUSxFQUFFMkQsU0FBUztJQUMvQyxJQUFJM0QsWUFBWSxHQUFHO1FBQ2YsT0FBTyxNQUFNQTtJQUNqQjtJQUNBLE9BQU8yRCxZQUFZLEtBQUsvTCxLQUFLdUksSUFBSSxDQUFDLENBQUNIO0FBQ3ZDO0FBQ0EsU0FBUzRELHdCQUF3QixFQUFFekwsR0FBRyxFQUFFZ0gsRUFBRSxFQUFFQyxFQUFFLEVBQUVyRyxFQUFFLEVBQUVDLEVBQUUsRUFBRXVKLENBQUMsRUFBRTtJQUN2RCxPQUFRcEs7UUFDSixLQUFLOEcsU0FBU0ksSUFBSTtZQUNkLE9BQU87Z0JBQUNGLEtBQUt1RSx1QkFBdUJ2RSxLQUFLcEcsSUFBSXdKO2dCQUFJbkQ7YUFBRztRQUN4RCxLQUFLSCxTQUFTSyxLQUFLO1lBQ2YsT0FBTztnQkFBQ0gsS0FBS3VFLHVCQUF1QjNLLEtBQUtvRyxJQUFJb0Q7Z0JBQUluRDthQUFHO1FBQ3hELEtBQUtILFNBQVNVLEdBQUc7WUFDYixPQUFPO2dCQUFDUjtnQkFBSUMsS0FBS3NFLHVCQUF1QnRFLEtBQUtwRyxJQUFJdUo7YUFBRztRQUN4RCxLQUFLdEQsU0FBU1EsTUFBTTtZQUNoQixPQUFPO2dCQUFDTjtnQkFBSUMsS0FBS3NFLHVCQUF1QjFLLEtBQUtvRyxJQUFJbUQ7YUFBRztJQUM1RDtBQUNKO0FBQ0EsU0FBU3NCLGNBQWMsRUFBRWhHLE9BQU8sRUFBRUMsT0FBTyxFQUFFMEIsaUJBQWlCUCxTQUFTUSxNQUFNLEVBQUUxQixPQUFPLEVBQUVDLE9BQU8sRUFBRTBCLGlCQUFpQlQsU0FBU1UsR0FBRyxFQUFFZ0UsWUFBWSxJQUFJLEVBQUc7SUFDN0ksTUFBTSxDQUFDckYsZ0JBQWdCQyxlQUFlLEdBQUdxRix3QkFBd0I7UUFDN0R6TCxLQUFLcUg7UUFDTEwsSUFBSXRCO1FBQ0p1QixJQUFJdEI7UUFDSi9FLElBQUlnRjtRQUNKL0UsSUFBSWdGO1FBQ0p1RSxHQUFHb0I7SUFDUDtJQUNBLE1BQU0sQ0FBQ25GLGdCQUFnQkMsZUFBZSxHQUFHbUYsd0JBQXdCO1FBQzdEekwsS0FBS3VIO1FBQ0xQLElBQUlwQjtRQUNKcUIsSUFBSXBCO1FBQ0pqRixJQUFJOEU7UUFDSjdFLElBQUk4RTtRQUNKeUUsR0FBR29CO0lBQ1A7SUFDQSxNQUFNLENBQUNuSCxRQUFRQyxRQUFRaUMsU0FBU0MsUUFBUSxHQUFHTixvQkFBb0I7UUFDM0RSO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FNO1FBQ0FDO1FBQ0FDO1FBQ0FDO0lBQ0o7SUFDQSxPQUFPO1FBQ0gsQ0FBQyxDQUFDLEVBQUVaLFFBQVEsQ0FBQyxFQUFFQyxRQUFRLEVBQUUsRUFBRVEsZUFBZSxDQUFDLEVBQUVDLGVBQWUsQ0FBQyxFQUFFQyxlQUFlLENBQUMsRUFBRUMsZUFBZSxDQUFDLEVBQUVWLFFBQVEsQ0FBQyxFQUFFQyxRQUFRLENBQUM7UUFDdkh4QjtRQUNBQztRQUNBaUM7UUFDQUM7S0FDSDtBQUNMO0FBQ0EsTUFBTW1GLDJCQUFheFMsMkNBQUlBLENBQUMsQ0FBQyxFQUFFdU0sT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFd0IsaUJBQWlCUCxTQUFTUSxNQUFNLEVBQUVDLGlCQUFpQlQsU0FBU1UsR0FBRyxFQUFFN0osS0FBSyxFQUFFQyxVQUFVLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFQyxjQUFjLEVBQUVDLG1CQUFtQixFQUFFcEIsS0FBSyxFQUFFMkgsU0FBUyxFQUFFQyxXQUFXLEVBQUUwRyxXQUFXLEVBQUV6RyxnQkFBZ0IsRUFBRztJQUM5USxNQUFNLENBQUNMLE1BQU1DLFFBQVFDLE9BQU8sR0FBR29ILGNBQWM7UUFDekNoRztRQUNBQztRQUNBMEI7UUFDQXpCO1FBQ0FDO1FBQ0EwQjtRQUNBaUUsV0FBV04sYUFBYU07SUFDNUI7SUFDQSxxQkFBUXpTLGdEQUFtQixDQUFDb0wsVUFBVTtRQUFFQyxNQUFNQTtRQUFNQyxRQUFRQTtRQUFRQyxRQUFRQTtRQUFRM0csT0FBT0E7UUFBT0MsWUFBWUE7UUFBWUMsYUFBYUE7UUFBYUMsY0FBY0E7UUFBY0MsZ0JBQWdCQTtRQUFnQkMscUJBQXFCQTtRQUFxQnBCLE9BQU9BO1FBQU8ySCxXQUFXQTtRQUFXQyxhQUFhQTtRQUFhQyxrQkFBa0JBO0lBQWlCO0FBQy9WO0FBQ0FrSCxXQUFXNUcsV0FBVyxHQUFHO0FBRXpCLE1BQU02Ryw4QkFBZ0I1UyxvREFBYUEsQ0FBQztBQUNwQyxNQUFNcUIsV0FBV3VSLGNBQWN2UixRQUFRO0FBQ3ZDdVIsY0FBY0MsUUFBUTtBQUN0QixNQUFNQyxZQUFZO0lBQ2QsTUFBTUMsU0FBUzlTLGlEQUFVQSxDQUFDMlM7SUFDMUIsT0FBT0c7QUFDWDtBQUVBLE1BQU1DLFNBQVMsQ0FBQzNMLFVBQVksUUFBUUEsV0FBVyxZQUFZQSxXQUFXLFlBQVlBO0FBQ2xGLE1BQU00TCxTQUFTLENBQUM1TCxVQUFZLFFBQVFBLFdBQVcsQ0FBRSxhQUFZQSxPQUFNLEtBQU0sQ0FBRSxhQUFZQSxPQUFNO0FBQzdGLE1BQU02TCxjQUFjLENBQUNoTixNQUFNaU4sT0FBTzdHO0lBQzlCLElBQUksQ0FBQzJHLE9BQU8vTSxPQUFPO1FBQ2YsT0FBTyxFQUFFO0lBQ2I7SUFDQSxNQUFNa04sYUFBYTlHLE1BQU0rRyxNQUFNLENBQUMsQ0FBQzdHLElBQU1BLEVBQUVvQyxNQUFNLEtBQUsxSSxLQUFLbkUsRUFBRSxFQUFFdVIsR0FBRyxDQUFDLENBQUM5RyxJQUFNQSxFQUFFbEksTUFBTTtJQUNoRixPQUFPNk8sTUFBTUUsTUFBTSxDQUFDLENBQUN2SyxJQUFNc0ssV0FBV25KLFFBQVEsQ0FBQ25CLEVBQUUvRyxFQUFFO0FBQ3ZEO0FBQ0EsTUFBTXdSLGNBQWMsQ0FBQ3JOLE1BQU1pTixPQUFPN0c7SUFDOUIsSUFBSSxDQUFDMkcsT0FBTy9NLE9BQU87UUFDZixPQUFPLEVBQUU7SUFDYjtJQUNBLE1BQU1zTixjQUFjbEgsTUFBTStHLE1BQU0sQ0FBQyxDQUFDN0csSUFBTUEsRUFBRWxJLE1BQU0sS0FBSzRCLEtBQUtuRSxFQUFFLEVBQUV1UixHQUFHLENBQUMsQ0FBQzlHLElBQU1BLEVBQUVvQyxNQUFNO0lBQ2pGLE9BQU91RSxNQUFNRSxNQUFNLENBQUMsQ0FBQ3ZLLElBQU0wSyxZQUFZdkosUUFBUSxDQUFDbkIsRUFBRS9HLEVBQUU7QUFDeEQ7QUFDQSxNQUFNMFIsWUFBWSxDQUFDLEVBQUU3RSxNQUFNLEVBQUV6TSxZQUFZLEVBQUVtQyxNQUFNLEVBQUVqQyxZQUFZLEVBQUUsR0FBSyxDQUFDLGdCQUFnQixFQUFFdU0sT0FBTyxFQUFFek0sZ0JBQWdCLEdBQUcsQ0FBQyxFQUFFbUMsT0FBTyxFQUFFakMsZ0JBQWdCLEdBQUcsQ0FBQztBQUNySixNQUFNcVIsY0FBYyxDQUFDQyxRQUFRQztJQUN6QixJQUFJLE9BQU9ELFdBQVcsYUFBYTtRQUMvQixPQUFPO0lBQ1g7SUFDQSxJQUFJLE9BQU9BLFdBQVcsVUFBVTtRQUM1QixPQUFPQTtJQUNYO0lBQ0EsTUFBTUUsV0FBV0QsT0FBTyxDQUFDLEVBQUVBLEtBQUssRUFBRSxDQUFDLEdBQUc7SUFDdEMsT0FBTyxDQUFDLEVBQUVDLFNBQVMsRUFBRUMsT0FBT0MsSUFBSSxDQUFDSixRQUM1QkssSUFBSSxHQUNKVixHQUFHLENBQUMsQ0FBQ1csTUFBUSxDQUFDLEVBQUVBLElBQUksQ0FBQyxFQUFFTixNQUFNLENBQUNNLElBQUksQ0FBQyxDQUFDLEVBQ3BDQyxJQUFJLENBQUMsS0FBSyxDQUFDO0FBQ3BCO0FBQ0EsTUFBTUMsbUJBQW1CLENBQUMvUixNQUFNa0s7SUFDNUIsT0FBT0EsTUFBTThILElBQUksQ0FBQyxDQUFDQyxLQUFPQSxHQUFHekYsTUFBTSxLQUFLeE0sS0FBS3dNLE1BQU0sSUFDL0N5RixHQUFHL1AsTUFBTSxLQUFLbEMsS0FBS2tDLE1BQU0sSUFDeEIrUCxDQUFBQSxHQUFHbFMsWUFBWSxLQUFLQyxLQUFLRCxZQUFZLElBQUssQ0FBQ2tTLEdBQUdsUyxZQUFZLElBQUksQ0FBQ0MsS0FBS0QsWUFBWSxLQUNoRmtTLENBQUFBLEdBQUdoUyxZQUFZLEtBQUtELEtBQUtDLFlBQVksSUFBSyxDQUFDZ1MsR0FBR2hTLFlBQVksSUFBSSxDQUFDRCxLQUFLQyxZQUFZO0FBQ3pGO0FBQ0EsTUFBTWlTLFVBQVUsQ0FBQ0MsWUFBWWpJO0lBQ3pCLElBQUksQ0FBQ2lJLFdBQVczRixNQUFNLElBQUksQ0FBQzJGLFdBQVdqUSxNQUFNLEVBQUU7UUFDMUMrRSxRQUFRLE9BQU8vSCxhQUFhLENBQUMsV0FBVztRQUN4QyxPQUFPZ0w7SUFDWDtJQUNBLElBQUlsSztJQUNKLElBQUk0USxPQUFPdUIsYUFBYTtRQUNwQm5TLE9BQU87WUFBRSxHQUFHbVMsVUFBVTtRQUFDO0lBQzNCLE9BQ0s7UUFDRG5TLE9BQU87WUFDSCxHQUFHbVMsVUFBVTtZQUNieFMsSUFBSTBSLFVBQVVjO1FBQ2xCO0lBQ0o7SUFDQSxJQUFJSixpQkFBaUIvUixNQUFNa0ssUUFBUTtRQUMvQixPQUFPQTtJQUNYO0lBQ0EsT0FBT0EsTUFBTWtJLE1BQU0sQ0FBQ3BTO0FBQ3hCO0FBQ0EsTUFBTXFTLGFBQWEsQ0FBQ0MsU0FBU0MsZUFBZXJJLE9BQU9zSSxVQUFVO0lBQUVDLGlCQUFpQjtBQUFLLENBQUM7SUFDbEYsTUFBTSxFQUFFOVMsSUFBSStTLFNBQVMsRUFBRSxHQUFHalIsTUFBTSxHQUFHNlE7SUFDbkMsSUFBSSxDQUFDQyxjQUFjL0YsTUFBTSxJQUFJLENBQUMrRixjQUFjclEsTUFBTSxFQUFFO1FBQ2hEK0UsUUFBUSxPQUFPL0gsYUFBYSxDQUFDLFdBQVc7UUFDeEMsT0FBT2dMO0lBQ1g7SUFDQSxNQUFNeUksWUFBWXpJLE1BQU1DLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxFQUFFekssRUFBRSxLQUFLK1M7SUFDN0MsSUFBSSxDQUFDQyxXQUFXO1FBQ1oxTCxRQUFRLE9BQU8vSCxhQUFhLENBQUMsV0FBVyxDQUFDd1Q7UUFDekMsT0FBT3hJO0lBQ1g7SUFDQSx1RUFBdUU7SUFDdkUsTUFBTWxLLE9BQU87UUFDVCxHQUFHeUIsSUFBSTtRQUNQOUIsSUFBSTZTLFFBQVFDLGVBQWUsR0FBR3BCLFVBQVVrQixpQkFBaUJHO1FBQ3pEbEcsUUFBUStGLGNBQWMvRixNQUFNO1FBQzVCdEssUUFBUXFRLGNBQWNyUSxNQUFNO1FBQzVCbkMsY0FBY3dTLGNBQWN4UyxZQUFZO1FBQ3hDRSxjQUFjc1MsY0FBY3RTLFlBQVk7SUFDNUM7SUFDQSxPQUFPaUssTUFBTStHLE1BQU0sQ0FBQyxDQUFDN0csSUFBTUEsRUFBRXpLLEVBQUUsS0FBSytTLFdBQVdOLE1BQU0sQ0FBQ3BTO0FBQzFEO0FBQ0EsTUFBTTRTLHVCQUF1QixDQUFDLEVBQUV2USxDQUFDLEVBQUVDLENBQUMsRUFBRSxFQUFFLENBQUN1USxJQUFJQyxJQUFJQyxPQUFPLEVBQUVDLFlBQVksQ0FBQ0MsT0FBT0MsTUFBTTtJQUNoRixNQUFNN1IsV0FBVztRQUNiZ0IsR0FBRyxDQUFDQSxJQUFJd1EsRUFBQyxJQUFLRTtRQUNkelEsR0FBRyxDQUFDQSxJQUFJd1EsRUFBQyxJQUFLQztJQUNsQjtJQUNBLElBQUlDLFlBQVk7UUFDWixPQUFPO1lBQ0gzUSxHQUFHNFEsUUFBUTVPLEtBQUs4TyxLQUFLLENBQUM5UixTQUFTZ0IsQ0FBQyxHQUFHNFE7WUFDbkMzUSxHQUFHNFEsUUFBUTdPLEtBQUs4TyxLQUFLLENBQUM5UixTQUFTaUIsQ0FBQyxHQUFHNFE7UUFDdkM7SUFDSjtJQUNBLE9BQU83UjtBQUNYO0FBQ0EsTUFBTStSLHVCQUF1QixDQUFDLEVBQUUvUSxDQUFDLEVBQUVDLENBQUMsRUFBRSxFQUFFLENBQUN1USxJQUFJQyxJQUFJQyxPQUFPO0lBQ3BELE9BQU87UUFDSDFRLEdBQUdBLElBQUkwUSxTQUFTRjtRQUNoQnZRLEdBQUdBLElBQUl5USxTQUFTRDtJQUNwQjtBQUNKO0FBQ0EsTUFBTU8sNEJBQTRCLENBQUN2UCxNQUFNd1AsYUFBYTtJQUFDO0lBQUc7Q0FBRTtJQUN4RCxJQUFJLENBQUN4UCxNQUFNO1FBQ1AsT0FBTztZQUNIekIsR0FBRztZQUNIQyxHQUFHO1lBQ0h1RCxrQkFBa0I7Z0JBQ2R4RCxHQUFHO2dCQUNIQyxHQUFHO1lBQ1A7UUFDSjtJQUNKO0lBQ0EsTUFBTTZJLFVBQVUsQ0FBQ3JILEtBQUtkLEtBQUssSUFBSSxLQUFLc1EsVUFBVSxDQUFDLEVBQUU7SUFDakQsTUFBTWxJLFVBQVUsQ0FBQ3RILEtBQUtiLE1BQU0sSUFBSSxLQUFLcVEsVUFBVSxDQUFDLEVBQUU7SUFDbEQsTUFBTWpTLFdBQVc7UUFDYmdCLEdBQUd5QixLQUFLekMsUUFBUSxDQUFDZ0IsQ0FBQyxHQUFHOEk7UUFDckI3SSxHQUFHd0IsS0FBS3pDLFFBQVEsQ0FBQ2lCLENBQUMsR0FBRzhJO0lBQ3pCO0lBQ0EsT0FBTztRQUNILEdBQUcvSixRQUFRO1FBQ1h3RSxrQkFBa0IvQixLQUFLK0IsZ0JBQWdCLEdBQ2pDO1lBQ0V4RCxHQUFHeUIsS0FBSytCLGdCQUFnQixDQUFDeEQsQ0FBQyxHQUFHOEk7WUFDN0I3SSxHQUFHd0IsS0FBSytCLGdCQUFnQixDQUFDdkQsQ0FBQyxHQUFHOEk7UUFDakMsSUFDRS9KO0lBQ1Y7QUFDSjtBQUNBLE1BQU1rUyxpQkFBaUIsQ0FBQ3hDLE9BQU91QyxhQUFhO0lBQUM7SUFBRztDQUFFO0lBQzlDLElBQUl2QyxNQUFNbkIsTUFBTSxLQUFLLEdBQUc7UUFDcEIsT0FBTztZQUFFdk4sR0FBRztZQUFHQyxHQUFHO1lBQUdVLE9BQU87WUFBR0MsUUFBUTtRQUFFO0lBQzdDO0lBQ0EsTUFBTXVRLE1BQU16QyxNQUFNeEIsTUFBTSxDQUFDLENBQUNrRSxTQUFTM1A7UUFDL0IsTUFBTSxFQUFFekIsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBRytRLDBCQUEwQnZQLE1BQU13UCxZQUFZek4sZ0JBQWdCO1FBQzdFLE9BQU9SLGlCQUFpQm9PLFNBQVMvTixVQUFVO1lBQ3ZDckQ7WUFDQUM7WUFDQVUsT0FBT2MsS0FBS2QsS0FBSyxJQUFJO1lBQ3JCQyxRQUFRYSxLQUFLYixNQUFNLElBQUk7UUFDM0I7SUFDSixHQUFHO1FBQUVaLEdBQUdxUjtRQUFVcFIsR0FBR29SO1FBQVVsTyxJQUFJLENBQUNrTztRQUFVak8sSUFBSSxDQUFDaU87SUFBUztJQUM1RCxPQUFPL04sVUFBVTZOO0FBQ3JCO0FBQ0Esb0NBQW9DO0FBQ3BDLE1BQU1HLGlCQUFpQixDQUFDNUMsT0FBT3VDLGFBQWE7SUFBQztJQUFHO0NBQUU7SUFDOUNsTSxRQUFRQyxJQUFJLENBQUM7SUFDYixPQUFPa00sZUFBZXhDLE9BQU91QztBQUNqQztBQUNBLE1BQU1NLGlCQUFpQixDQUFDQyxlQUFlQyxNQUFNLENBQUNqQixJQUFJQyxJQUFJQyxPQUFPLEdBQUc7SUFBQztJQUFHO0lBQUc7Q0FBRSxFQUFFZ0IsWUFBWSxLQUFLLEVBQzVGLGlHQUFpRztBQUNqR0MsNEJBQTRCLEtBQUssRUFBRVYsYUFBYTtJQUFDO0lBQUc7Q0FBRTtJQUNsRCxNQUFNVyxXQUFXO1FBQ2I1UixHQUFHLENBQUN5UixLQUFLelIsQ0FBQyxHQUFHd1EsRUFBQyxJQUFLRTtRQUNuQnpRLEdBQUcsQ0FBQ3dSLEtBQUt4UixDQUFDLEdBQUd3USxFQUFDLElBQUtDO1FBQ25CL1AsT0FBTzhRLEtBQUs5USxLQUFLLEdBQUcrUDtRQUNwQjlQLFFBQVE2USxLQUFLN1EsTUFBTSxHQUFHOFA7SUFDMUI7SUFDQSxNQUFNbUIsZUFBZSxFQUFFO0lBQ3ZCTCxjQUFjTSxPQUFPLENBQUMsQ0FBQ3JRO1FBQ25CLE1BQU0sRUFBRWQsS0FBSyxFQUFFQyxNQUFNLEVBQUVtUixhQUFhLElBQUksRUFBRUMsU0FBUyxLQUFLLEVBQUUsR0FBR3ZRO1FBQzdELElBQUksNkJBQThCLENBQUNzUSxjQUFlQyxRQUFRO1lBQ3RELE9BQU87UUFDWDtRQUNBLE1BQU0sRUFBRXhPLGdCQUFnQixFQUFFLEdBQUd3TiwwQkFBMEJ2UCxNQUFNd1A7UUFDN0QsTUFBTWdCLFdBQVc7WUFDYmpTLEdBQUd3RCxpQkFBaUJ4RCxDQUFDO1lBQ3JCQyxHQUFHdUQsaUJBQWlCdkQsQ0FBQztZQUNyQlUsT0FBT0EsU0FBUztZQUNoQkMsUUFBUUEsVUFBVTtRQUN0QjtRQUNBLE1BQU1zUixrQkFBa0J0TyxtQkFBbUJnTyxVQUFVSztRQUNyRCxNQUFNRSxpQkFBaUIsT0FBT3hSLFVBQVUsZUFBZSxPQUFPQyxXQUFXLGVBQWVELFVBQVUsUUFBUUMsV0FBVztRQUNySCxNQUFNd1IsbUJBQW1CVixhQUFhUSxrQkFBa0I7UUFDeEQsTUFBTUcsT0FBTyxDQUFDMVIsU0FBUyxLQUFNQyxDQUFBQSxVQUFVO1FBQ3ZDLE1BQU0wUixZQUFZSCxrQkFBa0JDLG9CQUFvQkYsbUJBQW1CRztRQUMzRSxJQUFJQyxhQUFhN1EsS0FBSzhRLFFBQVEsRUFBRTtZQUM1QlYsYUFBYVcsSUFBSSxDQUFDL1E7UUFDdEI7SUFDSjtJQUNBLE9BQU9vUTtBQUNYO0FBQ0EsTUFBTVksb0JBQW9CLENBQUMvRCxPQUFPN0c7SUFDOUIsTUFBTTZLLFVBQVVoRSxNQUFNRyxHQUFHLENBQUMsQ0FBQ3BOLE9BQVNBLEtBQUtuRSxFQUFFO0lBQzNDLE9BQU91SyxNQUFNK0csTUFBTSxDQUFDLENBQUNqUixPQUFTK1UsUUFBUWxOLFFBQVEsQ0FBQzdILEtBQUt3TSxNQUFNLEtBQUt1SSxRQUFRbE4sUUFBUSxDQUFDN0gsS0FBS2tDLE1BQU07QUFDL0Y7QUFDQSwwQ0FBMEM7QUFDMUMsTUFBTThTLHdCQUF3QixDQUFDblEsUUFBUTdCLE9BQU9DLFFBQVFnUyxTQUFTQyxTQUFTQyxVQUFVLEdBQUc7SUFDakYsTUFBTSxFQUFFOVMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU1RCxJQUFJLEVBQUUsR0FBRzBXLHFCQUFxQnZRLFFBQVE3QixPQUFPQyxRQUFRZ1MsU0FBU0MsU0FBU0M7SUFDckYvTixRQUFRQyxJQUFJLENBQUM7SUFDYixPQUFPO1FBQUNoRjtRQUFHQztRQUFHNUQ7S0FBSztBQUN2QjtBQUNBLE1BQU0wVyx1QkFBdUIsQ0FBQ3ZRLFFBQVE3QixPQUFPQyxRQUFRZ1MsU0FBU0MsU0FBU0MsVUFBVSxHQUFHO0lBQ2hGLE1BQU1FLFFBQVFyUyxRQUFTNkIsQ0FBQUEsT0FBTzdCLEtBQUssR0FBSSxLQUFJbVMsT0FBTSxDQUFDO0lBQ2xELE1BQU1HLFFBQVFyUyxTQUFVNEIsQ0FBQUEsT0FBTzVCLE1BQU0sR0FBSSxLQUFJa1MsT0FBTSxDQUFDO0lBQ3BELE1BQU16VyxPQUFPMkYsS0FBS0YsR0FBRyxDQUFDa1IsT0FBT0M7SUFDN0IsTUFBTUMsY0FBY3RSLE1BQU12RixNQUFNdVcsU0FBU0M7SUFDekMsTUFBTU0sZ0JBQWdCM1EsT0FBT3hDLENBQUMsR0FBR3dDLE9BQU83QixLQUFLLEdBQUc7SUFDaEQsTUFBTXlTLGdCQUFnQjVRLE9BQU92QyxDQUFDLEdBQUd1QyxPQUFPNUIsTUFBTSxHQUFHO0lBQ2pELE1BQU1aLElBQUlXLFFBQVEsSUFBSXdTLGdCQUFnQkQ7SUFDdEMsTUFBTWpULElBQUlXLFNBQVMsSUFBSXdTLGdCQUFnQkY7SUFDdkMsT0FBTztRQUFFbFQ7UUFBR0M7UUFBRzVELE1BQU02VztJQUFZO0FBQ3JDO0FBQ0EsTUFBTUcsa0JBQWtCLENBQUNDLFdBQVdDLFdBQVcsQ0FBQztJQUM1QyxPQUFPRCxVQUFVRSxVQUFVLEdBQUdELFFBQVEsQ0FBQ0E7QUFDM0M7QUFFQSxvRUFBb0U7QUFDcEUscUVBQXFFO0FBQ3JFLFNBQVNFLFdBQVdoUyxJQUFJLEVBQUVpUyxZQUFZLEVBQUVsVyxJQUFJLEVBQUVtVyxhQUFhO0lBQ3ZELE9BQU8sQ0FBQ0QsWUFBWSxDQUFDbFcsS0FBSyxJQUFJLEVBQUUsRUFBRTBQLE1BQU0sQ0FBQyxDQUFDQyxLQUFLeUc7UUFDM0MsSUFBSSxDQUFDLEVBQUVuUyxLQUFLbkUsRUFBRSxDQUFDLENBQUMsRUFBRXNXLEVBQUV0VyxFQUFFLENBQUMsQ0FBQyxFQUFFRSxLQUFLLENBQUMsS0FBS21XLGVBQWU7WUFDaER4RyxJQUFJcUYsSUFBSSxDQUFDO2dCQUNMbFYsSUFBSXNXLEVBQUV0VyxFQUFFLElBQUk7Z0JBQ1pFO2dCQUNBOFEsUUFBUTdNLEtBQUtuRSxFQUFFO2dCQUNmMEMsR0FBRyxDQUFDeUIsS0FBSytCLGdCQUFnQixFQUFFeEQsS0FBSyxLQUFLNFQsRUFBRTVULENBQUMsR0FBRzRULEVBQUVqVCxLQUFLLEdBQUc7Z0JBQ3JEVixHQUFHLENBQUN3QixLQUFLK0IsZ0JBQWdCLEVBQUV2RCxLQUFLLEtBQUsyVCxFQUFFM1QsQ0FBQyxHQUFHMlQsRUFBRWhULE1BQU0sR0FBRztZQUMxRDtRQUNKO1FBQ0EsT0FBT3VNO0lBQ1gsR0FBRyxFQUFFO0FBQ1Q7QUFDQSxTQUFTMEcsaUJBQWlCM08sS0FBSyxFQUFFNE8sR0FBRyxFQUFFdlIsR0FBRyxFQUFFd1IsZ0JBQWdCLEVBQUVDLE9BQU8sRUFBRUMsU0FBUztJQUMzRSxtR0FBbUc7SUFDbkcsd0hBQXdIO0lBQ3hILE1BQU0sRUFBRWpVLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUc0RixpQkFBaUJYO0lBQ2xDLE1BQU1nUCxXQUFXSixJQUFJSyxpQkFBaUIsQ0FBQ25VLEdBQUdDO0lBQzFDLE1BQU1tVSxjQUFjRixTQUFTcE0sSUFBSSxDQUFDLENBQUM4SCxLQUFPQSxHQUFHeUUsU0FBUyxDQUFDQyxRQUFRLENBQUM7SUFDaEUsSUFBSUYsYUFBYTtRQUNiLE1BQU1HLGVBQWVILFlBQVlJLFlBQVksQ0FBQztRQUM5QyxJQUFJRCxjQUFjO1lBQ2QsTUFBTUUsYUFBYUMsY0FBYzlNLFdBQVd3TTtZQUM1QyxNQUFNTyxXQUFXUCxZQUFZSSxZQUFZLENBQUM7WUFDMUMsTUFBTUksb0JBQW9CWCxVQUFVO2dCQUFFM0YsUUFBUWlHO2dCQUFjalgsSUFBSXFYO2dCQUFVblgsTUFBTWlYO1lBQVc7WUFDM0YsSUFBSUcsbUJBQW1CO2dCQUNuQixNQUFNQyxTQUFTYixRQUFRbE0sSUFBSSxDQUFDLENBQUM4TCxJQUFNQSxFQUFFdEYsTUFBTSxLQUFLaUcsZ0JBQWdCWCxFQUFFcFcsSUFBSSxLQUFLaVgsY0FBY2IsRUFBRXRXLEVBQUUsS0FBS3FYO2dCQUNsRyxPQUFPO29CQUNIRSxRQUFRO3dCQUNKdlgsSUFBSXFYO3dCQUNKblgsTUFBTWlYO3dCQUNObkcsUUFBUWlHO3dCQUNSdlUsR0FBRzZVLFFBQVE3VSxLQUFLdUMsSUFBSXZDLENBQUM7d0JBQ3JCQyxHQUFHNFUsUUFBUTVVLEtBQUtzQyxJQUFJdEMsQ0FBQztvQkFDekI7b0JBQ0EyVTtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUNBLHFIQUFxSDtJQUNySCxJQUFJRSxpQkFBaUIsRUFBRTtJQUN2QixJQUFJQyxjQUFjMUQ7SUFDbEIyQyxRQUFRbEMsT0FBTyxDQUFDLENBQUMrQztRQUNiLE1BQU16SyxXQUFXcEksS0FBS3VJLElBQUksQ0FBQyxDQUFDc0ssT0FBTzdVLENBQUMsR0FBR3VDLElBQUl2QyxDQUFDLEtBQUssSUFBSSxDQUFDNlUsT0FBTzVVLENBQUMsR0FBR3NDLElBQUl0QyxDQUFDLEtBQUs7UUFDM0UsSUFBSW1LLFlBQVkySixrQkFBa0I7WUFDOUIsTUFBTWEsb0JBQW9CWCxVQUFVWTtZQUNwQyxJQUFJekssWUFBWTJLLGFBQWE7Z0JBQ3pCLElBQUkzSyxXQUFXMkssYUFBYTtvQkFDeEJELGlCQUFpQjt3QkFBQzs0QkFBRUQ7NEJBQVFEO3dCQUFrQjtxQkFBRTtnQkFDcEQsT0FDSyxJQUFJeEssYUFBYTJLLGFBQWE7b0JBQy9CLHdFQUF3RTtvQkFDeEVELGVBQWV0QyxJQUFJLENBQUM7d0JBQ2hCcUM7d0JBQ0FEO29CQUNKO2dCQUNKO2dCQUNBRyxjQUFjM0s7WUFDbEI7UUFDSjtJQUNKO0lBQ0EsSUFBSSxDQUFDMEssZUFBZXZILE1BQU0sRUFBRTtRQUN4QixPQUFPO1lBQUVzSCxRQUFRO1lBQU1ELG1CQUFtQkk7UUFBZ0I7SUFDOUQ7SUFDQSxJQUFJRixlQUFldkgsTUFBTSxLQUFLLEdBQUc7UUFDN0IsT0FBT3VILGNBQWMsQ0FBQyxFQUFFO0lBQzVCO0lBQ0EsTUFBTUcsaUJBQWlCSCxlQUFlbkYsSUFBSSxDQUFDLENBQUMsRUFBRWlGLGlCQUFpQixFQUFFLEdBQUtBLGtCQUFrQk0sT0FBTztJQUMvRixNQUFNQyxrQkFBa0JMLGVBQWVuRixJQUFJLENBQUMsQ0FBQyxFQUFFa0YsTUFBTSxFQUFFLEdBQUtBLE9BQU9yWCxJQUFJLEtBQUs7SUFDNUUsdUhBQXVIO0lBQ3ZILE9BQVFzWCxlQUFlaE4sSUFBSSxDQUFDLENBQUMsRUFBRStNLE1BQU0sRUFBRUQsaUJBQWlCLEVBQUUsR0FBS08sa0JBQWtCTixPQUFPclgsSUFBSSxLQUFLLFdBQVl5WCxpQkFBaUJMLGtCQUFrQk0sT0FBTyxHQUFHLFNBQVVKLGNBQWMsQ0FBQyxFQUFFO0FBQ3pMO0FBQ0EsTUFBTU0saUJBQWlCO0lBQUVqTCxRQUFRO0lBQU10SyxRQUFRO0lBQU1uQyxjQUFjO0lBQU1FLGNBQWM7QUFBSztBQUM1RixNQUFNb1gsZ0JBQWdCLElBQU87UUFDekJLLGVBQWU7UUFDZkgsU0FBUztRQUNUSSxZQUFZRjtRQUNaRyxXQUFXO0lBQ2Y7QUFDQSxxRkFBcUY7QUFDckYsU0FBU0MsY0FBY1gsTUFBTSxFQUFFWSxjQUFjLEVBQUVDLFVBQVUsRUFBRUMsWUFBWSxFQUFFQyxRQUFRLEVBQUVDLGlCQUFpQixFQUFFL0IsR0FBRztJQUNyRyxNQUFNZ0MsV0FBV0YsYUFBYTtJQUM5QixNQUFNRyxnQkFBZ0JqQyxJQUFJa0MsYUFBYSxDQUFDLENBQUMsNkJBQTZCLEVBQUVuQixRQUFRdkcsT0FBTyxDQUFDLEVBQUV1RyxRQUFRdlgsR0FBRyxDQUFDLEVBQUV1WCxRQUFRclgsS0FBSyxFQUFFLENBQUM7SUFDeEgsTUFBTXlZLFNBQVM7UUFDWCxHQUFHakIsZUFBZTtRQUNsQkssZUFBZVU7SUFDbkI7SUFDQSxJQUFJQSxlQUFlO1FBQ2YsTUFBTXRCLGFBQWFDLGNBQWM5TSxXQUFXbU87UUFDNUMsTUFBTXhCLGVBQWV3QixjQUFjdkIsWUFBWSxDQUFDO1FBQ2hELE1BQU1HLFdBQVdvQixjQUFjdkIsWUFBWSxDQUFDO1FBQzVDLE1BQU0wQixjQUFjSCxjQUFjMUIsU0FBUyxDQUFDQyxRQUFRLENBQUM7UUFDckQsTUFBTTZCLGlCQUFpQkosY0FBYzFCLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDO1FBQ3hELE1BQU1nQixhQUFhO1lBQ2ZuTCxRQUFRMkwsV0FBV3ZCLGVBQWVtQjtZQUNsQ2hZLGNBQWNvWSxXQUFXbkIsV0FBV2dCO1lBQ3BDOVYsUUFBUWlXLFdBQVdKLGFBQWFuQjtZQUNoQzNXLGNBQWNrWSxXQUFXSCxlQUFlaEI7UUFDNUM7UUFDQXNCLE9BQU9YLFVBQVUsR0FBR0E7UUFDcEIsTUFBTWMsZ0JBQWdCRixlQUFlQztRQUNyQyxpRkFBaUY7UUFDakYsTUFBTWpCLFVBQVVrQixpQkFDWFgsQ0FBQUEsbUJBQW1Cek0sZUFBZXFOLE1BQU0sR0FDbkMsWUFBYTVCLGVBQWUsWUFBYyxDQUFDcUIsWUFBWXJCLGVBQWUsV0FDdEVGLGlCQUFpQm1CLGNBQWNmLGFBQWFnQixZQUFXO1FBQ2pFLElBQUlULFNBQVM7WUFDVGUsT0FBT1YsU0FBUyxHQUFHO2dCQUNmakgsUUFBUWlHO2dCQUNSSTtnQkFDQW5YLE1BQU1pWDtZQUNWO1lBQ0F3QixPQUFPZixPQUFPLEdBQUdXLGtCQUFrQlA7UUFDdkM7SUFDSjtJQUNBLE9BQU9XO0FBQ1g7QUFDQSxTQUFTSyxnQkFBZ0IsRUFBRTVILEtBQUssRUFBRUosTUFBTSxFQUFFcUcsUUFBUSxFQUFFRixVQUFVLEVBQUU7SUFDNUQsT0FBTy9GLE1BQU14QixNQUFNLENBQUMsQ0FBQ0MsS0FBSzFMO1FBQ3RCLElBQUlBLElBQUksQ0FBQytDLGdCQUFnQixFQUFFO1lBQ3ZCLE1BQU0sRUFBRWtQLFlBQVksRUFBRSxHQUFHalMsSUFBSSxDQUFDK0MsZ0JBQWdCO1lBQzlDLElBQUkrUixnQkFBZ0IsRUFBRTtZQUN0QixJQUFJQyxnQkFBZ0IsRUFBRTtZQUN0QixJQUFJOUMsY0FBYztnQkFDZDZDLGdCQUFnQjlDLFdBQVdoUyxNQUFNaVMsY0FBYyxVQUFVLENBQUMsRUFBRXBGLE9BQU8sQ0FBQyxFQUFFcUcsU0FBUyxDQUFDLEVBQUVGLFdBQVcsQ0FBQztnQkFDOUYrQixnQkFBZ0IvQyxXQUFXaFMsTUFBTWlTLGNBQWMsVUFBVSxDQUFDLEVBQUVwRixPQUFPLENBQUMsRUFBRXFHLFNBQVMsQ0FBQyxFQUFFRixXQUFXLENBQUM7WUFDbEc7WUFDQXRILElBQUlxRixJQUFJLElBQUkrRCxrQkFBa0JDO1FBQ2xDO1FBQ0EsT0FBT3JKO0lBQ1gsR0FBRyxFQUFFO0FBQ1Q7QUFDQSxTQUFTdUgsY0FBYytCLGVBQWUsRUFBRXBCLGFBQWE7SUFDakQsSUFBSW9CLGlCQUFpQjtRQUNqQixPQUFPQTtJQUNYLE9BQ0ssSUFBSXBCLGVBQWVoQixVQUFVQyxTQUFTLFdBQVc7UUFDbEQsT0FBTztJQUNYLE9BQ0ssSUFBSWUsZUFBZWhCLFVBQVVDLFNBQVMsV0FBVztRQUNsRCxPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTb0Msa0JBQWtCckIsYUFBYTtJQUNwQ0EsZUFBZWhCLFVBQVVzQyxPQUFPLFNBQVMsY0FBYyw0QkFBNEI7QUFDdkY7QUFDQSxTQUFTQyxvQkFBb0JDLHdCQUF3QixFQUFFQyxhQUFhO0lBQ2hFLElBQUlDLG1CQUFtQjtJQUN2QixJQUFJRCxlQUFlO1FBQ2ZDLG1CQUFtQjtJQUN2QixPQUNLLElBQUlGLDRCQUE0QixDQUFDQyxlQUFlO1FBQ2pEQyxtQkFBbUI7SUFDdkI7SUFDQSxPQUFPQTtBQUNYO0FBRUEsU0FBU0Msa0JBQWtCLEVBQUU5UixLQUFLLEVBQUV5UCxRQUFRLEVBQUVyRyxNQUFNLEVBQUUySSxTQUFTLEVBQUVuQixRQUFRLEVBQUV0WCxRQUFRLEVBQUVDLFFBQVEsRUFBRW9YLGlCQUFpQixFQUFFWSxlQUFlLEVBQUVTLGVBQWUsRUFBRztJQUNqSixxRUFBcUU7SUFDckUsTUFBTXBELE1BQU1uUixrQkFBa0J1QyxNQUFNckYsTUFBTTtJQUMxQyxNQUFNLEVBQUU0VixjQUFjLEVBQUUwQixPQUFPLEVBQUVDLGdCQUFnQixFQUFFckQsZ0JBQWdCLEVBQUVzRCxjQUFjLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxnQkFBZ0IsRUFBRyxHQUFHaFo7SUFDNUgsSUFBSWlaLFlBQVk7SUFDaEIsSUFBSUM7SUFDSixNQUFNLEVBQUUxWCxDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHNEYsaUJBQWlCWDtJQUNsQyxNQUFNeVMsZ0JBQWdCN0QsS0FBSzhELGlCQUFpQjVYLEdBQUdDO0lBQy9DLE1BQU13VSxhQUFhQyxjQUFjK0IsaUJBQWlCa0I7SUFDbEQsTUFBTUUsa0JBQWtCVixTQUFTVztJQUNqQyxJQUFJLENBQUNELG1CQUFtQixDQUFDcEQsWUFBWTtRQUNqQztJQUNKO0lBQ0EsSUFBSXNEO0lBQ0osSUFBSUMscUJBQXFCblMsaUJBQWlCWCxPQUFPMlM7SUFDakQsSUFBSUksaUJBQWlCO0lBQ3JCLElBQUkzQyxhQUFhO0lBQ2pCLElBQUlKLFVBQVU7SUFDZCxJQUFJRyxnQkFBZ0I7SUFDcEIsTUFBTTZDLGVBQWU1QixnQkFBZ0I7UUFDakM1SCxPQUFPNkk7UUFDUGpKO1FBQ0FxRztRQUNBRjtJQUNKO0lBQ0Esd0dBQXdHO0lBQ3hHLE1BQU0wRCxVQUFVO1FBQ1osSUFBSSxDQUFDZixrQkFBa0I7WUFDbkI7UUFDSjtRQUNBLE1BQU0sQ0FBQzNVLFdBQVdDLFVBQVUsR0FBR0osWUFBWTBWLG9CQUFvQkg7UUFDL0RQLE1BQU07WUFBRXRYLEdBQUd5QztZQUFXeEMsR0FBR3lDO1FBQVU7UUFDbkMrVSxZQUFZVyxzQkFBc0JEO0lBQ3RDO0lBQ0ExWixTQUFTO1FBQ0x1WjtRQUNBakIsa0JBQWtCO1FBQ2xCLDJGQUEyRjtRQUMzRnNCLGtCQUFrQi9KO1FBQ2xCZ0ssb0JBQW9CM0Q7UUFDcEI0RCxzQkFBc0I5RDtRQUN0QitELHVCQUF1QjtZQUNuQmxLO1lBQ0FxRztZQUNBblgsTUFBTWlYO1FBQ1Y7UUFDQWdFLHFCQUFxQjtJQUN6QjtJQUNBcEIsaUJBQWlCblMsT0FBTztRQUFFb0o7UUFBUXFHO1FBQVVGO0lBQVc7SUFDdkQsU0FBU2lFLGNBQWN4VCxLQUFLO1FBQ3hCLE1BQU0sRUFBRWpFLFNBQVMsRUFBRSxHQUFHekM7UUFDdEJ3WixxQkFBcUJuUyxpQkFBaUJYLE9BQU8yUztRQUM3QyxNQUFNLEVBQUVoRCxNQUFNLEVBQUVELGlCQUFpQixFQUFFLEdBQUdmLGlCQUFpQjNPLE9BQU80TyxLQUFLdkQscUJBQXFCeUgsb0JBQW9CL1csV0FBVyxPQUFPO1lBQUM7WUFBRztTQUFFLEdBQUc4UyxrQkFBa0JtRSxjQUFjLENBQUNyRCxTQUFXVyxjQUFjWCxRQUFRWSxnQkFBZ0JuSCxRQUFRcUcsVUFBVW1CLFdBQVcsV0FBVyxVQUFVRCxtQkFBbUIvQjtRQUM5UjRELGdCQUFnQjdDO1FBQ2hCLElBQUksQ0FBQ29ELGdCQUFnQjtZQUNqQkU7WUFDQUYsaUJBQWlCO1FBQ3JCO1FBQ0E1QyxnQkFBZ0JULGtCQUFrQlMsYUFBYTtRQUMvQ0MsYUFBYVYsa0JBQWtCVSxVQUFVO1FBQ3pDSixVQUFVTixrQkFBa0JNLE9BQU87UUFDbkN6VyxTQUFTO1lBQ0x1WixvQkFBb0JOLGlCQUFpQnhDLFVBQy9CbkUscUJBQXFCO2dCQUNuQi9RLEdBQUcwWCxjQUFjMVgsQ0FBQztnQkFDbEJDLEdBQUd5WCxjQUFjelgsQ0FBQztZQUN0QixHQUFHZ0IsYUFDRCtXO1lBQ05qQixrQkFBa0JILG9CQUFvQixDQUFDLENBQUNjLGVBQWV4QztZQUN2RHVELHFCQUFxQjdELGtCQUFrQlcsU0FBUztRQUNwRDtRQUNBLElBQUksQ0FBQ21DLGlCQUFpQixDQUFDeEMsV0FBVyxDQUFDRyxlQUFlO1lBQzlDLE9BQU9xQixrQkFBa0JxQjtRQUM3QjtRQUNBLElBQUl6QyxXQUFXbkwsTUFBTSxLQUFLbUwsV0FBV3pWLE1BQU0sSUFBSXdWLGVBQWU7WUFDMURxQixrQkFBa0JxQjtZQUNsQkEsbUJBQW1CMUM7WUFDbkIsb0ZBQW9GO1lBQ3BGQSxjQUFjaEIsU0FBUyxDQUFDc0UsR0FBRyxDQUFDLGNBQWM7WUFDMUN0RCxjQUFjaEIsU0FBUyxDQUFDdUUsTUFBTSxDQUFDLFNBQVMxRDtZQUN4Q0csY0FBY2hCLFNBQVMsQ0FBQ3VFLE1BQU0sQ0FBQyw0QkFBNEIxRDtRQUMvRDtJQUNKO0lBQ0EsU0FBUzJELFlBQVkzVCxLQUFLO1FBQ3RCLElBQUksQ0FBQ3dTLGlCQUFpQnJDLGFBQVksS0FBTUMsY0FBY0osU0FBUztZQUMzRCtCLFlBQVkzQjtRQUNoQjtRQUNBLDhEQUE4RDtRQUM5RCxtREFBbUQ7UUFDbkQ5VyxXQUFXc2EsWUFBWSxHQUFHNVQ7UUFDMUIsSUFBSXVSLGlCQUFpQjtZQUNqQlMsa0JBQWtCaFM7UUFDdEI7UUFDQXdSLGtCQUFrQnFCO1FBQ2xCUDtRQUNBdUIscUJBQXFCdEI7UUFDckJRLGlCQUFpQjtRQUNqQi9DLFVBQVU7UUFDVkksYUFBYTtRQUNiRCxnQkFBZ0I7UUFDaEJ2QixJQUFJa0YsbUJBQW1CLENBQUMsYUFBYU47UUFDckM1RSxJQUFJa0YsbUJBQW1CLENBQUMsV0FBV0g7UUFDbkMvRSxJQUFJa0YsbUJBQW1CLENBQUMsYUFBYU47UUFDckM1RSxJQUFJa0YsbUJBQW1CLENBQUMsWUFBWUg7SUFDeEM7SUFDQS9FLElBQUltRixnQkFBZ0IsQ0FBQyxhQUFhUDtJQUNsQzVFLElBQUltRixnQkFBZ0IsQ0FBQyxXQUFXSjtJQUNoQy9FLElBQUltRixnQkFBZ0IsQ0FBQyxhQUFhUDtJQUNsQzVFLElBQUltRixnQkFBZ0IsQ0FBQyxZQUFZSjtBQUNyQztBQUVBLE1BQU1LLGNBQWMsSUFBTTtBQUMxQixNQUFNQyxhQUFhLENBQUN0YSxJQUFPO1FBQ3ZCMlosdUJBQXVCM1osRUFBRTJaLHFCQUFxQjtRQUM5Q1ksZ0JBQWdCdmEsRUFBRXVhLGNBQWM7UUFDaENDLGdCQUFnQnhhLEVBQUV3YSxjQUFjO0lBQ3BDO0FBQ0EsTUFBTUMscUJBQXFCLENBQUNoTCxRQUFRcUcsVUFBVW5YLE9BQVMsQ0FBQytiO1FBQ3BELE1BQU0sRUFBRWYsdUJBQXVCZ0IsV0FBVyxFQUFFZixxQkFBcUJsRCxTQUFTLEVBQUVrRSw0QkFBNEJDLFdBQVcsRUFBRyxHQUFHSDtRQUN6SCxPQUFPO1lBQ0hJLFlBQVksYUFBY3JMLFdBQVdBLFVBQVVrTCxhQUFhN0UsYUFBYUEsWUFBWTZFLGFBQWFoYyxTQUFTQSxRQUN0RytYLFdBQVdqSCxXQUFXQSxVQUFVaUgsV0FBV1osYUFBYUEsWUFBWVksV0FBVy9YLFNBQVNBO1lBQzdGb2MsaUJBQWlCRixhQUFhcEwsV0FBV0EsVUFBVW9MLGFBQWEvRSxhQUFhQSxZQUFZK0UsYUFBYWxjLFNBQVNBO1FBQ25IO0lBQ0o7QUFDQSxNQUFNcWMsdUJBQVMvZCxpREFBVUEsQ0FBQyxDQUFDLEVBQUUwQixPQUFPLFFBQVEsRUFBRXdCLFdBQVdxSyxTQUFTVSxHQUFHLEVBQUU4TCxpQkFBaUIsRUFBRU8sZ0JBQWdCLElBQUksRUFBRTBELHFCQUFxQixJQUFJLEVBQUVDLG1CQUFtQixJQUFJLEVBQUV6YyxFQUFFLEVBQUUyWixTQUFTLEVBQUVoWSxRQUFRLEVBQUVDLFNBQVMsRUFBRThhLFdBQVcsRUFBRUMsWUFBWSxFQUFFLEdBQUc3YSxNQUFNLEVBQUVrQztJQUMxTyxNQUFNcVQsV0FBV3JYLE1BQU07SUFDdkIsTUFBTXdZLFdBQVd0WSxTQUFTO0lBQzFCLE1BQU1hLFFBQVFFO0lBQ2QsTUFBTStQLFNBQVNEO0lBQ2YsTUFBTSxFQUFFK0ssY0FBYyxFQUFFQyxjQUFjLEVBQUUsR0FBR25iLFNBQVNpYixZQUFZaGQsb0RBQU9BO0lBQ3ZFLE1BQU0sRUFBRXdkLFVBQVUsRUFBRUMsZUFBZSxFQUFFLEdBQUcxYixTQUFTb2IsbUJBQW1CaEwsUUFBUXFHLFVBQVVuWCxPQUFPckIsb0RBQU9BO0lBQ3BHLElBQUksQ0FBQ21TLFFBQVE7UUFDVGpRLE1BQU1HLFFBQVEsR0FBRzBiLE9BQU8sR0FBRyxPQUFPcmQsYUFBYSxDQUFDLFdBQVc7SUFDL0Q7SUFDQSxNQUFNc2Qsb0JBQW9CLENBQUNDO1FBQ3ZCLE1BQU0sRUFBRUMsa0JBQWtCLEVBQUVwRCxXQUFXcUQsZUFBZSxFQUFFQyxlQUFlLEVBQUUsR0FBR2xjLE1BQU1HLFFBQVE7UUFDMUYsTUFBTXNSLGFBQWE7WUFDZixHQUFHdUssa0JBQWtCO1lBQ3JCLEdBQUdELE1BQU07UUFDYjtRQUNBLElBQUlHLGlCQUFpQjtZQUNqQixNQUFNLEVBQUUxUyxLQUFLLEVBQUUyUyxRQUFRLEVBQUUsR0FBR25jLE1BQU1HLFFBQVE7WUFDMUNnYyxTQUFTM0ssUUFBUUMsWUFBWWpJO1FBQ2pDO1FBQ0F5UyxrQkFBa0J4SztRQUNsQm1ILFlBQVluSDtJQUNoQjtJQUNBLE1BQU0ySyxnQkFBZ0IsQ0FBQ3ZWO1FBQ25CLElBQUksQ0FBQ29KLFFBQVE7WUFDVDtRQUNKO1FBQ0EsTUFBTXhJLG1CQUFtQkYsYUFBYVY7UUFDdEMsSUFBSTRVLHNCQUF1QixxQkFBcUI1VSxNQUFNd1YsTUFBTSxLQUFLLEtBQU0sQ0FBQzVVLGdCQUFlLEdBQUk7WUFDdkZrUixrQkFBa0I7Z0JBQ2Q5UjtnQkFDQXlQO2dCQUNBckc7Z0JBQ0EySSxXQUFXa0Q7Z0JBQ1hyRTtnQkFDQXRYLFVBQVVILE1BQU1HLFFBQVE7Z0JBQ3hCQyxVQUFVSixNQUFNSSxRQUFRO2dCQUN4Qm9YLG1CQUFtQkEscUJBQXFCeFgsTUFBTUcsUUFBUSxHQUFHcVgsaUJBQWlCLElBQUlxRDtZQUNsRjtRQUNKO1FBQ0EsSUFBSXBULGtCQUFrQjtZQUNsQmtVLGNBQWM5VTtRQUNsQixPQUNLO1lBQ0QrVSxlQUFlL1U7UUFDbkI7SUFDSjtJQUNBLE1BQU15VixVQUFVLENBQUN6VjtRQUNiLE1BQU0sRUFBRTBWLG1CQUFtQixFQUFFQyxpQkFBaUIsRUFBRXBCLDBCQUEwQixFQUFFaEUsY0FBYyxFQUFFSSxtQkFBbUJpRixzQkFBc0IsRUFBRyxHQUFHemMsTUFBTUcsUUFBUTtRQUN6SixJQUFJLENBQUM4UCxVQUFXLENBQUNtTCw4QkFBOEIsQ0FBQ0ssb0JBQXFCO1lBQ2pFO1FBQ0o7UUFDQSxJQUFJLENBQUNMLDRCQUE0QjtZQUM3Qm1CLHNCQUFzQjFWLE9BQU87Z0JBQUVvSjtnQkFBUXFHO2dCQUFVRixZQUFZalg7WUFBSztZQUNsRWEsTUFBTUksUUFBUSxDQUFDO2dCQUFFZ2IsNEJBQTRCO29CQUFFbkw7b0JBQVE5UTtvQkFBTW1YO2dCQUFTO1lBQUU7WUFDeEU7UUFDSjtRQUNBLE1BQU1iLE1BQU1uUixrQkFBa0J1QyxNQUFNckYsTUFBTTtRQUMxQyxNQUFNa2IsMkJBQTJCbEYscUJBQXFCaUYsMEJBQTBCNUI7UUFDaEYsTUFBTSxFQUFFNUQsVUFBVSxFQUFFSixPQUFPLEVBQUUsR0FBR00sY0FBYztZQUMxQ2xIO1lBQ0FoUixJQUFJcVg7WUFDSm5YO1FBQ0osR0FBR2lZLGdCQUFnQmdFLDJCQUEyQm5MLE1BQU0sRUFBRW1MLDJCQUEyQjlFLFFBQVEsSUFBSSxNQUFNOEUsMkJBQTJCamMsSUFBSSxFQUFFdWQsMEJBQTBCakg7UUFDOUosSUFBSW9CLFNBQVM7WUFDVGlGLGtCQUFrQjdFO1FBQ3RCO1FBQ0F1RixvQkFBb0IzVjtRQUNwQjdHLE1BQU1JLFFBQVEsQ0FBQztZQUFFZ2IsNEJBQTRCO1FBQUs7SUFDdEQ7SUFDQSxxQkFBUW5lLGdEQUFtQixDQUFDLE9BQU87UUFBRSxpQkFBaUJxWjtRQUFVLGVBQWVyRztRQUFRLGtCQUFrQnRQO1FBQVUsV0FBVyxDQUFDLEVBQUVzUCxPQUFPLENBQUMsRUFBRXFHLFNBQVMsQ0FBQyxFQUFFblgsS0FBSyxDQUFDO1FBQUUwQixXQUFXbEQsb0RBQUVBLENBQUM7WUFDcks7WUFDQSxDQUFDLG1CQUFtQixFQUFFZ0QsU0FBUyxDQUFDO1lBQ2hDO1lBQ0FxYTtZQUNBbmE7WUFDQTtnQkFDSWlMLFFBQVEsQ0FBQzJMO2dCQUNUalcsUUFBUWlXO2dCQUNSSSxhQUFhRTtnQkFDYjRFLGtCQUFrQmxCO2dCQUNsQm1CLGdCQUFnQmxCO2dCQUNoQkosWUFBWUM7Z0JBQ1oscUVBQXFFO2dCQUNyRXNCLHFCQUFxQjlFLGlCQUFrQix1QkFBdUIsQ0FBQ3VELGNBQWdCSSxvQkFBb0JKLFVBQVU7WUFDakg7U0FDSDtRQUFHSyxhQUFhUztRQUFlUixjQUFjUTtRQUFlRSxTQUFTdkIsaUJBQWlCdUIsVUFBVS9TO1FBQVd0RyxLQUFLQTtRQUFLLEdBQUdsQyxJQUFJO0lBQUMsR0FBR0g7QUFDekk7QUFDQTRhLE9BQU92UyxXQUFXLEdBQUc7QUFDckIsSUFBSTZULHlCQUFXemYsMkNBQUlBLENBQUNtZTtBQUVwQixNQUFNdUIsY0FBYyxDQUFDLEVBQUVDLElBQUksRUFBRWpGLGFBQWEsRUFBRXRNLGlCQUFpQlQsU0FBU1UsR0FBRyxFQUFFSCxpQkFBaUJQLFNBQVNRLE1BQU0sRUFBRztJQUMxRyxxQkFBUXZPLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLG9CQUN4Q0EsZ0RBQW1CLENBQUM2ZixVQUFVO1FBQUUzZCxNQUFNO1FBQVV3QixVQUFVOEs7UUFBZ0JzTSxlQUFlQTtJQUFjLElBQ3ZHaUYsTUFBTW5iLHFCQUNONUUsZ0RBQW1CLENBQUM2ZixVQUFVO1FBQUUzZCxNQUFNO1FBQVV3QixVQUFVNEs7UUFBZ0J3TSxlQUFlQTtJQUFjO0FBQy9HO0FBQ0FnRixZQUFZOVQsV0FBVyxHQUFHO0FBQzFCLElBQUlnVSw4QkFBZ0I1ZiwyQ0FBSUEsQ0FBQzBmO0FBRXpCLE1BQU1HLFlBQVksQ0FBQyxFQUFFRixJQUFJLEVBQUVqRixhQUFhLEVBQUV4TSxpQkFBaUJQLFNBQVNRLE1BQU0sRUFBRSxpQkFBTXZPLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLE1BQ2xIK2YsTUFBTW5iLHFCQUNONUUsZ0RBQW1CLENBQUM2ZixVQUFVO1FBQUUzZCxNQUFNO1FBQVV3QixVQUFVNEs7UUFBZ0J3TSxlQUFlQTtJQUFjO0FBQzNHbUYsVUFBVWpVLFdBQVcsR0FBRztBQUN4QixJQUFJa1UsNEJBQWM5ZiwyQ0FBSUEsQ0FBQzZmO0FBRXZCLE1BQU1FLGFBQWEsQ0FBQyxFQUFFSixJQUFJLEVBQUVqRixhQUFhLEVBQUV0TSxpQkFBaUJULFNBQVNVLEdBQUcsRUFBRSxpQkFBTXpPLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLG9CQUNoSEEsZ0RBQW1CLENBQUM2ZixVQUFVO1FBQUUzZCxNQUFNO1FBQVV3QixVQUFVOEs7UUFBZ0JzTSxlQUFlQTtJQUFjLElBQ3ZHaUYsTUFBTW5iO0FBQ1Z1YixXQUFXblUsV0FBVyxHQUFHO0FBQ3pCLElBQUlvVSw2QkFBZWhnQiwyQ0FBSUEsQ0FBQytmO0FBRXhCLE1BQU1FLFlBQVksSUFBTTtBQUN4QkEsVUFBVXJVLFdBQVcsR0FBRztBQUV4QixNQUFNc1UsYUFBYSxDQUFDL2MsSUFBTztRQUN2QmdkLGVBQWVoZCxFQUFFMFksUUFBUSxHQUFHM0ksTUFBTSxDQUFDLENBQUN2SyxJQUFNQSxFQUFFeVgsUUFBUTtRQUNwREMsZUFBZWxkLEVBQUVnSixLQUFLLENBQUMrRyxNQUFNLENBQUMsQ0FBQzdHLElBQU1BLEVBQUUrVCxRQUFRO0lBQ25EO0FBQ0EsTUFBTUUsV0FBVyxDQUFDN1gsTUFBUUEsSUFBSTdHLEVBQUU7QUFDaEMsU0FBUzJlLFNBQVM1UixDQUFDLEVBQUVDLENBQUM7SUFDbEIsT0FBUW5PLHdEQUFPQSxDQUFDa08sRUFBRXdSLGFBQWEsQ0FBQ2hOLEdBQUcsQ0FBQ21OLFdBQVcxUixFQUFFdVIsYUFBYSxDQUFDaE4sR0FBRyxDQUFDbU4sY0FDL0Q3Zix3REFBT0EsQ0FBQ2tPLEVBQUUwUixhQUFhLENBQUNsTixHQUFHLENBQUNtTixXQUFXMVIsRUFBRXlSLGFBQWEsQ0FBQ2xOLEdBQUcsQ0FBQ21OO0FBQ25FO0FBQ0EsOEVBQThFO0FBQzlFLDJHQUEyRztBQUMzRyxNQUFNRSxrQ0FBb0J4Z0IsMkNBQUlBLENBQUMsQ0FBQyxFQUFFeWdCLGlCQUFpQixFQUFFO0lBQ2pELE1BQU05ZCxRQUFRRTtJQUNkLE1BQU0sRUFBRXNkLGFBQWEsRUFBRUUsYUFBYSxFQUFFLEdBQUc3ZCxTQUFTMGQsWUFBWUs7SUFDOURwZ0IsZ0RBQVNBLENBQUM7UUFDTixNQUFNdWUsU0FBUztZQUFFMUwsT0FBT21OO1lBQWVoVSxPQUFPa1U7UUFBYztRQUM1REksb0JBQW9CL0I7UUFDcEIvYixNQUFNRyxRQUFRLEdBQUcyZCxpQkFBaUIsQ0FBQ3JLLE9BQU8sQ0FBQyxDQUFDc0ssS0FBT0EsR0FBR2hDO0lBQzFELEdBQUc7UUFBQ3lCO1FBQWVFO1FBQWVJO0tBQWtCO0lBQ3BELE9BQU87QUFDWDtBQUNBRCxrQkFBa0I1VSxXQUFXLEdBQUc7QUFDaEMsTUFBTStVLGlCQUFpQixDQUFDeGQsSUFBTSxDQUFDLENBQUNBLEVBQUVzZCxpQkFBaUI7QUFDbkQsU0FBU0csVUFBVSxFQUFFSCxpQkFBaUIsRUFBRTtJQUNwQyxNQUFNSSwwQkFBMEJyZSxTQUFTbWU7SUFDekMsSUFBSUYscUJBQXFCSSx5QkFBeUI7UUFDOUMscUJBQU9qaEIsZ0RBQW1CLENBQUM0Z0IsbUJBQW1CO1lBQUVDLG1CQUFtQkE7UUFBa0I7SUFDekY7SUFDQSxPQUFPO0FBQ1g7QUFFQSxNQUFNSyxhQUFhLENBQUMzZCxJQUFPO1FBQ3ZCNGQsVUFBVTVkLEVBQUU0ZCxRQUFRO1FBQ3BCakMsVUFBVTNiLEVBQUUyYixRQUFRO1FBQ3BCa0MseUJBQXlCN2QsRUFBRTZkLHVCQUF1QjtRQUNsREMsWUFBWTlkLEVBQUU4ZCxVQUFVO1FBQ3hCQyxZQUFZL2QsRUFBRStkLFVBQVU7UUFDeEJDLG9CQUFvQmhlLEVBQUVnZSxrQkFBa0I7UUFDeENDLGVBQWVqZSxFQUFFaWUsYUFBYTtRQUM5QkMsT0FBT2xlLEVBQUVrZSxLQUFLO0lBQ2xCO0FBQ0EsU0FBU0MsZ0JBQWdCNWEsS0FBSyxFQUFFNmEsYUFBYTtJQUN6Q3BoQixnREFBU0EsQ0FBQztRQUNOLElBQUksT0FBT3VHLFVBQVUsYUFBYTtZQUM5QjZhLGNBQWM3YTtRQUNsQjtJQUNKLEdBQUc7UUFBQ0E7S0FBTTtBQUNkO0FBQ0EsMkVBQTJFO0FBQzNFLFNBQVM4YSxzQkFBc0IxTixHQUFHLEVBQUVwTixLQUFLLEVBQUUzRCxRQUFRO0lBQy9DNUMsZ0RBQVNBLENBQUM7UUFDTixJQUFJLE9BQU91RyxVQUFVLGFBQWE7WUFDOUIzRCxTQUFTO2dCQUFFLENBQUMrUSxJQUFJLEVBQUVwTjtZQUFNO1FBQzVCO0lBQ0osR0FBRztRQUFDQTtLQUFNO0FBQ2Q7QUFDQSxNQUFNK2EsZUFBZSxDQUFDLEVBQUV6TyxLQUFLLEVBQUU3RyxLQUFLLEVBQUV1VixZQUFZLEVBQUVDLFlBQVksRUFBRXBHLFNBQVMsRUFBRUksY0FBYyxFQUFFeUIsWUFBWSxFQUFFOEIsbUJBQW1CLEVBQUVDLGlCQUFpQixFQUFFeUMsY0FBYyxFQUFFQyxnQkFBZ0IsRUFBRUMsY0FBYyxFQUFFQyxjQUFjLEVBQUVDLGNBQWMsRUFBRUMsb0JBQW9CLEVBQUUvSyxPQUFPLEVBQUVDLE9BQU8sRUFBRStLLFVBQVUsRUFBRUMsYUFBYSxFQUFFQyxhQUFhLEVBQUVDLGtCQUFrQixFQUFFdEksY0FBYyxFQUFFdUksUUFBUSxFQUFFck4sVUFBVSxFQUFFc04sZUFBZSxFQUFFN0UsY0FBYyxFQUFFaUIsa0JBQWtCLEVBQUU2RCxPQUFPLEVBQUVDLGNBQWMsRUFBRUMsYUFBYSxFQUFFQyxhQUFhLEVBQUVDLFVBQVUsRUFBRUMsZUFBZSxFQUFFQyxjQUFjLEVBQUVDLGVBQWUsRUFBRUMsb0JBQW9CLEVBQUVDLG1CQUFtQixFQUFFdEYsY0FBYyxFQUFFcEksVUFBVSxFQUFFOUIsSUFBSSxFQUFFaUksZ0JBQWdCLEVBQUV3SCxpQkFBaUIsRUFBRTFFLE9BQU8sRUFBRW5HLGdCQUFnQixFQUFFOEIsaUJBQWlCLEVBQUVnSixpQkFBaUIsRUFBRztJQUMzc0IsTUFBTSxFQUFFcEMsUUFBUSxFQUFFakMsUUFBUSxFQUFFa0MsdUJBQXVCLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxrQkFBa0IsRUFBRUMsYUFBYSxFQUFFQyxLQUFLLEVBQUcsR0FBRzdlLFNBQVNzZSxZQUFZcmdCLG9EQUFPQTtJQUN2SixNQUFNa0MsUUFBUUU7SUFDZDFDLGdEQUFTQSxDQUFDO1FBQ04sTUFBTWlqQixvQkFBb0J6QixjQUFjeE8sSUFBSSxDQUFDOUcsSUFBTztnQkFBRSxHQUFHQSxDQUFDO2dCQUFFLEdBQUdzUyxrQkFBa0I7WUFBQztRQUNsRnFDLHdCQUF3QlUsY0FBYzBCO1FBQ3RDLE9BQU87WUFDSC9CO1FBQ0o7SUFDSixHQUFHLEVBQUU7SUFDTEcsc0JBQXNCLHNCQUFzQjdDLG9CQUFvQmhjLE1BQU1JLFFBQVE7SUFDOUV5ZSxzQkFBc0Isa0JBQWtCekgsZ0JBQWdCcFgsTUFBTUksUUFBUTtJQUN0RXllLHNCQUFzQixhQUFhakcsV0FBVzVZLE1BQU1JLFFBQVE7SUFDNUR5ZSxzQkFBc0Isa0JBQWtCN0YsZ0JBQWdCaFosTUFBTUksUUFBUTtJQUN0RXllLHNCQUFzQixnQkFBZ0JwRSxjQUFjemEsTUFBTUksUUFBUTtJQUNsRXllLHNCQUFzQix1QkFBdUJ0QyxxQkFBcUJ2YyxNQUFNSSxRQUFRO0lBQ2hGeWUsc0JBQXNCLHFCQUFxQnJDLG1CQUFtQnhjLE1BQU1JLFFBQVE7SUFDNUV5ZSxzQkFBc0Isa0JBQWtCSSxnQkFBZ0JqZixNQUFNSSxRQUFRO0lBQ3RFeWUsc0JBQXNCLG9CQUFvQkssa0JBQWtCbGYsTUFBTUksUUFBUTtJQUMxRXllLHNCQUFzQixrQkFBa0JNLGdCQUFnQm5mLE1BQU1JLFFBQVE7SUFDdEV5ZSxzQkFBc0Isa0JBQWtCTyxnQkFBZ0JwZixNQUFNSSxRQUFRO0lBQ3RFeWUsc0JBQXNCLGtCQUFrQlEsZ0JBQWdCcmYsTUFBTUksUUFBUTtJQUN0RXllLHNCQUFzQixzQkFBc0JhLG9CQUFvQjFmLE1BQU1JLFFBQVE7SUFDOUV5ZSxzQkFBc0Isd0JBQXdCUyxzQkFBc0J0ZixNQUFNSSxRQUFRO0lBQ2xGeWUsc0JBQXNCLGNBQWN2TSxZQUFZdFMsTUFBTUksUUFBUTtJQUM5RHllLHNCQUFzQixZQUFZYyxVQUFVM2YsTUFBTUksUUFBUTtJQUMxRHllLHNCQUFzQixpQkFBaUJXLGVBQWV4ZixNQUFNSSxRQUFRO0lBQ3BFeWUsc0JBQXNCLGlCQUFpQlksZUFBZXpmLE1BQU1JLFFBQVE7SUFDcEV5ZSxzQkFBc0Isa0JBQWtCOUQsZ0JBQWdCL2EsTUFBTUksUUFBUTtJQUN0RXllLHNCQUFzQixpQkFBaUJnQixTQUFTN2YsTUFBTUksUUFBUTtJQUM5RHllLHNCQUFzQix3QkFBd0JpQixnQkFBZ0I5ZixNQUFNSSxRQUFRO0lBQzVFeWUsc0JBQXNCLGlCQUFpQmtCLGVBQWUvZixNQUFNSSxRQUFRO0lBQ3BFeWUsc0JBQXNCLGlCQUFpQm1CLGVBQWVoZ0IsTUFBTUksUUFBUTtJQUNwRXllLHNCQUFzQixjQUFjb0IsWUFBWWpnQixNQUFNSSxRQUFRO0lBQzlEeWUsc0JBQXNCLG1CQUFtQnFCLGlCQUFpQmxnQixNQUFNSSxRQUFRO0lBQ3hFeWUsc0JBQXNCLGtCQUFrQnNCLGdCQUFnQm5nQixNQUFNSSxRQUFRO0lBQ3RFeWUsc0JBQXNCLG1CQUFtQnVCLGlCQUFpQnBnQixNQUFNSSxRQUFRO0lBQ3hFeWUsc0JBQXNCLHdCQUF3QndCLHNCQUFzQnJnQixNQUFNSSxRQUFRO0lBQ2xGeWUsc0JBQXNCLHVCQUF1QnlCLHFCQUFxQnRnQixNQUFNSSxRQUFRO0lBQ2hGeWUsc0JBQXNCLGtCQUFrQjdELGdCQUFnQmhiLE1BQU1JLFFBQVE7SUFDdEV5ZSxzQkFBc0IsY0FBY2pNLFlBQVk1UyxNQUFNSSxRQUFRO0lBQzlEeWUsc0JBQXNCLFFBQVEvTixNQUFNOVEsTUFBTUksUUFBUTtJQUNsRHllLHNCQUFzQixvQkFBb0I5RixrQkFBa0IvWSxNQUFNSSxRQUFRO0lBQzFFeWUsc0JBQXNCLHFCQUFxQjBCLG1CQUFtQnZnQixNQUFNSSxRQUFRO0lBQzVFeWUsc0JBQXNCLFdBQVdoRCxTQUFTN2IsTUFBTUksUUFBUTtJQUN4RHllLHNCQUFzQixvQkFBb0JuSixrQkFBa0IxVixNQUFNSSxRQUFRO0lBQzFFeWUsc0JBQXNCLHFCQUFxQnJILG1CQUFtQnhYLE1BQU1JLFFBQVE7SUFDNUV5ZSxzQkFBc0IscUJBQXFCMkIsbUJBQW1CeGdCLE1BQU1JLFFBQVE7SUFDNUV1ZSxnQkFBZ0J0TyxPQUFPK047SUFDdkJPLGdCQUFnQm5WLE9BQU8yUztJQUN2QndDLGdCQUFnQnBLLFNBQVMrSjtJQUN6QkssZ0JBQWdCbkssU0FBUytKO0lBQ3pCSSxnQkFBZ0JpQixpQkFBaUJwQjtJQUNqQ0csZ0JBQWdCWSxZQUFZZDtJQUM1QixPQUFPO0FBQ1g7QUFFQSxNQUFNM2QsUUFBUTtJQUFFNGYsU0FBUztBQUFPO0FBQ2hDLE1BQU1DLGdCQUFnQjtJQUNsQmhnQixVQUFVO0lBQ1YyQixPQUFPO0lBQ1BDLFFBQVE7SUFDUnFlLFFBQVEsQ0FBQztJQUNUQyxRQUFRO0lBQ1JwTSxTQUFTO0lBQ1RxTSxVQUFVO0lBQ1ZDLE1BQU07SUFDTkMsVUFBVTtBQUNkO0FBQ0EsTUFBTUMscUJBQXFCO0FBQzNCLE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxvQkFBb0I7QUFDMUIsTUFBTUMsYUFBYSxDQUFDNWdCLElBQU1BLEVBQUU2Z0IsZUFBZTtBQUMzQyxTQUFTQyxnQkFBZ0IsRUFBRXhRLElBQUksRUFBRTtJQUM3QixNQUFNdVEsa0JBQWtCeGhCLFNBQVN1aEI7SUFDakMscUJBQVFua0IsZ0RBQW1CLENBQUMsT0FBTztRQUFFZ0MsSUFBSSxDQUFDLEVBQUVraUIsa0JBQWtCLENBQUMsRUFBRXJRLEtBQUssQ0FBQztRQUFFLGFBQWE7UUFBYSxlQUFlO1FBQVFoUSxPQUFPNmY7SUFBYyxHQUFHVTtBQUN0SjtBQUNBLFNBQVNFLGlCQUFpQixFQUFFelEsSUFBSSxFQUFFMFEsbUJBQW1CLEVBQUU7SUFDbkQscUJBQVF2a0IsZ0RBQW1CLENBQUNBLDJDQUFjLEVBQUUsb0JBQ3hDQSxnREFBbUIsQ0FBQyxPQUFPO1FBQUVnQyxJQUFJLENBQUMsRUFBRWdpQixtQkFBbUIsQ0FBQyxFQUFFblEsS0FBSyxDQUFDO1FBQUVoUSxPQUFPQTtJQUFNLEdBQzNFLDBDQUNBLENBQUMwZ0IsdUJBQXVCLDREQUN4QixvREFDQSxvQkFDSnZrQixnREFBbUIsQ0FBQyxPQUFPO1FBQUVnQyxJQUFJLENBQUMsRUFBRWlpQixtQkFBbUIsQ0FBQyxFQUFFcFEsS0FBSyxDQUFDO1FBQUVoUSxPQUFPQTtJQUFNLEdBQUcsd0dBQ2xGLENBQUMwZ0IscUNBQXVCdmtCLGdEQUFtQixDQUFDcWtCLGlCQUFpQjtRQUFFeFEsTUFBTUE7SUFBSztBQUNsRjtBQUVBLHNFQUFzRTtBQUN0RSwwRUFBMEU7QUFDMUUsMkVBQTJFO0FBQzNFLCtEQUErRDtBQUMvRCxJQUFJMlEsY0FBYyxDQUFDQyxVQUFVLElBQUksRUFBRTVQLFVBQVU7SUFBRTZQLDRCQUE0QjtBQUFLLENBQUM7SUFDN0UsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUd0a0IsK0NBQVFBLENBQUM7SUFDN0Msd0VBQXdFO0lBQ3hFLE1BQU11a0Isa0JBQWtCeGtCLDZDQUFNQSxDQUFDO0lBQy9CLHdFQUF3RTtJQUN4RSxNQUFNeWtCLGNBQWN6a0IsNkNBQU1BLENBQUMsSUFBSTBrQixJQUFJLEVBQUU7SUFDckMsNkVBQTZFO0lBQzdFLHNFQUFzRTtJQUN0RSxpR0FBaUc7SUFDakcsOEdBQThHO0lBQzlHLGlIQUFpSDtJQUNqSCwrQ0FBK0M7SUFDL0MsTUFBTSxDQUFDQyxVQUFVQyxZQUFZLEdBQUc5a0IsOENBQU9BLENBQUM7UUFDcEMsSUFBSXNrQixZQUFZLE1BQU07WUFDbEIsTUFBTVMsYUFBYUMsTUFBTUMsT0FBTyxDQUFDWCxXQUFXQSxVQUFVO2dCQUFDQTthQUFRO1lBQy9ELE1BQU16USxPQUFPa1IsV0FBVzVSLE1BQU0sQ0FBQyxDQUFDK1IsS0FBTyxPQUFPQSxPQUFPLFVBQVU5UixHQUFHLENBQUMsQ0FBQzhSLEtBQU9BLEdBQUdwaEIsS0FBSyxDQUFDO1lBQ3BGLE1BQU1xaEIsV0FBV3RSLEtBQUtwQyxNQUFNLENBQUMsQ0FBQ0MsS0FBSzBULE9BQVMxVCxJQUFJNEMsTUFBTSxJQUFJOFEsT0FBTyxFQUFFO1lBQ25FLE9BQU87Z0JBQUN2UjtnQkFBTXNSO2FBQVM7UUFDM0I7UUFDQSxPQUFPO1lBQUMsRUFBRTtZQUFFLEVBQUU7U0FBQztJQUNuQixHQUFHO1FBQUNiO0tBQVE7SUFDWmxrQixnREFBU0EsQ0FBQztRQUNOLE1BQU1pWSxNQUFNLE9BQU8vUSxhQUFhLGNBQWNBLFdBQVc7UUFDekQsTUFBTWxELFNBQVNzUSxTQUFTdFEsVUFBVWlVO1FBQ2xDLElBQUlpTSxZQUFZLE1BQU07WUFDbEIsTUFBTWUsY0FBYyxDQUFDNWI7Z0JBQ2pCaWIsZ0JBQWdCcmYsT0FBTyxHQUFHb0UsTUFBTTZiLE9BQU8sSUFBSTdiLE1BQU04YixPQUFPLElBQUk5YixNQUFNK2IsUUFBUTtnQkFDMUUsTUFBTUMsZ0JBQWdCLENBQUMsQ0FBQ2YsZ0JBQWdCcmYsT0FBTyxJQUFLcWYsZ0JBQWdCcmYsT0FBTyxJQUFJLENBQUNxUCxRQUFRNlAsMEJBQTBCLEtBQzlHN2EsZUFBZUQ7Z0JBQ25CLElBQUlnYyxlQUFlO29CQUNmLE9BQU87Z0JBQ1g7Z0JBQ0EsTUFBTUMsWUFBWUMsYUFBYWxjLE1BQU1tYyxJQUFJLEVBQUVkO2dCQUMzQ0gsWUFBWXRmLE9BQU8sQ0FBQzZYLEdBQUcsQ0FBQ3pULEtBQUssQ0FBQ2ljLFVBQVU7Z0JBQ3hDLElBQUlHLGNBQWNoQixVQUFVRixZQUFZdGYsT0FBTyxFQUFFLFFBQVE7b0JBQ3JEb0UsTUFBTXFjLGNBQWM7b0JBQ3BCckIsY0FBYztnQkFDbEI7WUFDSjtZQUNBLE1BQU1zQixZQUFZLENBQUN0YztnQkFDZixNQUFNZ2MsZ0JBQWdCLENBQUMsQ0FBQ2YsZ0JBQWdCcmYsT0FBTyxJQUFLcWYsZ0JBQWdCcmYsT0FBTyxJQUFJLENBQUNxUCxRQUFRNlAsMEJBQTBCLEtBQzlHN2EsZUFBZUQ7Z0JBQ25CLElBQUlnYyxlQUFlO29CQUNmLE9BQU87Z0JBQ1g7Z0JBQ0EsTUFBTUMsWUFBWUMsYUFBYWxjLE1BQU1tYyxJQUFJLEVBQUVkO2dCQUMzQyxJQUFJZSxjQUFjaEIsVUFBVUYsWUFBWXRmLE9BQU8sRUFBRSxPQUFPO29CQUNwRG9mLGNBQWM7b0JBQ2RFLFlBQVl0ZixPQUFPLENBQUMyZ0IsS0FBSztnQkFDN0IsT0FDSztvQkFDRHJCLFlBQVl0ZixPQUFPLENBQUM0Z0IsTUFBTSxDQUFDeGMsS0FBSyxDQUFDaWMsVUFBVTtnQkFDL0M7Z0JBQ0EsME1BQTBNO2dCQUMxTSxJQUFJamMsTUFBTXNLLEdBQUcsS0FBSyxRQUFRO29CQUN0QjRRLFlBQVl0ZixPQUFPLENBQUMyZ0IsS0FBSztnQkFDN0I7Z0JBQ0F0QixnQkFBZ0JyZixPQUFPLEdBQUc7WUFDOUI7WUFDQSxNQUFNNmdCLGVBQWU7Z0JBQ2pCdkIsWUFBWXRmLE9BQU8sQ0FBQzJnQixLQUFLO2dCQUN6QnZCLGNBQWM7WUFDbEI7WUFDQXJnQixRQUFRb1osaUJBQWlCLFdBQVc2SDtZQUNwQ2poQixRQUFRb1osaUJBQWlCLFNBQVN1STtZQUNsQzFlLE9BQU9tVyxnQkFBZ0IsQ0FBQyxRQUFRMEk7WUFDaEMsT0FBTztnQkFDSDloQixRQUFRbVosb0JBQW9CLFdBQVc4SDtnQkFDdkNqaEIsUUFBUW1aLG9CQUFvQixTQUFTd0k7Z0JBQ3JDMWUsT0FBT2tXLG1CQUFtQixDQUFDLFFBQVEySTtZQUN2QztRQUNKO0lBQ0osR0FBRztRQUFDNUI7UUFBU0c7S0FBYztJQUMzQixPQUFPRDtBQUNYO0FBQ0EsUUFBUTtBQUNSLFNBQVNxQixjQUFjaEIsUUFBUSxFQUFFRixXQUFXLEVBQUV3QixJQUFJO0lBQzlDLE9BQVF0QixRQUNKLDREQUE0RDtJQUM1RCxzRUFBc0U7SUFDdEUsK0VBQStFO0tBQzlFMVIsTUFBTSxDQUFDLENBQUNVLE9BQVNzUyxRQUFRdFMsS0FBSy9CLE1BQU0sS0FBSzZTLFlBQVl4VCxJQUFJLENBQzFELGtFQUFrRTtJQUNsRSxtREFBbUQ7S0FDbEQrQyxJQUFJLENBQUMsQ0FBQ0wsT0FBU0EsS0FBS3VTLEtBQUssQ0FBQyxDQUFDQyxJQUFNMUIsWUFBWTJCLEdBQUcsQ0FBQ0Q7QUFDMUQ7QUFDQSxTQUFTVixhQUFhWSxTQUFTLEVBQUV6QixXQUFXO0lBQ3hDLE9BQU9BLFlBQVkvYSxRQUFRLENBQUN3YyxhQUFhLFNBQVM7QUFDdEQ7QUFFQSxTQUFTQyxxQkFBcUJ4Z0IsSUFBSSxFQUFFK1AsYUFBYSxFQUFFeUUsTUFBTSxFQUFFaEYsVUFBVTtJQUNqRSxJQUFJLENBQUN4UCxLQUFLeWdCLFVBQVUsRUFBRTtRQUNsQixPQUFPak07SUFDWDtJQUNBLE1BQU1pTSxhQUFhMVEsY0FBYzJRLEdBQUcsQ0FBQzFnQixLQUFLeWdCLFVBQVU7SUFDcEQsTUFBTUUscUJBQXFCcFIsMEJBQTBCa1IsWUFBWWpSO0lBQ2pFLE9BQU9nUixxQkFBcUJDLFlBQVkxUSxlQUFlO1FBQ25EeFIsR0FBRyxDQUFDaVcsT0FBT2pXLENBQUMsSUFBSSxLQUFLb2lCLG1CQUFtQnBpQixDQUFDO1FBQ3pDQyxHQUFHLENBQUNnVyxPQUFPaFcsQ0FBQyxJQUFJLEtBQUttaUIsbUJBQW1CbmlCLENBQUM7UUFDekNvaUIsR0FBRyxDQUFDSCxVQUFVLENBQUMxZCxnQkFBZ0IsRUFBRTZkLEtBQUssS0FBTXBNLENBQUFBLE9BQU9vTSxDQUFDLElBQUksS0FBS0gsVUFBVSxDQUFDMWQsZ0JBQWdCLEVBQUU2ZCxLQUFLLElBQUlwTSxPQUFPb00sQ0FBQyxJQUFJO0lBQ25ILEdBQUdwUjtBQUNQO0FBQ0EsU0FBU3FSLDRCQUE0QjlRLGFBQWEsRUFBRVAsVUFBVSxFQUFFc1IsV0FBVztJQUN2RS9RLGNBQWNNLE9BQU8sQ0FBQyxDQUFDclE7UUFDbkIsSUFBSUEsS0FBS3lnQixVQUFVLElBQUksQ0FBQzFRLGNBQWN1USxHQUFHLENBQUN0Z0IsS0FBS3lnQixVQUFVLEdBQUc7WUFDeEQsTUFBTSxJQUFJNWpCLE1BQU0sQ0FBQyxZQUFZLEVBQUVtRCxLQUFLeWdCLFVBQVUsQ0FBQyxVQUFVLENBQUM7UUFDOUQ7UUFDQSxJQUFJemdCLEtBQUt5Z0IsVUFBVSxJQUFJSyxhQUFhLENBQUM5Z0IsS0FBS25FLEVBQUUsQ0FBQyxFQUFFO1lBQzNDLE1BQU0sRUFBRTBDLENBQUMsRUFBRUMsQ0FBQyxFQUFFb2lCLENBQUMsRUFBRSxHQUFHSixxQkFBcUJ4Z0IsTUFBTStQLGVBQWU7Z0JBQzFELEdBQUcvUCxLQUFLekMsUUFBUTtnQkFDaEJxakIsR0FBRzVnQixJQUFJLENBQUMrQyxnQkFBZ0IsRUFBRTZkLEtBQUs7WUFDbkMsR0FBR3BSO1lBQ0h4UCxLQUFLK0IsZ0JBQWdCLEdBQUc7Z0JBQ3BCeEQ7Z0JBQ0FDO1lBQ0o7WUFDQXdCLElBQUksQ0FBQytDLGdCQUFnQixDQUFDNmQsQ0FBQyxHQUFHQTtZQUMxQixJQUFJRSxhQUFhLENBQUM5Z0IsS0FBS25FLEVBQUUsQ0FBQyxFQUFFO2dCQUN4Qm1FLElBQUksQ0FBQytDLGdCQUFnQixDQUFDZ2UsUUFBUSxHQUFHO1lBQ3JDO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBU0Msb0JBQW9CL1QsS0FBSyxFQUFFOEMsYUFBYSxFQUFFUCxVQUFVLEVBQUUwTSxvQkFBb0I7SUFDL0UsTUFBTStFLG9CQUFvQixJQUFJQztJQUM5QixNQUFNSixjQUFjLENBQUM7SUFDckIsTUFBTUssZ0JBQWdCakYsdUJBQXVCLE9BQU87SUFDcERqUCxNQUFNb0QsT0FBTyxDQUFDLENBQUNyUTtRQUNYLE1BQU00Z0IsSUFBSSxDQUFDamUsVUFBVTNDLEtBQUtvaEIsTUFBTSxJQUFJcGhCLEtBQUtvaEIsTUFBTSxHQUFHLEtBQU1waEIsQ0FBQUEsS0FBS3FhLFFBQVEsR0FBRzhHLGdCQUFnQjtRQUN4RixNQUFNRSxnQkFBZ0J0UixjQUFjMlEsR0FBRyxDQUFDMWdCLEtBQUtuRSxFQUFFO1FBQy9DLE1BQU15bEIsWUFBWTtZQUNkcGlCLE9BQU9taUIsZUFBZW5pQjtZQUN0QkMsUUFBUWtpQixlQUFlbGlCO1lBQ3ZCLEdBQUdhLElBQUk7WUFDUCtCLGtCQUFrQjtnQkFDZHhELEdBQUd5QixLQUFLekMsUUFBUSxDQUFDZ0IsQ0FBQztnQkFDbEJDLEdBQUd3QixLQUFLekMsUUFBUSxDQUFDaUIsQ0FBQztZQUN0QjtRQUNKO1FBQ0EsSUFBSXdCLEtBQUt5Z0IsVUFBVSxFQUFFO1lBQ2pCYSxVQUFVYixVQUFVLEdBQUd6Z0IsS0FBS3lnQixVQUFVO1lBQ3RDSyxXQUFXLENBQUM5Z0IsS0FBS3lnQixVQUFVLENBQUMsR0FBRztRQUNuQztRQUNBN1MsT0FBTzJULGNBQWMsQ0FBQ0QsV0FBV3ZlLGlCQUFpQjtZQUM5Q3llLFlBQVk7WUFDWjdnQixPQUFPO2dCQUNIc1IsY0FBY29QLGVBQWUsQ0FBQ3RlLGdCQUFnQixFQUFFa1A7Z0JBQ2hEMk87WUFDSjtRQUNKO1FBQ0FLLGtCQUFrQlEsR0FBRyxDQUFDemhCLEtBQUtuRSxFQUFFLEVBQUV5bEI7SUFDbkM7SUFDQVQsNEJBQTRCSSxtQkFBbUJ6UixZQUFZc1I7SUFDM0QsT0FBT0c7QUFDWDtBQUNBLFNBQVN4RSxRQUFRaUUsR0FBRyxFQUFFaFMsVUFBVSxDQUFDLENBQUM7SUFDOUIsTUFBTSxFQUFFb0gsUUFBUSxFQUFFNVcsS0FBSyxFQUFFQyxNQUFNLEVBQUVnUyxPQUFPLEVBQUVDLE9BQU8sRUFBRXNRLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxpQkFBaUIsRUFBRUMsYUFBYSxFQUFFclMsVUFBVSxFQUFHLEdBQUdrUjtJQUMxSCxNQUFNb0IsbUJBQW1CcFQsUUFBUXFULE9BQU8sSUFBSSxDQUFDSCxxQkFBcUJDO0lBQ2xFLE1BQU1HLGdCQUFnQk4sVUFBVUM7SUFDaEMsSUFBSUssaUJBQWtCRixDQUFBQSxvQkFBb0IsQ0FBQ3BULFFBQVFxVCxPQUFPLEdBQUc7UUFDekQsTUFBTTlVLFFBQVE2SSxXQUFXM0ksTUFBTSxDQUFDLENBQUN2SztZQUM3QixNQUFNaU8sWUFBWW5DLFFBQVF1VCxrQkFBa0IsR0FBR3JmLEVBQUUxRCxLQUFLLElBQUkwRCxFQUFFekQsTUFBTSxHQUFHLENBQUN5RCxFQUFFMk4sTUFBTTtZQUM5RSxJQUFJN0IsUUFBUXpCLEtBQUssRUFBRW5CLFFBQVE7Z0JBQ3ZCLE9BQU8rRSxhQUFhbkMsUUFBUXpCLEtBQUssQ0FBQ2lCLElBQUksQ0FBQyxDQUFDZ1UsYUFBZUEsV0FBV3JtQixFQUFFLEtBQUsrRyxFQUFFL0csRUFBRTtZQUNqRjtZQUNBLE9BQU9nVjtRQUNYO1FBQ0EsTUFBTXNSLG1CQUFtQmxWLE1BQU1tVCxLQUFLLENBQUMsQ0FBQ3hkLElBQU1BLEVBQUUxRCxLQUFLLElBQUkwRCxFQUFFekQsTUFBTTtRQUMvRCxJQUFJOE4sTUFBTW5CLE1BQU0sR0FBRyxLQUFLcVcsa0JBQWtCO1lBQ3RDLE1BQU1waEIsU0FBUzBPLGVBQWV4QyxPQUFPdUM7WUFDckMsTUFBTSxFQUFFalIsQ0FBQyxFQUFFQyxDQUFDLEVBQUU1RCxJQUFJLEVBQUUsR0FBRzBXLHFCQUFxQnZRLFFBQVE3QixPQUFPQyxRQUFRdVAsUUFBUXlDLE9BQU8sSUFBSUEsU0FBU3pDLFFBQVEwQyxPQUFPLElBQUlBLFNBQVMxQyxRQUFRMkMsT0FBTyxJQUFJO1lBQzlJLE1BQU0rUSxnQkFBZ0J6bkIsaURBQVlBLENBQUMwbkIsU0FBUyxDQUFDOWpCLEdBQUdDLEdBQUc4akIsS0FBSyxDQUFDMW5CO1lBQ3pELElBQUksT0FBTzhULFFBQVFvRCxRQUFRLEtBQUssWUFBWXBELFFBQVFvRCxRQUFRLEdBQUcsR0FBRztnQkFDOUQ0UCxPQUFPbGlCLFNBQVMsQ0FBQ29TLGdCQUFnQitQLGFBQWFqVCxRQUFRb0QsUUFBUSxHQUFHc1E7WUFDckUsT0FDSztnQkFDRFYsT0FBT2xpQixTQUFTLENBQUNtaUIsYUFBYVM7WUFDbEM7WUFDQSxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNHLG9DQUFvQ0MsV0FBVyxFQUFFelMsYUFBYTtJQUNuRXlTLFlBQVluUyxPQUFPLENBQUMsQ0FBQ29TO1FBQ2pCLE1BQU16aUIsT0FBTytQLGNBQWMyUSxHQUFHLENBQUMrQixPQUFPNW1CLEVBQUU7UUFDeEMsSUFBSW1FLE1BQU07WUFDTitQLGNBQWMwUixHQUFHLENBQUN6aEIsS0FBS25FLEVBQUUsRUFBRTtnQkFDdkIsR0FBR21FLElBQUk7Z0JBQ1AsQ0FBQytDLGdCQUFnQixFQUFFL0MsSUFBSSxDQUFDK0MsZ0JBQWdCO2dCQUN4Q3NYLFVBQVVvSSxPQUFPcEksUUFBUTtZQUM3QjtRQUNKO0lBQ0o7SUFDQSxPQUFPLElBQUk2RyxJQUFJblI7QUFDbkI7QUFDQSxTQUFTMlMsb0NBQW9DQyxXQUFXLEVBQUV2YyxLQUFLO0lBQzNELE9BQU9BLE1BQU1nSCxHQUFHLENBQUMsQ0FBQzlHO1FBQ2QsTUFBTW1jLFNBQVNFLFlBQVl0YyxJQUFJLENBQUMsQ0FBQ29jLFNBQVdBLE9BQU81bUIsRUFBRSxLQUFLeUssRUFBRXpLLEVBQUU7UUFDOUQsSUFBSTRtQixRQUFRO1lBQ1JuYyxFQUFFK1QsUUFBUSxHQUFHb0ksT0FBT3BJLFFBQVE7UUFDaEM7UUFDQSxPQUFPL1Q7SUFDWDtBQUNKO0FBQ0EsU0FBU3NjLDhCQUE4QixFQUFFQyxZQUFZLEVBQUVDLFlBQVksRUFBRXBDLEdBQUcsRUFBRWUsR0FBRyxFQUFFO0lBQzNFLE1BQU0sRUFBRTFSLGFBQWEsRUFBRTNKLEtBQUssRUFBRWdXLGFBQWEsRUFBRUMsYUFBYSxFQUFFMEcsZUFBZSxFQUFFakssZUFBZSxFQUFFLEdBQUc0SDtJQUNqRyxJQUFJbUMsY0FBYy9XLFFBQVE7UUFDdEIsSUFBSWlYLGlCQUFpQjtZQUNqQnRCLElBQUk7Z0JBQUUxUixlQUFld1Msb0NBQW9DTSxjQUFjOVM7WUFBZTtRQUMxRjtRQUNBcU0sZ0JBQWdCeUc7SUFDcEI7SUFDQSxJQUFJQyxjQUFjaFgsUUFBUTtRQUN0QixJQUFJZ04saUJBQWlCO1lBQ2pCMkksSUFBSTtnQkFBRXJiLE9BQU9zYyxvQ0FBb0NJLGNBQWMxYztZQUFPO1FBQzFFO1FBQ0FpVyxnQkFBZ0J5RztJQUNwQjtBQUNKO0FBRUEsZ0VBQWdFO0FBQ2hFLE1BQU1FLE9BQU8sS0FBUTtBQUNyQixNQUFNQyx3QkFBd0I7SUFDMUJDLFFBQVFGO0lBQ1JHLFNBQVNIO0lBQ1RJLFFBQVFKO0lBQ1JLLFNBQVMsSUFBTTtJQUNmQyxhQUFhTjtJQUNiTyxhQUFhLElBQU87WUFBRWhsQixHQUFHO1lBQUdDLEdBQUc7WUFBRzVELE1BQU07UUFBRTtJQUMxQzZoQixTQUFTLElBQU07SUFDZitHLFdBQVdSO0lBQ1hTLFdBQVdUO0lBQ1hVLFNBQVMsQ0FBQ25tQixXQUFhQTtJQUN2Qm9tQixzQkFBc0IsQ0FBQ3BtQixXQUFhQTtJQUNwQ3FtQixzQkFBc0IsQ0FBQ3JtQixXQUFhQTtJQUNwQ3NtQixxQkFBcUI7QUFDekI7QUFDQSxNQUFNQyxhQUFhLENBQUMxbUIsSUFBTztRQUN2QnNrQixRQUFRdGtCLEVBQUVza0IsTUFBTTtRQUNoQkMsYUFBYXZrQixFQUFFdWtCLFdBQVc7SUFDOUI7QUFDQSxNQUFNb0Msb0JBQW9CO0lBQ3RCLE1BQU1ubkIsUUFBUUU7SUFDZCxNQUFNLEVBQUU0a0IsTUFBTSxFQUFFQyxXQUFXLEVBQUUsR0FBR2xsQixTQUFTcW5CLFlBQVlwcEIsb0RBQU9BO0lBQzVELE1BQU1zcEIsMEJBQTBCaHFCLDhDQUFPQSxDQUFDO1FBQ3BDLElBQUkybkIsZUFBZUQsUUFBUTtZQUN2QixPQUFPO2dCQUNId0IsUUFBUSxDQUFDeFUsVUFBWWdULE9BQU91QyxPQUFPLENBQUNyUyxnQkFBZ0IrUCxhQUFhalQsU0FBU29ELFdBQVc7Z0JBQ3JGcVIsU0FBUyxDQUFDelUsVUFBWWdULE9BQU91QyxPQUFPLENBQUNyUyxnQkFBZ0IrUCxhQUFhalQsU0FBU29ELFdBQVcsSUFBSTtnQkFDMUZzUixRQUFRLENBQUNjLFdBQVd4VixVQUFZZ1QsT0FBT3lDLE9BQU8sQ0FBQ3ZTLGdCQUFnQitQLGFBQWFqVCxTQUFTb0QsV0FBV29TO2dCQUNoR2IsU0FBUyxJQUFNem1CLE1BQU1HLFFBQVEsR0FBR3lDLFNBQVMsQ0FBQyxFQUFFO2dCQUM1QzhqQixhQUFhLENBQUM5akIsV0FBV2tQO29CQUNyQixNQUFNLENBQUNuUSxHQUFHQyxHQUFHNUQsS0FBSyxHQUFHZ0MsTUFBTUcsUUFBUSxHQUFHeUMsU0FBUztvQkFDL0MsTUFBTTRpQixnQkFBZ0J6bkIsaURBQVlBLENBQzdCMG5CLFNBQVMsQ0FBQzdpQixVQUFVakIsQ0FBQyxJQUFJQSxHQUFHaUIsVUFBVWhCLENBQUMsSUFBSUEsR0FDM0M4akIsS0FBSyxDQUFDOWlCLFVBQVU1RSxJQUFJLElBQUlBO29CQUM3QjhtQixPQUFPbGlCLFNBQVMsQ0FBQ29TLGdCQUFnQitQLGFBQWFqVCxTQUFTb0QsV0FBV3NRO2dCQUN0RTtnQkFDQW1CLGFBQWE7b0JBQ1QsTUFBTSxDQUFDaGxCLEdBQUdDLEdBQUc1RCxLQUFLLEdBQUdnQyxNQUFNRyxRQUFRLEdBQUd5QyxTQUFTO29CQUMvQyxPQUFPO3dCQUFFakI7d0JBQUdDO3dCQUFHNUQ7b0JBQUs7Z0JBQ3hCO2dCQUNBNmhCLFNBQVMsQ0FBQy9OLFVBQVkrTixRQUFRN2YsTUFBTUcsUUFBUSxFQUFFMlI7Z0JBQzlDOFUsV0FBVyxDQUFDamxCLEdBQUdDLEdBQUdrUTtvQkFDZCxNQUFNLEVBQUV4UCxLQUFLLEVBQUVDLE1BQU0sRUFBRWlTLE9BQU8sRUFBRSxHQUFHeFUsTUFBTUcsUUFBUTtvQkFDakQsTUFBTXFuQixXQUFXLE9BQU8xVixTQUFTOVQsU0FBUyxjQUFjOFQsUUFBUTlULElBQUksR0FBR3dXO29CQUN2RSxNQUFNdkssVUFBVTNILFFBQVEsSUFBSVgsSUFBSTZsQjtvQkFDaEMsTUFBTXJkLFVBQVU1SCxTQUFTLElBQUlYLElBQUk0bEI7b0JBQ2pDLE1BQU01a0IsWUFBWTdFLGlEQUFZQSxDQUFDMG5CLFNBQVMsQ0FBQ3hiLFNBQVNFLFNBQVN1YixLQUFLLENBQUM4QjtvQkFDakUxQyxPQUFPbGlCLFNBQVMsQ0FBQ29TLGdCQUFnQitQLGFBQWFqVCxTQUFTb0QsV0FBV3RTO2dCQUN0RTtnQkFDQWlrQixXQUFXLENBQUMxaUIsUUFBUTJOO29CQUNoQixNQUFNLEVBQUV4UCxLQUFLLEVBQUVDLE1BQU0sRUFBRWdTLE9BQU8sRUFBRUMsT0FBTyxFQUFFLEdBQUd4VSxNQUFNRyxRQUFRO29CQUMxRCxNQUFNLEVBQUV3QixDQUFDLEVBQUVDLENBQUMsRUFBRTVELElBQUksRUFBRSxHQUFHMFcscUJBQXFCdlEsUUFBUTdCLE9BQU9DLFFBQVFnUyxTQUFTQyxTQUFTMUMsU0FBUzJDLFdBQVc7b0JBQ3pHLE1BQU03UixZQUFZN0UsaURBQVlBLENBQUMwbkIsU0FBUyxDQUFDOWpCLEdBQUdDLEdBQUc4akIsS0FBSyxDQUFDMW5CO29CQUNyRDhtQixPQUFPbGlCLFNBQVMsQ0FBQ29TLGdCQUFnQitQLGFBQWFqVCxTQUFTb0QsV0FBV3RTO2dCQUN0RTtnQkFDQSwwQ0FBMEM7Z0JBQzFDa2tCLFNBQVMsQ0FBQ25tQjtvQkFDTixNQUFNLEVBQUVpQyxTQUFTLEVBQUUwUCxVQUFVLEVBQUVxTixRQUFRLEVBQUUsR0FBRzNmLE1BQU1HLFFBQVE7b0JBQzFEdUcsUUFBUUMsSUFBSSxDQUFDO29CQUNiLE9BQU91TCxxQkFBcUJ2UixVQUFVaUMsV0FBVzBQLFlBQVlxTjtnQkFDakU7Z0JBQ0FvSCxzQkFBc0IsQ0FBQ3BtQjtvQkFDbkIsTUFBTSxFQUFFaUMsU0FBUyxFQUFFMFAsVUFBVSxFQUFFcU4sUUFBUSxFQUFFN0csT0FBTyxFQUFFLEdBQUc5WSxNQUFNRyxRQUFRO29CQUNuRSxJQUFJLENBQUMyWSxTQUFTO3dCQUNWLE9BQU9uWTtvQkFDWDtvQkFDQSxNQUFNLEVBQUVnQixHQUFHOGxCLElBQUksRUFBRTdsQixHQUFHOGxCLElBQUksRUFBRSxHQUFHNU8sUUFBUVcscUJBQXFCO29CQUMxRCxNQUFNa08sbUJBQW1CO3dCQUNyQmhtQixHQUFHaEIsU0FBU2dCLENBQUMsR0FBRzhsQjt3QkFDaEI3bEIsR0FBR2pCLFNBQVNpQixDQUFDLEdBQUc4bEI7b0JBQ3BCO29CQUNBLE9BQU94VixxQkFBcUJ5VixrQkFBa0Iva0IsV0FBVzBQLFlBQVlxTjtnQkFDekU7Z0JBQ0FxSCxzQkFBc0IsQ0FBQ3JtQjtvQkFDbkIsTUFBTSxFQUFFaUMsU0FBUyxFQUFFa1csT0FBTyxFQUFFLEdBQUc5WSxNQUFNRyxRQUFRO29CQUM3QyxJQUFJLENBQUMyWSxTQUFTO3dCQUNWLE9BQU9uWTtvQkFDWDtvQkFDQSxNQUFNLEVBQUVnQixHQUFHOGxCLElBQUksRUFBRTdsQixHQUFHOGxCLElBQUksRUFBRSxHQUFHNU8sUUFBUVcscUJBQXFCO29CQUMxRCxNQUFNbU8sbUJBQW1CbFYscUJBQXFCL1IsVUFBVWlDO29CQUN4RCxPQUFPO3dCQUNIakIsR0FBR2ltQixpQkFBaUJqbUIsQ0FBQyxHQUFHOGxCO3dCQUN4QjdsQixHQUFHZ21CLGlCQUFpQmhtQixDQUFDLEdBQUc4bEI7b0JBQzVCO2dCQUNKO2dCQUNBVCxxQkFBcUI7WUFDekI7UUFDSjtRQUNBLE9BQU9aO0lBQ1gsR0FBRztRQUFDdkI7UUFBUUM7S0FBWTtJQUN4QixPQUFPcUM7QUFDWDtBQUVBLCtEQUErRCxHQUMvRCxTQUFTUztJQUNMLE1BQU1DLGlCQUFpQlg7SUFDdkIsTUFBTW5uQixRQUFRRTtJQUNkLE1BQU1nWixXQUFXeGIsa0RBQVdBLENBQUM7UUFDekIsT0FBT3NDLE1BQ0ZHLFFBQVEsR0FDUitZLFFBQVEsR0FDUjFJLEdBQUcsQ0FBQyxDQUFDeEssSUFBTztnQkFBRSxHQUFHQSxDQUFDO1lBQUM7SUFDNUIsR0FBRyxFQUFFO0lBQ0wsTUFBTStoQixVQUFVcnFCLGtEQUFXQSxDQUFDLENBQUN1QjtRQUN6QixPQUFPZSxNQUFNRyxRQUFRLEdBQUdnVCxhQUFhLENBQUMyUSxHQUFHLENBQUM3a0I7SUFDOUMsR0FBRyxFQUFFO0lBQ0wsTUFBTStvQixXQUFXdHFCLGtEQUFXQSxDQUFDO1FBQ3pCLE1BQU0sRUFBRThMLFFBQVEsRUFBRSxFQUFFLEdBQUd4SixNQUFNRyxRQUFRO1FBQ3JDLE9BQU9xSixNQUFNZ0gsR0FBRyxDQUFDLENBQUM5RyxJQUFPO2dCQUFFLEdBQUdBLENBQUM7WUFBQztJQUNwQyxHQUFHLEVBQUU7SUFDTCxNQUFNdWUsVUFBVXZxQixrREFBV0EsQ0FBQyxDQUFDdUI7UUFDekIsTUFBTSxFQUFFdUssUUFBUSxFQUFFLEVBQUUsR0FBR3hKLE1BQU1HLFFBQVE7UUFDckMsT0FBT3FKLE1BQU1DLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxFQUFFekssRUFBRSxLQUFLQTtJQUN0QyxHQUFHLEVBQUU7SUFDTCxNQUFNbWYsV0FBVzFnQixrREFBV0EsQ0FBQyxDQUFDd3FCO1FBQzFCLE1BQU0sRUFBRWhQLFFBQVEsRUFBRWtGLFFBQVEsRUFBRStILGVBQWUsRUFBRTNHLGFBQWEsRUFBRSxHQUFHeGYsTUFBTUcsUUFBUTtRQUM3RSxNQUFNa1EsUUFBUTZJO1FBQ2QsTUFBTWlQLFlBQVksT0FBT0QsWUFBWSxhQUFhQSxRQUFRN1gsU0FBUzZYO1FBQ25FLElBQUkvQixpQkFBaUI7WUFDakIvSCxTQUFTK0o7UUFDYixPQUNLLElBQUkzSSxlQUFlO1lBQ3BCLE1BQU00SSxVQUFVRCxVQUFValosTUFBTSxLQUFLLElBQy9CbUIsTUFBTUcsR0FBRyxDQUFDLENBQUNwTixPQUFVO29CQUFFakUsTUFBTTtvQkFBVUYsSUFBSW1FLEtBQUtuRSxFQUFFO2dCQUFDLE1BQ25Ea3BCLFVBQVUzWCxHQUFHLENBQUMsQ0FBQ3BOLE9BQVU7b0JBQUVvZixNQUFNcGY7b0JBQU1qRSxNQUFNO2dCQUFRO1lBQzNEcWdCLGNBQWM0STtRQUNsQjtJQUNKLEdBQUcsRUFBRTtJQUNMLE1BQU1qTSxXQUFXemUsa0RBQVdBLENBQUMsQ0FBQ3dxQjtRQUMxQixNQUFNLEVBQUUxZSxRQUFRLEVBQUUsRUFBRTJTLFFBQVEsRUFBRUQsZUFBZSxFQUFFdUQsYUFBYSxFQUFFLEdBQUd6ZixNQUFNRyxRQUFRO1FBQy9FLE1BQU1rb0IsWUFBWSxPQUFPSCxZQUFZLGFBQWFBLFFBQVExZSxTQUFTMGU7UUFDbkUsSUFBSWhNLGlCQUFpQjtZQUNqQkMsU0FBU2tNO1FBQ2IsT0FDSyxJQUFJNUksZUFBZTtZQUNwQixNQUFNMkksVUFBVUMsVUFBVW5aLE1BQU0sS0FBSyxJQUMvQjFGLE1BQU1nSCxHQUFHLENBQUMsQ0FBQ2xSLE9BQVU7b0JBQUVILE1BQU07b0JBQVVGLElBQUlLLEtBQUtMLEVBQUU7Z0JBQUMsTUFDbkRvcEIsVUFBVTdYLEdBQUcsQ0FBQyxDQUFDbFIsT0FBVTtvQkFBRWtqQixNQUFNbGpCO29CQUFNSCxNQUFNO2dCQUFRO1lBQzNEc2dCLGNBQWMySTtRQUNsQjtJQUNKLEdBQUcsRUFBRTtJQUNMLE1BQU1FLFdBQVc1cUIsa0RBQVdBLENBQUMsQ0FBQ3dxQjtRQUMxQixNQUFNN1gsUUFBUStSLE1BQU1DLE9BQU8sQ0FBQzZGLFdBQVdBLFVBQVU7WUFBQ0E7U0FBUTtRQUMxRCxNQUFNLEVBQUVoUCxRQUFRLEVBQUVrRixRQUFRLEVBQUUrSCxlQUFlLEVBQUUzRyxhQUFhLEVBQUUsR0FBR3hmLE1BQU1HLFFBQVE7UUFDN0UsSUFBSWdtQixpQkFBaUI7WUFDakIsTUFBTW9DLGVBQWVyUDtZQUNyQixNQUFNaVAsWUFBWTttQkFBSUk7bUJBQWlCbFk7YUFBTTtZQUM3QytOLFNBQVMrSjtRQUNiLE9BQ0ssSUFBSTNJLGVBQWU7WUFDcEIsTUFBTTRJLFVBQVUvWCxNQUFNRyxHQUFHLENBQUMsQ0FBQ3BOLE9BQVU7b0JBQUVvZixNQUFNcGY7b0JBQU1qRSxNQUFNO2dCQUFNO1lBQy9EcWdCLGNBQWM0STtRQUNsQjtJQUNKLEdBQUcsRUFBRTtJQUNMLE1BQU1JLFdBQVc5cUIsa0RBQVdBLENBQUMsQ0FBQ3dxQjtRQUMxQixNQUFNRyxZQUFZakcsTUFBTUMsT0FBTyxDQUFDNkYsV0FBV0EsVUFBVTtZQUFDQTtTQUFRO1FBQzlELE1BQU0sRUFBRTFlLFFBQVEsRUFBRSxFQUFFMlMsUUFBUSxFQUFFRCxlQUFlLEVBQUV1RCxhQUFhLEVBQUUsR0FBR3pmLE1BQU1HLFFBQVE7UUFDL0UsSUFBSStiLGlCQUFpQjtZQUNqQkMsU0FBUzttQkFBSTNTO21CQUFVNmU7YUFBVTtRQUNyQyxPQUNLLElBQUk1SSxlQUFlO1lBQ3BCLE1BQU0ySSxVQUFVQyxVQUFVN1gsR0FBRyxDQUFDLENBQUNsUixPQUFVO29CQUFFa2pCLE1BQU1sakI7b0JBQU1ILE1BQU07Z0JBQU07WUFDbkVzZ0IsY0FBYzJJO1FBQ2xCO0lBQ0osR0FBRyxFQUFFO0lBQ0wsTUFBTUssV0FBVy9xQixrREFBV0EsQ0FBQztRQUN6QixNQUFNLEVBQUV3YixRQUFRLEVBQUUxUCxRQUFRLEVBQUUsRUFBRTVHLFNBQVMsRUFBRSxHQUFHNUMsTUFBTUcsUUFBUTtRQUMxRCxNQUFNLENBQUN3QixHQUFHQyxHQUFHNUQsS0FBSyxHQUFHNEU7UUFDckIsT0FBTztZQUNIeU4sT0FBTzZJLFdBQVcxSSxHQUFHLENBQUMsQ0FBQ3hLLElBQU87b0JBQUUsR0FBR0EsQ0FBQztnQkFBQztZQUNyQ3dELE9BQU9BLE1BQU1nSCxHQUFHLENBQUMsQ0FBQzlHLElBQU87b0JBQUUsR0FBR0EsQ0FBQztnQkFBQztZQUNoQ2dmLFVBQVU7Z0JBQ04vbUI7Z0JBQ0FDO2dCQUNBNUQ7WUFDSjtRQUNKO0lBQ0osR0FBRyxFQUFFO0lBQ0wsTUFBTTJxQixpQkFBaUJqckIsa0RBQVdBLENBQUMsQ0FBQyxFQUFFMlMsT0FBT3VZLFlBQVksRUFBRXBmLE9BQU9xZixZQUFZLEVBQUU7UUFDNUUsTUFBTSxFQUFFMVYsYUFBYSxFQUFFK0YsUUFBUSxFQUFFMVAsS0FBSyxFQUFFMmMsZUFBZSxFQUFFakssZUFBZSxFQUFFNkQsYUFBYSxFQUFFQyxhQUFhLEVBQUVSLGFBQWEsRUFBRUMsYUFBYSxFQUFHLEdBQUd6ZixNQUFNRyxRQUFRO1FBQ3hKLE1BQU1rVSxVQUFVLENBQUN1VSxnQkFBZ0IsRUFBRSxFQUFFcFksR0FBRyxDQUFDLENBQUNwTixPQUFTQSxLQUFLbkUsRUFBRTtRQUMxRCxNQUFNNnBCLFVBQVUsQ0FBQ0QsZ0JBQWdCLEVBQUUsRUFBRXJZLEdBQUcsQ0FBQyxDQUFDbFIsT0FBU0EsS0FBS0wsRUFBRTtRQUMxRCxNQUFNOHBCLGdCQUFnQjdQLFdBQVdySyxNQUFNLENBQUMsQ0FBQ0MsS0FBSzFMO1lBQzFDLE1BQU00bEIsWUFBWSxDQUFDM1UsUUFBUWxOLFFBQVEsQ0FBQy9ELEtBQUtuRSxFQUFFLEtBQUttRSxLQUFLeWdCLFVBQVUsSUFBSS9VLElBQUlyRixJQUFJLENBQUMsQ0FBQ3pELElBQU1BLEVBQUUvRyxFQUFFLEtBQUttRSxLQUFLeWdCLFVBQVU7WUFDM0csTUFBTW9GLFlBQVksT0FBTzdsQixLQUFLNmxCLFNBQVMsS0FBSyxZQUFZN2xCLEtBQUs2bEIsU0FBUyxHQUFHO1lBQ3pFLElBQUlBLGFBQWM1VSxDQUFBQSxRQUFRbE4sUUFBUSxDQUFDL0QsS0FBS25FLEVBQUUsS0FBSytwQixTQUFRLEdBQUk7Z0JBQ3ZEbGEsSUFBSXFGLElBQUksQ0FBQy9RO1lBQ2I7WUFDQSxPQUFPMEw7UUFDWCxHQUFHLEVBQUU7UUFDTCxNQUFNb2EsaUJBQWlCMWYsTUFBTStHLE1BQU0sQ0FBQyxDQUFDN0csSUFBTyxPQUFPQSxFQUFFdWYsU0FBUyxLQUFLLFlBQVl2ZixFQUFFdWYsU0FBUyxHQUFHO1FBQzdGLE1BQU1FLGtCQUFrQkQsZUFBZTNZLE1BQU0sQ0FBQyxDQUFDN0csSUFBTW9mLFFBQVEzaEIsUUFBUSxDQUFDdUMsRUFBRXpLLEVBQUU7UUFDMUUsSUFBSThwQixpQkFBaUJJLGlCQUFpQjtZQUNsQyxNQUFNQyxpQkFBaUJoVixrQkFBa0IyVSxlQUFlRztZQUN4RCxNQUFNRyxnQkFBZ0I7bUJBQUlGO21CQUFvQkM7YUFBZTtZQUM3RCxNQUFNRSxrQkFBa0JELGNBQWN4YSxNQUFNLENBQUMsQ0FBQ0MsS0FBS3hQO2dCQUMvQyxJQUFJLENBQUN3UCxJQUFJM0gsUUFBUSxDQUFDN0gsS0FBS0wsRUFBRSxHQUFHO29CQUN4QjZQLElBQUlxRixJQUFJLENBQUM3VSxLQUFLTCxFQUFFO2dCQUNwQjtnQkFDQSxPQUFPNlA7WUFDWCxHQUFHLEVBQUU7WUFDTCxJQUFJb04sbUJBQW1CaUssaUJBQWlCO2dCQUNwQyxJQUFJakssaUJBQWlCO29CQUNqQmxjLE1BQU1JLFFBQVEsQ0FBQzt3QkFDWG9KLE9BQU9BLE1BQU0rRyxNQUFNLENBQUMsQ0FBQzdHLElBQU0sQ0FBQzRmLGdCQUFnQm5pQixRQUFRLENBQUN1QyxFQUFFekssRUFBRTtvQkFDN0Q7Z0JBQ0o7Z0JBQ0EsSUFBSWtuQixpQkFBaUI7b0JBQ2pCNEMsY0FBY3RWLE9BQU8sQ0FBQyxDQUFDclE7d0JBQ25CK1AsY0FBY2tRLE1BQU0sQ0FBQ2pnQixLQUFLbkUsRUFBRTtvQkFDaEM7b0JBQ0FlLE1BQU1JLFFBQVEsQ0FBQzt3QkFDWCtTLGVBQWUsSUFBSW1SLElBQUluUjtvQkFDM0I7Z0JBQ0o7WUFDSjtZQUNBLElBQUltVyxnQkFBZ0JwYSxNQUFNLEdBQUcsR0FBRztnQkFDNUI4USxnQkFBZ0JxSjtnQkFDaEIsSUFBSTVKLGVBQWU7b0JBQ2ZBLGNBQWM2SixnQkFBZ0I5WSxHQUFHLENBQUMsQ0FBQ3ZSLEtBQVE7NEJBQ3ZDQTs0QkFDQUUsTUFBTTt3QkFDVjtnQkFDSjtZQUNKO1lBQ0EsSUFBSTRwQixjQUFjN1osTUFBTSxHQUFHLEdBQUc7Z0JBQzFCNlEsZ0JBQWdCZ0o7Z0JBQ2hCLElBQUl2SixlQUFlO29CQUNmLE1BQU1vRyxjQUFjbUQsY0FBY3ZZLEdBQUcsQ0FBQyxDQUFDeEssSUFBTzs0QkFBRS9HLElBQUkrRyxFQUFFL0csRUFBRTs0QkFBRUUsTUFBTTt3QkFBUztvQkFDekVxZ0IsY0FBY29HO2dCQUNsQjtZQUNKO1FBQ0o7SUFDSixHQUFHLEVBQUU7SUFDTCxNQUFNMkQsY0FBYzdyQixrREFBV0EsQ0FBQyxDQUFDOHJCO1FBQzdCLE1BQU1DLFNBQVM1akIsYUFBYTJqQjtRQUM1QixNQUFNcG1CLE9BQU9xbUIsU0FBUyxPQUFPenBCLE1BQU1HLFFBQVEsR0FBR2dULGFBQWEsQ0FBQzJRLEdBQUcsQ0FBQzBGLFdBQVd2cUIsRUFBRTtRQUM3RSxNQUFNMlUsV0FBVzZWLFNBQVNELGFBQWF0a0IsV0FBVzlCO1FBQ2xELE9BQU87WUFBQ3dRO1lBQVV4UTtZQUFNcW1CO1NBQU87SUFDbkMsR0FBRyxFQUFFO0lBQ0wsTUFBTUMsdUJBQXVCaHNCLGtEQUFXQSxDQUFDLENBQUM4ckIsWUFBWW5XLFlBQVksSUFBSSxFQUFFaEQ7UUFDcEUsTUFBTSxDQUFDdUQsVUFBVXhRLE1BQU1xbUIsT0FBTyxHQUFHRixZQUFZQztRQUM3QyxJQUFJLENBQUM1VixVQUFVO1lBQ1gsT0FBTyxFQUFFO1FBQ2I7UUFDQSxPQUFPLENBQUN2RCxTQUFTclEsTUFBTUcsUUFBUSxHQUFHK1ksUUFBUSxFQUFDLEVBQUczSSxNQUFNLENBQUMsQ0FBQ3ZLO1lBQ2xELElBQUksQ0FBQ3lqQixVQUFXempCLENBQUFBLEVBQUUvRyxFQUFFLEtBQUttRSxLQUFLbkUsRUFBRSxJQUFJLENBQUMrRyxFQUFFYixnQkFBZ0IsR0FBRztnQkFDdEQsT0FBTztZQUNYO1lBQ0EsTUFBTXdrQixlQUFlemtCLFdBQVdjO1lBQ2hDLE1BQU02TixrQkFBa0J0TyxtQkFBbUJva0IsY0FBYy9WO1lBQ3pELE1BQU1HLG1CQUFtQlYsYUFBYVEsa0JBQWtCO1lBQ3hELE9BQU9FLG9CQUFvQkYsbUJBQW1CRCxTQUFTdFIsS0FBSyxHQUFHc1IsU0FBU3JSLE1BQU07UUFDbEY7SUFDSixHQUFHLEVBQUU7SUFDTCxNQUFNcW5CLHFCQUFxQmxzQixrREFBV0EsQ0FBQyxDQUFDOHJCLFlBQVl4VixNQUFNWCxZQUFZLElBQUk7UUFDdEUsTUFBTSxDQUFDTyxTQUFTLEdBQUcyVixZQUFZQztRQUMvQixJQUFJLENBQUM1VixVQUFVO1lBQ1gsT0FBTztRQUNYO1FBQ0EsTUFBTUMsa0JBQWtCdE8sbUJBQW1CcU8sVUFBVUk7UUFDckQsTUFBTUQsbUJBQW1CVixhQUFhUSxrQkFBa0I7UUFDeEQsT0FBT0Usb0JBQW9CRixtQkFBbUJELFNBQVN0UixLQUFLLEdBQUdzUixTQUFTclIsTUFBTTtJQUNsRixHQUFHLEVBQUU7SUFDTCxPQUFPbkYsOENBQU9BLENBQUM7UUFDWCxPQUFPO1lBQ0gsR0FBRzBxQixjQUFjO1lBQ2pCNU87WUFDQTZPO1lBQ0FDO1lBQ0FDO1lBQ0E3SjtZQUNBakM7WUFDQW1NO1lBQ0FFO1lBQ0FDO1lBQ0FFO1lBQ0FlO1lBQ0FFO1FBQ0o7SUFDSixHQUFHO1FBQ0M5QjtRQUNBNU87UUFDQTZPO1FBQ0FDO1FBQ0FDO1FBQ0E3SjtRQUNBakM7UUFDQW1NO1FBQ0FFO1FBQ0FDO1FBQ0FFO1FBQ0FlO1FBQ0FFO0tBQ0g7QUFDTDtBQUVBLE1BQU1DLG1CQUFtQjtJQUFFbEksNEJBQTRCO0FBQU07QUFDN0QsSUFBSW1JLHNCQUFzQixDQUFDLEVBQUVDLGFBQWEsRUFBRUMscUJBQXFCLEVBQUU7SUFDL0QsTUFBTWhxQixRQUFRRTtJQUNkLE1BQU0sRUFBRXlvQixjQUFjLEVBQUUsR0FBR2Q7SUFDM0IsTUFBTW9DLG1CQUFtQnhJLFlBQVlzSSxlQUFlRjtJQUNwRCxNQUFNSywyQkFBMkJ6SSxZQUFZdUk7SUFDN0N4c0IsZ0RBQVNBLENBQUM7UUFDTixJQUFJeXNCLGtCQUFrQjtZQUNsQixNQUFNLEVBQUV6Z0IsS0FBSyxFQUFFMFAsUUFBUSxFQUFFLEdBQUdsWixNQUFNRyxRQUFRO1lBQzFDLE1BQU1xZCxnQkFBZ0J0RSxXQUFXM0ksTUFBTSxDQUFDLENBQUNuTixPQUFTQSxLQUFLcWEsUUFBUTtZQUMvRCxNQUFNQyxnQkFBZ0JsVSxNQUFNK0csTUFBTSxDQUFDLENBQUNqUixPQUFTQSxLQUFLbWUsUUFBUTtZQUMxRGtMLGVBQWU7Z0JBQUV0WSxPQUFPbU47Z0JBQWVoVSxPQUFPa1U7WUFBYztZQUM1RDFkLE1BQU1JLFFBQVEsQ0FBQztnQkFBRStwQixzQkFBc0I7WUFBTTtRQUNqRDtJQUNKLEdBQUc7UUFBQ0Y7S0FBaUI7SUFDckJ6c0IsZ0RBQVNBLENBQUM7UUFDTndDLE1BQU1JLFFBQVEsQ0FBQztZQUFFZ3FCLHNCQUFzQkY7UUFBeUI7SUFDcEUsR0FBRztRQUFDQTtLQUF5QjtBQUNqQztBQUVBLFNBQVNHLGlCQUFpQkMsWUFBWTtJQUNsQyxNQUFNdHFCLFFBQVFFO0lBQ2QxQyxnREFBU0EsQ0FBQztRQUNOLElBQUkrc0I7UUFDSixNQUFNQyxtQkFBbUI7WUFDckIsSUFBSSxDQUFDRixhQUFhN25CLE9BQU8sRUFBRTtnQkFDdkI7WUFDSjtZQUNBLE1BQU04TCxPQUFPcEwsY0FBY21uQixhQUFhN25CLE9BQU87WUFDL0MsSUFBSThMLEtBQUtoTSxNQUFNLEtBQUssS0FBS2dNLEtBQUtqTSxLQUFLLEtBQUssR0FBRztnQkFDdkN0QyxNQUFNRyxRQUFRLEdBQUcwYixPQUFPLEdBQUcsT0FBT3JkLGFBQWEsQ0FBQyxXQUFXO1lBQy9EO1lBQ0F3QixNQUFNSSxRQUFRLENBQUM7Z0JBQUVrQyxPQUFPaU0sS0FBS2pNLEtBQUssSUFBSTtnQkFBS0MsUUFBUWdNLEtBQUtoTSxNQUFNLElBQUk7WUFBSTtRQUMxRTtRQUNBaW9CO1FBQ0EvbEIsT0FBT21XLGdCQUFnQixDQUFDLFVBQVU0UDtRQUNsQyxJQUFJRixhQUFhN25CLE9BQU8sRUFBRTtZQUN0QjhuQixpQkFBaUIsSUFBSUUsZUFBZSxJQUFNRDtZQUMxQ0QsZUFBZUcsT0FBTyxDQUFDSixhQUFhN25CLE9BQU87UUFDL0M7UUFDQSxPQUFPO1lBQ0hnQyxPQUFPa1csbUJBQW1CLENBQUMsVUFBVTZQO1lBQ3JDLElBQUlELGtCQUFrQkQsYUFBYTduQixPQUFPLEVBQUU7Z0JBQ3hDOG5CLGVBQWVJLFNBQVMsQ0FBQ0wsYUFBYTduQixPQUFPO1lBQ2pEO1FBQ0o7SUFDSixHQUFHLEVBQUU7QUFDVDtBQUVBLE1BQU1tb0IsaUJBQWlCO0lBQ25CanFCLFVBQVU7SUFDVjJCLE9BQU87SUFDUEMsUUFBUTtJQUNSeUYsS0FBSztJQUNMRCxNQUFNO0FBQ1Y7QUFFQSxvREFBb0QsR0FDcEQsTUFBTThpQixjQUFjLENBQUNDLGNBQWNDLGlCQUFtQkQsYUFBYW5wQixDQUFDLEtBQUtvcEIsZUFBZXBwQixDQUFDLElBQUltcEIsYUFBYWxwQixDQUFDLEtBQUttcEIsZUFBZW5wQixDQUFDLElBQUlrcEIsYUFBYTlzQixJQUFJLEtBQUsrc0IsZUFBZXRILENBQUM7QUFDMUssTUFBTXVILHVCQUF1QixDQUFDRCxpQkFBb0I7UUFDOUNwcEIsR0FBR29wQixlQUFlcHBCLENBQUM7UUFDbkJDLEdBQUdtcEIsZUFBZW5wQixDQUFDO1FBQ25CNUQsTUFBTStzQixlQUFldEgsQ0FBQztJQUMxQjtBQUNBLE1BQU13SCxxQkFBcUIsQ0FBQ3BrQixPQUFPaEcsWUFBY2dHLE1BQU1yRixNQUFNLENBQUM4RixPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUV6RyxVQUFVLENBQUM7QUFDckYsTUFBTXFxQixrQkFBa0IsQ0FBQ0MsV0FBV0MsYUFBZUEsZUFBZSxLQUFLaEosTUFBTUMsT0FBTyxDQUFDOEksY0FBY0EsVUFBVWhrQixRQUFRLENBQUM7QUFDdEgsTUFBTWtrQixhQUFhLENBQUN4a0I7SUFDaEIsTUFBTXlrQixTQUFTemtCLE1BQU02YixPQUFPLElBQUl6YSxZQUFZLEtBQUs7SUFDakQsT0FBTyxDQUFDcEIsTUFBTTBrQixNQUFNLEdBQUkxa0IsQ0FBQUEsTUFBTTJrQixTQUFTLEtBQUssSUFBSSxPQUFPM2tCLE1BQU0ya0IsU0FBUyxHQUFHLElBQUksS0FBSSxJQUFLRjtBQUMxRjtBQUNBLE1BQU1HLGFBQWEsQ0FBQ2pyQixJQUFPO1FBQ3ZCc2tCLFFBQVF0a0IsRUFBRXNrQixNQUFNO1FBQ2hCQyxhQUFhdmtCLEVBQUV1a0IsV0FBVztRQUMxQjJHLGVBQWVsckIsRUFBRWtyQixhQUFhO1FBQzlCanJCLHFCQUFxQkQsRUFBRUMsbUJBQW1CO0lBQzlDO0FBQ0EsTUFBTWtyQixXQUFXLENBQUMsRUFBRUMsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLFNBQVMsRUFBRUMsaUJBQWlCLEVBQUVDLGVBQWUsSUFBSSxFQUFFQyxjQUFjLElBQUksRUFBRUMsY0FBYyxLQUFLLEVBQUVDLG1CQUFtQixHQUFHLEVBQUVDLGtCQUFrQnhoQixnQkFBZ0J5aEIsSUFBSSxFQUFFQyxvQkFBb0IsSUFBSSxFQUFFNU0sa0JBQWtCLEVBQUV5TCxZQUFZLElBQUksRUFBRW9CLGVBQWUsRUFBRTNNLGVBQWUsRUFBRXJMLE9BQU8sRUFBRUMsT0FBTyxFQUFFZ1kscUJBQXFCLEVBQUVDLG1CQUFtQixJQUFJLEVBQUU3ckIsUUFBUSxFQUFFOHJCLGdCQUFnQixFQUFFMVIsY0FBYyxFQUFHO0lBQ2xaLE1BQU0yUixVQUFVcnZCLDZDQUFNQTtJQUN0QixNQUFNMEMsUUFBUUU7SUFDZCxNQUFNMHNCLHFCQUFxQnR2Qiw2Q0FBTUEsQ0FBQztJQUNsQyxNQUFNdXZCLDZCQUE2QnZ2Qiw2Q0FBTUEsQ0FBQztJQUMxQyxNQUFNd3ZCLFdBQVd4dkIsNkNBQU1BLENBQUM7SUFDeEIsTUFBTXl2QixnQkFBZ0J6dkIsNkNBQU1BLENBQUM7UUFBRXFFLEdBQUc7UUFBR0MsR0FBRztRQUFHNUQsTUFBTTtJQUFFO0lBQ25ELE1BQU0sRUFBRThtQixNQUFNLEVBQUVDLFdBQVcsRUFBRTJHLGFBQWEsRUFBRWpyQixtQkFBbUIsRUFBRSxHQUFHWixTQUFTNHJCLFlBQVkzdEIsb0RBQU9BO0lBQ2hHLE1BQU1rdkIsMkJBQTJCdkwsWUFBWStLO0lBQzdDLE1BQU1TLGNBQWMzdkIsNkNBQU1BLENBQUM7SUFDM0IsTUFBTTR2QixpQkFBaUI1dkIsNkNBQU1BLENBQUM7SUFDOUIsTUFBTTZ2QixtQkFBbUI3dkIsNkNBQU1BO0lBQy9CK3NCLGlCQUFpQnlDO0lBQ2pCdHZCLGdEQUFTQSxDQUFDO1FBQ04sSUFBSXN2QixTQUFTcnFCLE9BQU8sRUFBRTtZQUNsQixNQUFNMnFCLE9BQU9OLFNBQVNycUIsT0FBTyxDQUFDZ1gscUJBQXFCO1lBQ25ELE1BQU00VCxpQkFBaUJydkIsNkNBQUlBLEdBQUdzdkIsV0FBVyxDQUFDO2dCQUFDL1k7Z0JBQVNDO2FBQVEsRUFBRW9MLGVBQWUsQ0FBQ0E7WUFDOUUsTUFBTTNLLFlBQVloWCx3REFBTUEsQ0FBQzZ1QixTQUFTcnFCLE9BQU8sRUFBRThxQixJQUFJLENBQUNGO1lBQ2hELE1BQU1HLG1CQUFtQnp2QixpREFBWUEsQ0FDaEMwbkIsU0FBUyxDQUFDOEcsZ0JBQWdCNXFCLENBQUMsRUFBRTRxQixnQkFBZ0IzcUIsQ0FBQyxFQUM5QzhqQixLQUFLLENBQUNuaUIsTUFBTWdwQixnQkFBZ0J2dUIsSUFBSSxFQUFFdVcsU0FBU0M7WUFDaEQsTUFBTTNRLFNBQVM7Z0JBQ1g7b0JBQUM7b0JBQUc7aUJBQUU7Z0JBQ047b0JBQUN1cEIsS0FBSzlxQixLQUFLO29CQUFFOHFCLEtBQUs3cUIsTUFBTTtpQkFBQzthQUM1QjtZQUNELE1BQU1rckIsdUJBQXVCSixlQUFlSyxTQUFTLEdBQUdGLGtCQUFrQjNwQixRQUFRK2I7WUFDbEZ5TixlQUFlenFCLFNBQVMsQ0FBQ3FTLFdBQVd3WTtZQUNwQ0osZUFBZWhDLFVBQVUsQ0FBQ0E7WUFDMUJyckIsTUFBTUksUUFBUSxDQUFDO2dCQUNYMGtCLFFBQVF1STtnQkFDUnRJLGFBQWE5UDtnQkFDYnlXLGVBQWV6VyxVQUFVMFksRUFBRSxDQUFDO2dCQUM1QixxR0FBcUc7Z0JBQ3JHL3FCLFdBQVc7b0JBQUM2cUIscUJBQXFCOXJCLENBQUM7b0JBQUU4ckIscUJBQXFCN3JCLENBQUM7b0JBQUU2ckIscUJBQXFCaEssQ0FBQztpQkFBQztnQkFDbkYzSyxTQUFTZ1UsU0FBU3JxQixPQUFPLENBQUM2RSxPQUFPLENBQUM7WUFDdEM7UUFDSjtJQUNKLEdBQUcsRUFBRTtJQUNMOUosZ0RBQVNBLENBQUM7UUFDTixJQUFJdW5CLGVBQWVELFFBQVE7WUFDdkIsSUFBSW9ILGVBQWUsQ0FBQ2MsNEJBQTRCLENBQUN2c0IscUJBQXFCO2dCQUNsRXNrQixZQUFZNEksRUFBRSxDQUFDLGNBQWMsQ0FBQzltQjtvQkFDMUIsSUFBSW9rQixtQkFBbUJwa0IsT0FBTzZsQixtQkFBbUI7d0JBQzdDLE9BQU87b0JBQ1g7b0JBQ0E3bEIsTUFBTXFjLGNBQWM7b0JBQ3BCcmMsTUFBTSttQix3QkFBd0I7b0JBQzlCLE1BQU1DLGNBQWM5SSxZQUFZK0ksUUFBUSxDQUFDLFVBQVVySyxDQUFDLElBQUk7b0JBQ3hELE1BQU1zSyxXQUFXOWxCO29CQUNqQiwwREFBMEQ7b0JBQzFELElBQUlwQixNQUFNNmIsT0FBTyxJQUFJdUosZUFBZThCLFVBQVU7d0JBQzFDLE1BQU1DLFFBQVE5dkIsd0RBQU9BLENBQUMySTt3QkFDdEIsTUFBTW9uQixhQUFhNUMsV0FBV3hrQjt3QkFDOUIsTUFBTTdJLE9BQU82dkIsY0FBY2xxQixLQUFLd0ksR0FBRyxDQUFDLEdBQUc4aEI7d0JBQ3ZDLGFBQWE7d0JBQ2JuSixPQUFPeUMsT0FBTyxDQUFDeEMsYUFBYS9tQixNQUFNZ3dCLE9BQU9ubkI7d0JBQ3pDO29CQUNKO29CQUNBLG1DQUFtQztvQkFDbkMsb0RBQW9EO29CQUNwRCxNQUFNcW5CLGlCQUFpQnJuQixNQUFNMmtCLFNBQVMsS0FBSyxJQUFJLEtBQUs7b0JBQ3BELElBQUkyQyxTQUFTL0Isb0JBQW9CeGhCLGdCQUFnQndqQixRQUFRLEdBQUcsSUFBSXZuQixNQUFNc25CLE1BQU0sR0FBR0Q7b0JBQy9FLElBQUkzQyxTQUFTYSxvQkFBb0J4aEIsZ0JBQWdCeWpCLFVBQVUsR0FBRyxJQUFJeG5CLE1BQU0wa0IsTUFBTSxHQUFHMkM7b0JBQ2pGLGlFQUFpRTtvQkFDakUsSUFBSSxDQUFDSCxZQUFZbG5CLE1BQU0rYixRQUFRLElBQUl3SixvQkFBb0J4aEIsZ0JBQWdCd2pCLFFBQVEsRUFBRTt3QkFDN0VELFNBQVN0bkIsTUFBTTBrQixNQUFNLEdBQUcyQzt3QkFDeEIzQyxTQUFTO29CQUNiO29CQUNBekcsT0FBT3dKLFdBQVcsQ0FBQ3ZKLGFBQWEsQ0FBRW9KLENBQUFBLFNBQVNOLFdBQVUsSUFBSzFCLGtCQUFrQixDQUFFWixDQUFBQSxTQUFTc0MsV0FBVSxJQUFLMUIsa0JBQ3RHLGFBQWE7b0JBQ2I7d0JBQUVvQyxVQUFVO29CQUFLO29CQUNqQixNQUFNQyxlQUFleEQscUJBQXFCakcsWUFBWStJLFFBQVEsQ0FBQztvQkFDL0QsTUFBTSxFQUFFVyxxQkFBcUIsRUFBRUMsZ0JBQWdCLEVBQUVDLG1CQUFtQixFQUFFLEdBQUczdUIsTUFBTUcsUUFBUTtvQkFDdkZ5dUIsYUFBYXpCLGlCQUFpQjFxQixPQUFPO29CQUNyQyxpRUFBaUU7b0JBQ2pFLDJEQUEyRDtvQkFDM0QseUZBQXlGO29CQUN6RixJQUFJLENBQUN5cUIsZUFBZXpxQixPQUFPLEVBQUU7d0JBQ3pCeXFCLGVBQWV6cUIsT0FBTyxHQUFHO3dCQUN6Qm9wQixjQUFjaGxCLE9BQU8ybkI7d0JBQ3JCQyx3QkFBd0JEO29CQUM1QjtvQkFDQSxJQUFJdEIsZUFBZXpxQixPQUFPLEVBQUU7d0JBQ3hCbXBCLFNBQVMva0IsT0FBTzJuQjt3QkFDaEJFLG1CQUFtQkY7d0JBQ25CckIsaUJBQWlCMXFCLE9BQU8sR0FBR29zQixXQUFXOzRCQUNsQy9DLFlBQVlqbEIsT0FBTzJuQjs0QkFDbkJHLHNCQUFzQkg7NEJBQ3RCdEIsZUFBZXpxQixPQUFPLEdBQUc7d0JBQzdCLEdBQUc7b0JBQ1A7Z0JBQ0osR0FBRztvQkFBRXFzQixTQUFTO2dCQUFNO1lBQ3hCLE9BQ0ssSUFBSSxPQUFPcEQsa0JBQWtCLGFBQWE7Z0JBQzNDM0csWUFBWTRJLEVBQUUsQ0FBQyxjQUFjLFNBQVU5bUIsS0FBSyxFQUFFZ0MsQ0FBQztvQkFDM0MsSUFBSSxDQUFDNGpCLG9CQUFvQnhCLG1CQUFtQnBrQixPQUFPNmxCLG1CQUFtQjt3QkFDbEUsT0FBTztvQkFDWDtvQkFDQTdsQixNQUFNcWMsY0FBYztvQkFDcEJ3SSxjQUFjNkIsSUFBSSxDQUFDLElBQUksRUFBRTFtQixPQUFPZ0M7Z0JBQ3BDLEdBQUc7b0JBQUVpbUIsU0FBUztnQkFBTTtZQUN4QjtRQUNKO0lBQ0osR0FBRztRQUNDcnVCO1FBQ0F5ckI7UUFDQUU7UUFDQXJIO1FBQ0FEO1FBQ0E0RztRQUNBc0I7UUFDQWY7UUFDQVE7UUFDQUM7UUFDQWI7UUFDQUQ7UUFDQUU7S0FDSDtJQUNEdHVCLGdEQUFTQSxDQUFDO1FBQ04sSUFBSXNuQixRQUFRO1lBQ1JBLE9BQU82SSxFQUFFLENBQUMsU0FBUyxDQUFDOW1CO2dCQUNoQixJQUFJLENBQUNBLE1BQU1rb0IsV0FBVyxJQUFJbG9CLE1BQU1rb0IsV0FBVyxDQUFDUixRQUFRLEVBQUU7b0JBQ2xELE9BQU87Z0JBQ1g7Z0JBQ0EseUVBQXlFO2dCQUN6RXRCLFlBQVl4cUIsT0FBTyxHQUFHb0UsTUFBTWtvQixXQUFXLEVBQUUxUztnQkFDekMsTUFBTSxFQUFFb1MscUJBQXFCLEVBQUUsR0FBR3p1QixNQUFNRyxRQUFRO2dCQUNoRCxNQUFNNnVCLGdCQUFnQmhFLHFCQUFxQm5rQixNQUFNakUsU0FBUztnQkFDMURncUIsbUJBQW1CbnFCLE9BQU8sR0FBRztnQkFDN0JzcUIsY0FBY3RxQixPQUFPLEdBQUd1c0I7Z0JBQ3hCLElBQUlub0IsTUFBTWtvQixXQUFXLEVBQUU1dkIsU0FBUyxhQUFhO29CQUN6Q2EsTUFBTUksUUFBUSxDQUFDO3dCQUFFNnVCLGNBQWM7b0JBQUs7Z0JBQ3hDO2dCQUNBUix3QkFBd0JPO2dCQUN4Qm5ELGNBQWNobEIsTUFBTWtvQixXQUFXLEVBQUVDO1lBQ3JDO1FBQ0o7SUFDSixHQUFHO1FBQUNsSztRQUFRK0c7S0FBWTtJQUN4QnJ1QixnREFBU0EsQ0FBQztRQUNOLElBQUlzbkIsUUFBUTtZQUNSLElBQUlya0IsdUJBQXVCLENBQUNtc0IsbUJBQW1CbnFCLE9BQU8sRUFBRTtnQkFDcERxaUIsT0FBTzZJLEVBQUUsQ0FBQyxRQUFRO1lBQ3RCLE9BQ0ssSUFBSSxDQUFDbHRCLHFCQUFxQjtnQkFDM0Jxa0IsT0FBTzZJLEVBQUUsQ0FBQyxRQUFRLENBQUM5bUI7b0JBQ2YsTUFBTSxFQUFFNm5CLGdCQUFnQixFQUFFLEdBQUcxdUIsTUFBTUcsUUFBUTtvQkFDM0NILE1BQU1JLFFBQVEsQ0FBQzt3QkFBRXdDLFdBQVc7NEJBQUNpRSxNQUFNakUsU0FBUyxDQUFDakIsQ0FBQzs0QkFBRWtGLE1BQU1qRSxTQUFTLENBQUNoQixDQUFDOzRCQUFFaUYsTUFBTWpFLFNBQVMsQ0FBQzZnQixDQUFDO3lCQUFDO29CQUFDO29CQUN0Rm9KLDJCQUEyQnBxQixPQUFPLEdBQUcsQ0FBQyxDQUFFc3BCLENBQUFBLHFCQUFxQmIsZ0JBQWdCQyxXQUFXOEIsWUFBWXhxQixPQUFPLElBQUksRUFBQztvQkFDaEgsSUFBSSxDQUFDbXBCLFVBQVU4QyxnQkFBZSxLQUFNLENBQUM3bkIsTUFBTWtvQixXQUFXLEVBQUVSLFVBQVU7d0JBQzlELE1BQU1TLGdCQUFnQmhFLHFCQUFxQm5rQixNQUFNakUsU0FBUzt3QkFDMUQ4ckIsbUJBQW1CTTt3QkFDbkJwRCxTQUFTL2tCLE1BQU1rb0IsV0FBVyxFQUFFQztvQkFDaEM7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0osR0FBRztRQUFDdnVCO1FBQXFCcWtCO1FBQVE4RztRQUFRVDtRQUFXWTtLQUFrQjtJQUN0RXZ1QixnREFBU0EsQ0FBQztRQUNOLElBQUlzbkIsUUFBUTtZQUNSQSxPQUFPNkksRUFBRSxDQUFDLE9BQU8sQ0FBQzltQjtnQkFDZCxJQUFJLENBQUNBLE1BQU1rb0IsV0FBVyxJQUFJbG9CLE1BQU1rb0IsV0FBVyxDQUFDUixRQUFRLEVBQUU7b0JBQ2xELE9BQU87Z0JBQ1g7Z0JBQ0EsTUFBTSxFQUFFSSxtQkFBbUIsRUFBRSxHQUFHM3VCLE1BQU1HLFFBQVE7Z0JBQzlDeXNCLG1CQUFtQm5xQixPQUFPLEdBQUc7Z0JBQzdCekMsTUFBTUksUUFBUSxDQUFDO29CQUFFNnVCLGNBQWM7Z0JBQU07Z0JBQ3JDLElBQUlsRCxxQkFDQWIsZ0JBQWdCQyxXQUFXOEIsWUFBWXhxQixPQUFPLElBQUksTUFDbEQsQ0FBQ29xQiwyQkFBMkJwcUIsT0FBTyxFQUFFO29CQUNyQ3NwQixrQkFBa0JsbEIsTUFBTWtvQixXQUFXO2dCQUN2QztnQkFDQWxDLDJCQUEyQnBxQixPQUFPLEdBQUc7Z0JBQ3JDLElBQUksQ0FBQ3FwQixhQUFhNkMsbUJBQWtCLEtBQU05RCxZQUFZa0MsY0FBY3RxQixPQUFPLEVBQUVvRSxNQUFNakUsU0FBUyxHQUFHO29CQUMzRixNQUFNb3NCLGdCQUFnQmhFLHFCQUFxQm5rQixNQUFNakUsU0FBUztvQkFDMURtcUIsY0FBY3RxQixPQUFPLEdBQUd1c0I7b0JBQ3hCSixhQUFhakMsUUFBUWxxQixPQUFPO29CQUM1QmtxQixRQUFRbHFCLE9BQU8sR0FBR29zQixXQUFXO3dCQUN6QkYsc0JBQXNCSzt3QkFDdEJsRCxZQUFZamxCLE1BQU1rb0IsV0FBVyxFQUFFQztvQkFDbkMsR0FBRzlDLGNBQWMsTUFBTTtnQkFDM0I7WUFDSjtRQUNKO0lBQ0osR0FBRztRQUFDcEg7UUFBUW9IO1FBQWFmO1FBQVdXO1FBQVdDO0tBQWtCO0lBQ2pFdnVCLGdEQUFTQSxDQUFDO1FBQ04sSUFBSXNuQixRQUFRO1lBQ1JBLE9BQU92VSxNQUFNLENBQUMsQ0FBQzFKO2dCQUNYLE1BQU1xb0IsYUFBYWxDLDRCQUE0QmhCO2dCQUMvQyxNQUFNbUQsWUFBWWxELGVBQWVwbEIsTUFBTTZiLE9BQU87Z0JBQzlDLElBQUksQ0FBQ3lJLGNBQWMsUUFBUy9JLE1BQU1DLE9BQU8sQ0FBQzhJLGNBQWNBLFVBQVVoa0IsUUFBUSxDQUFDLEVBQUUsS0FDekVOLE1BQU13VixNQUFNLEtBQUssS0FDakJ4VixNQUFNMUgsSUFBSSxLQUFLLGVBQ2Q4ckIsQ0FBQUEsbUJBQW1CcGtCLE9BQU8sdUJBQXVCb2tCLG1CQUFtQnBrQixPQUFPLG1CQUFrQixHQUFJO29CQUNsRyxPQUFPO2dCQUNYO2dCQUNBLCtEQUErRDtnQkFDL0QsSUFBSSxDQUFDc2tCLGFBQWEsQ0FBQytELGNBQWMsQ0FBQ2hELGVBQWUsQ0FBQ0kscUJBQXFCLENBQUNMLGFBQWE7b0JBQ2pGLE9BQU87Z0JBQ1g7Z0JBQ0EsdURBQXVEO2dCQUN2RCxJQUFJeHJCLHFCQUFxQjtvQkFDckIsT0FBTztnQkFDWDtnQkFDQSx5RUFBeUU7Z0JBQ3pFLElBQUksQ0FBQzZyQixxQkFBcUJ6bEIsTUFBTTFILElBQUksS0FBSyxZQUFZO29CQUNqRCxPQUFPO2dCQUNYO2dCQUNBLHdGQUF3RjtnQkFDeEYsSUFBSThyQixtQkFBbUJwa0IsT0FBTzZsQixxQkFBcUI3bEIsTUFBTTFILElBQUksS0FBSyxTQUFTO29CQUN2RSxPQUFPO2dCQUNYO2dCQUNBLHNGQUFzRjtnQkFDdEYsSUFBSThyQixtQkFBbUJwa0IsT0FBT21VLG1CQUN6Qm5VLENBQUFBLE1BQU0xSCxJQUFJLEtBQUssV0FBWStzQixlQUFlcmxCLE1BQU0xSCxJQUFJLEtBQUssV0FBVyxDQUFDNnRCLHdCQUF3QixHQUFJO29CQUNsRyxPQUFPO2dCQUNYO2dCQUNBLElBQUksQ0FBQ2YsZUFBZXBsQixNQUFNNmIsT0FBTyxJQUFJN2IsTUFBTTFILElBQUksS0FBSyxTQUFTO29CQUN6RCxPQUFPO2dCQUNYO2dCQUNBLHdFQUF3RTtnQkFDeEUsSUFBSSxDQUFDK3ZCLGNBQWMsQ0FBQ2hELGVBQWUsQ0FBQ2lELGFBQWF0b0IsTUFBTTFILElBQUksS0FBSyxTQUFTO29CQUNyRSxPQUFPO2dCQUNYO2dCQUNBLG1GQUFtRjtnQkFDbkYsSUFBSSxDQUFDZ3NCLGFBQWN0a0IsQ0FBQUEsTUFBTTFILElBQUksS0FBSyxlQUFlMEgsTUFBTTFILElBQUksS0FBSyxZQUFXLEdBQUk7b0JBQzNFLE9BQU87Z0JBQ1g7Z0JBQ0EsbURBQW1EO2dCQUNuRCxJQUFJaWpCLE1BQU1DLE9BQU8sQ0FBQzhJLGNBQ2QsQ0FBQ0EsVUFBVWhrQixRQUFRLENBQUNOLE1BQU13VixNQUFNLEtBQy9CeFYsQ0FBQUEsTUFBTTFILElBQUksS0FBSyxlQUFlMEgsTUFBTTFILElBQUksS0FBSyxZQUFXLEdBQUk7b0JBQzdELE9BQU87Z0JBQ1g7Z0JBQ0Esa0VBQWtFO2dCQUNsRSxNQUFNaXdCLGdCQUFnQixNQUFPL00sT0FBTyxDQUFDOEksY0FBY0EsVUFBVWhrQixRQUFRLENBQUNOLE1BQU13VixNQUFNLEtBQU0sQ0FBQ3hWLE1BQU13VixNQUFNLElBQUl4VixNQUFNd1YsTUFBTSxJQUFJO2dCQUN6SCw2QkFBNkI7Z0JBQzdCLE9BQU8sQ0FBQyxDQUFDeFYsTUFBTTZiLE9BQU8sSUFBSTdiLE1BQU0xSCxJQUFJLEtBQUssT0FBTSxLQUFNaXdCO1lBQ3pEO1FBQ0o7SUFDSixHQUFHO1FBQ0MzdUI7UUFDQXFrQjtRQUNBa0g7UUFDQUM7UUFDQUM7UUFDQUk7UUFDQW5CO1FBQ0F6TDtRQUNBc047S0FDSDtJQUNELHFCQUFRL3ZCLGdEQUFtQixDQUFDLE9BQU87UUFBRTRELFdBQVc7UUFBd0JvQyxLQUFLNnBCO1FBQVVoc0IsT0FBTzhwQjtJQUFlLEdBQUdocUI7QUFDcEg7QUFFQSxNQUFNeXVCLGFBQWEsQ0FBQzd1QixJQUFPO1FBQ3ZCQyxxQkFBcUJELEVBQUVDLG1CQUFtQjtRQUMxQzZ1QixtQkFBbUI5dUIsRUFBRTh1QixpQkFBaUI7SUFDMUM7QUFDQSxTQUFTQztJQUNMLE1BQU0sRUFBRTl1QixtQkFBbUIsRUFBRTZ1QixpQkFBaUIsRUFBRSxHQUFHenZCLFNBQVN3dkIsWUFBWXZ4QixvREFBT0E7SUFDL0UsTUFBTTB4QixXQUFXL3VCLHVCQUF1QjZ1QjtJQUN4QyxJQUFJLENBQUNFLFVBQVU7UUFDWCxPQUFPO0lBQ1g7SUFDQSxxQkFBUXZ5QixnREFBbUIsQ0FBQyxPQUFPO1FBQUU0RCxXQUFXO1FBQStDQyxPQUFPO1lBQzlGd0IsT0FBT2d0QixrQkFBa0JodEIsS0FBSztZQUM5QkMsUUFBUStzQixrQkFBa0Ivc0IsTUFBTTtZQUNoQ0ssV0FBVyxDQUFDLFVBQVUsRUFBRTBzQixrQkFBa0IzdEIsQ0FBQyxDQUFDLElBQUksRUFBRTJ0QixrQkFBa0IxdEIsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUM5RTtJQUFFO0FBQ1Y7QUFFQSxTQUFTNnRCLG1CQUFtQjNnQixHQUFHLEVBQUU0Z0IsVUFBVTtJQUN2QyxNQUFNQyxTQUFTN2dCLElBQUlyRixJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRXpLLEVBQUUsS0FBS3l3QixXQUFXN0wsVUFBVTtJQUM3RCxJQUFJOEwsUUFBUTtRQUNSLE1BQU1DLGNBQWNGLFdBQVcvdUIsUUFBUSxDQUFDZ0IsQ0FBQyxHQUFHK3RCLFdBQVdwdEIsS0FBSyxHQUFHcXRCLE9BQU9ydEIsS0FBSztRQUMzRSxNQUFNdXRCLGVBQWVILFdBQVcvdUIsUUFBUSxDQUFDaUIsQ0FBQyxHQUFHOHRCLFdBQVdudEIsTUFBTSxHQUFHb3RCLE9BQU9wdEIsTUFBTTtRQUM5RSxJQUFJcXRCLGNBQWMsS0FBS0MsZUFBZSxLQUFLSCxXQUFXL3VCLFFBQVEsQ0FBQ2dCLENBQUMsR0FBRyxLQUFLK3RCLFdBQVcvdUIsUUFBUSxDQUFDaUIsQ0FBQyxHQUFHLEdBQUc7WUFDL0YrdEIsT0FBTzd1QixLQUFLLEdBQUc7Z0JBQUUsR0FBRzZ1QixPQUFPN3VCLEtBQUs7WUFBQyxLQUFLLENBQUM7WUFDdkM2dUIsT0FBTzd1QixLQUFLLENBQUN3QixLQUFLLEdBQUdxdEIsT0FBTzd1QixLQUFLLENBQUN3QixLQUFLLElBQUlxdEIsT0FBT3J0QixLQUFLO1lBQ3ZEcXRCLE9BQU83dUIsS0FBSyxDQUFDeUIsTUFBTSxHQUFHb3RCLE9BQU83dUIsS0FBSyxDQUFDeUIsTUFBTSxJQUFJb3RCLE9BQU9wdEIsTUFBTTtZQUMxRCxJQUFJcXRCLGNBQWMsR0FBRztnQkFDakJELE9BQU83dUIsS0FBSyxDQUFDd0IsS0FBSyxJQUFJc3RCO1lBQzFCO1lBQ0EsSUFBSUMsZUFBZSxHQUFHO2dCQUNsQkYsT0FBTzd1QixLQUFLLENBQUN5QixNQUFNLElBQUlzdEI7WUFDM0I7WUFDQSxJQUFJSCxXQUFXL3VCLFFBQVEsQ0FBQ2dCLENBQUMsR0FBRyxHQUFHO2dCQUMzQixNQUFNbXVCLFFBQVFuc0IsS0FBS0ssR0FBRyxDQUFDMHJCLFdBQVcvdUIsUUFBUSxDQUFDZ0IsQ0FBQztnQkFDNUNndUIsT0FBT2h2QixRQUFRLENBQUNnQixDQUFDLEdBQUdndUIsT0FBT2h2QixRQUFRLENBQUNnQixDQUFDLEdBQUdtdUI7Z0JBQ3hDSCxPQUFPN3VCLEtBQUssQ0FBQ3dCLEtBQUssSUFBSXd0QjtnQkFDdEJKLFdBQVcvdUIsUUFBUSxDQUFDZ0IsQ0FBQyxHQUFHO1lBQzVCO1lBQ0EsSUFBSSt0QixXQUFXL3VCLFFBQVEsQ0FBQ2lCLENBQUMsR0FBRyxHQUFHO2dCQUMzQixNQUFNbXVCLFFBQVFwc0IsS0FBS0ssR0FBRyxDQUFDMHJCLFdBQVcvdUIsUUFBUSxDQUFDaUIsQ0FBQztnQkFDNUMrdEIsT0FBT2h2QixRQUFRLENBQUNpQixDQUFDLEdBQUcrdEIsT0FBT2h2QixRQUFRLENBQUNpQixDQUFDLEdBQUdtdUI7Z0JBQ3hDSixPQUFPN3VCLEtBQUssQ0FBQ3lCLE1BQU0sSUFBSXd0QjtnQkFDdkJMLFdBQVcvdUIsUUFBUSxDQUFDaUIsQ0FBQyxHQUFHO1lBQzVCO1lBQ0ErdEIsT0FBT3J0QixLQUFLLEdBQUdxdEIsT0FBTzd1QixLQUFLLENBQUN3QixLQUFLO1lBQ2pDcXRCLE9BQU9wdEIsTUFBTSxHQUFHb3RCLE9BQU83dUIsS0FBSyxDQUFDeUIsTUFBTTtRQUN2QztJQUNKO0FBQ0o7QUFDQSxTQUFTeXRCLGFBQWE1SCxPQUFPLEVBQUU2SCxRQUFRO0lBQ25DLCtHQUErRztJQUMvRyxJQUFJN0gsUUFBUTlXLElBQUksQ0FBQyxDQUFDaEQsSUFBTUEsRUFBRW5QLElBQUksS0FBSyxVQUFVO1FBQ3pDLE9BQU9pcEIsUUFBUTdYLE1BQU0sQ0FBQyxDQUFDakMsSUFBTUEsRUFBRW5QLElBQUksS0FBSyxTQUFTcVIsR0FBRyxDQUFDLENBQUNsQyxJQUFNQSxFQUFFa1UsSUFBSTtJQUN0RTtJQUNBLE1BQU0wTixlQUFlOUgsUUFBUTdYLE1BQU0sQ0FBQyxDQUFDakMsSUFBTUEsRUFBRW5QLElBQUksS0FBSyxPQUFPcVIsR0FBRyxDQUFDLENBQUNsQyxJQUFNQSxFQUFFa1UsSUFBSTtJQUM5RSxPQUFPeU4sU0FBU3BoQixNQUFNLENBQUMsQ0FBQ0MsS0FBSzBUO1FBQ3pCLE1BQU0yTixpQkFBaUIvSCxRQUFRN1gsTUFBTSxDQUFDLENBQUNqQyxJQUFNQSxFQUFFclAsRUFBRSxLQUFLdWpCLEtBQUt2akIsRUFBRTtRQUM3RCxJQUFJa3hCLGVBQWVqaEIsTUFBTSxLQUFLLEdBQUc7WUFDN0JKLElBQUlxRixJQUFJLENBQUNxTztZQUNULE9BQU8xVDtRQUNYO1FBQ0EsTUFBTTRnQixhQUFhO1lBQUUsR0FBR2xOLElBQUk7UUFBQztRQUM3QixLQUFLLE1BQU00TixpQkFBaUJELGVBQWdCO1lBQ3hDLElBQUlDLGVBQWU7Z0JBQ2YsT0FBUUEsY0FBY2p4QixJQUFJO29CQUN0QixLQUFLO3dCQUFVOzRCQUNYdXdCLFdBQVdqUyxRQUFRLEdBQUcyUyxjQUFjM1MsUUFBUTs0QkFDNUM7d0JBQ0o7b0JBQ0EsS0FBSzt3QkFBWTs0QkFDYixJQUFJLE9BQU8yUyxjQUFjenZCLFFBQVEsS0FBSyxhQUFhO2dDQUMvQyt1QixXQUFXL3VCLFFBQVEsR0FBR3l2QixjQUFjenZCLFFBQVE7NEJBQ2hEOzRCQUNBLElBQUksT0FBT3l2QixjQUFjanJCLGdCQUFnQixLQUFLLGFBQWE7Z0NBQ3ZEdXFCLFdBQVd2cUIsZ0JBQWdCLEdBQUdpckIsY0FBY2pyQixnQkFBZ0I7NEJBQ2hFOzRCQUNBLElBQUksT0FBT2lyQixjQUFjbGMsUUFBUSxLQUFLLGFBQWE7Z0NBQy9Dd2IsV0FBV3hiLFFBQVEsR0FBR2tjLGNBQWNsYyxRQUFROzRCQUNoRDs0QkFDQSxJQUFJd2IsV0FBV1csWUFBWSxFQUFFO2dDQUN6QlosbUJBQW1CM2dCLEtBQUs0Z0I7NEJBQzVCOzRCQUNBO3dCQUNKO29CQUNBLEtBQUs7d0JBQWM7NEJBQ2YsSUFBSSxPQUFPVSxjQUFjRSxVQUFVLEtBQUssYUFBYTtnQ0FDakRaLFdBQVdwdEIsS0FBSyxHQUFHOHRCLGNBQWNFLFVBQVUsQ0FBQ2h1QixLQUFLO2dDQUNqRG90QixXQUFXbnRCLE1BQU0sR0FBRzZ0QixjQUFjRSxVQUFVLENBQUMvdEIsTUFBTTs0QkFDdkQ7NEJBQ0EsSUFBSSxPQUFPNnRCLGNBQWNHLFdBQVcsS0FBSyxhQUFhO2dDQUNsRGIsV0FBVzV1QixLQUFLLEdBQUc7b0NBQUUsR0FBSTR1QixXQUFXNXVCLEtBQUssSUFBSSxDQUFDLENBQUM7b0NBQUcsR0FBR3N2QixjQUFjRSxVQUFVO2dDQUFDOzRCQUNsRjs0QkFDQSxJQUFJLE9BQU9GLGNBQWNJLFFBQVEsS0FBSyxXQUFXO2dDQUM3Q2QsV0FBV2MsUUFBUSxHQUFHSixjQUFjSSxRQUFROzRCQUNoRDs0QkFDQSxJQUFJZCxXQUFXVyxZQUFZLEVBQUU7Z0NBQ3pCWixtQkFBbUIzZ0IsS0FBSzRnQjs0QkFDNUI7NEJBQ0E7d0JBQ0o7b0JBQ0EsS0FBSzt3QkFBVTs0QkFDWCxPQUFPNWdCO3dCQUNYO2dCQUNKO1lBQ0o7UUFDSjtRQUNBQSxJQUFJcUYsSUFBSSxDQUFDdWI7UUFDVCxPQUFPNWdCO0lBQ1gsR0FBR29oQjtBQUNQO0FBQ0EsU0FBU08saUJBQWlCckksT0FBTyxFQUFFL1gsS0FBSztJQUNwQyxPQUFPMmYsYUFBYTVILFNBQVMvWDtBQUNqQztBQUNBLFNBQVNxZ0IsaUJBQWlCdEksT0FBTyxFQUFFNWUsS0FBSztJQUNwQyxPQUFPd21CLGFBQWE1SCxTQUFTNWU7QUFDakM7QUFDQSxNQUFNbW5CLHdCQUF3QixDQUFDMXhCLElBQUl3ZSxXQUFjO1FBQzdDeGU7UUFDQUUsTUFBTTtRQUNOc2U7SUFDSjtBQUNBLFNBQVNtVCxvQkFBb0JDLEtBQUssRUFBRUMsV0FBVztJQUMzQyxPQUFPRCxNQUFNaGlCLE1BQU0sQ0FBQyxDQUFDQyxLQUFLMFQ7UUFDdEIsTUFBTXVPLGlCQUFpQkQsWUFBWTNwQixRQUFRLENBQUNxYixLQUFLdmpCLEVBQUU7UUFDbkQsSUFBSSxDQUFDdWpCLEtBQUsvRSxRQUFRLElBQUlzVCxnQkFBZ0I7WUFDbEN2TyxLQUFLL0UsUUFBUSxHQUFHO1lBQ2hCM08sSUFBSXFGLElBQUksQ0FBQ3djLHNCQUFzQm5PLEtBQUt2akIsRUFBRSxFQUFFO1FBQzVDLE9BQ0ssSUFBSXVqQixLQUFLL0UsUUFBUSxJQUFJLENBQUNzVCxnQkFBZ0I7WUFDdkN2TyxLQUFLL0UsUUFBUSxHQUFHO1lBQ2hCM08sSUFBSXFGLElBQUksQ0FBQ3djLHNCQUFzQm5PLEtBQUt2akIsRUFBRSxFQUFFO1FBQzVDO1FBQ0EsT0FBTzZQO0lBQ1gsR0FBRyxFQUFFO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNELE1BQU1raUIsY0FBYyxDQUFDMW5CLFNBQVMybkI7SUFDMUIsT0FBTyxDQUFDcHFCO1FBQ0osSUFBSUEsTUFBTXJGLE1BQU0sS0FBS3l2QixhQUFheHVCLE9BQU8sRUFBRTtZQUN2QztRQUNKO1FBQ0E2RyxVQUFVekM7SUFDZDtBQUNKO0FBQ0EsTUFBTXFxQixhQUFhLENBQUMxd0IsSUFBTztRQUN2QkMscUJBQXFCRCxFQUFFQyxtQkFBbUI7UUFDMUNpZixvQkFBb0JsZixFQUFFa2Ysa0JBQWtCO1FBQ3hDeEwsVUFBVTFULEVBQUV5dUIsWUFBWTtJQUM1QjtBQUNBLE1BQU1rQyxxQkFBTzl6QiwyQ0FBSUEsQ0FBQyxDQUFDLEVBQUUrekIsV0FBVyxFQUFFQyxnQkFBZ0J4bUIsY0FBY3ltQixJQUFJLEVBQUVuRyxTQUFTLEVBQUVvRyxnQkFBZ0IsRUFBRUMsY0FBYyxFQUFFQyxXQUFXLEVBQUUxRixpQkFBaUIsRUFBRTJGLFlBQVksRUFBRUMsZ0JBQWdCLEVBQUVDLGVBQWUsRUFBRUMsZ0JBQWdCLEVBQUVqeEIsUUFBUSxFQUFHO0lBQzdOLE1BQU1reEIsWUFBWXgwQiw2Q0FBTUEsQ0FBQztJQUN6QixNQUFNMEMsUUFBUUU7SUFDZCxNQUFNNnhCLHlCQUF5QnowQiw2Q0FBTUEsQ0FBQztJQUN0QyxNQUFNMDBCLHlCQUF5QjEwQiw2Q0FBTUEsQ0FBQztJQUN0QyxNQUFNa2Msa0JBQWtCbGMsNkNBQU1BO0lBQzlCLE1BQU0sRUFBRW1ELG1CQUFtQixFQUFFaWYsa0JBQWtCLEVBQUV4TCxRQUFRLEVBQUUsR0FBR3JVLFNBQVNxeEIsWUFBWXB6QixvREFBT0E7SUFDMUYsTUFBTW0wQixxQkFBcUI7UUFDdkJqeUIsTUFBTUksUUFBUSxDQUFDO1lBQUVLLHFCQUFxQjtZQUFPNnVCLG1CQUFtQjtRQUFLO1FBQ3JFeUMsdUJBQXVCdHZCLE9BQU8sR0FBRztRQUNqQ3V2Qix1QkFBdUJ2dkIsT0FBTyxHQUFHO0lBQ3JDO0lBQ0EsTUFBTTZaLFVBQVUsQ0FBQ3pWO1FBQ2I0cUIsY0FBYzVxQjtRQUNkN0csTUFBTUcsUUFBUSxHQUFHK3hCLHFCQUFxQjtRQUN0Q2x5QixNQUFNSSxRQUFRLENBQUM7WUFBRStwQixzQkFBc0I7UUFBTTtJQUNqRDtJQUNBLE1BQU1nSSxnQkFBZ0IsQ0FBQ3RyQjtRQUNuQixJQUFJdWIsTUFBTUMsT0FBTyxDQUFDOEksY0FBY0EsV0FBV2hrQixTQUFTLElBQUk7WUFDcEROLE1BQU1xYyxjQUFjO1lBQ3BCO1FBQ0o7UUFDQTZJLG9CQUFvQmxsQjtJQUN4QjtJQUNBLE1BQU11ckIsVUFBVVYsZUFBZSxDQUFDN3FCLFFBQVU2cUIsYUFBYTdxQixTQUFTMEM7SUFDaEUsTUFBTW9TLGNBQWMsQ0FBQzlVO1FBQ2pCLE1BQU0sRUFBRXFyQixxQkFBcUIsRUFBRXBaLE9BQU8sRUFBRSxHQUFHOVksTUFBTUcsUUFBUTtRQUN6RHFaLGdCQUFnQi9XLE9BQU8sR0FBR3FXLFNBQVNXO1FBQ25DLElBQUksQ0FBQ2lHLHNCQUNELENBQUMwUixlQUNEdnFCLE1BQU13VixNQUFNLEtBQUssS0FDakJ4VixNQUFNckYsTUFBTSxLQUFLc3dCLFVBQVVydkIsT0FBTyxJQUNsQyxDQUFDK1csZ0JBQWdCL1csT0FBTyxFQUFFO1lBQzFCO1FBQ0o7UUFDQSxNQUFNLEVBQUVkLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUc0RixpQkFBaUJYLE9BQU8yUyxnQkFBZ0IvVyxPQUFPO1FBQ2hFeXZCO1FBQ0FseUIsTUFBTUksUUFBUSxDQUFDO1lBQ1hrdkIsbUJBQW1CO2dCQUNmaHRCLE9BQU87Z0JBQ1BDLFFBQVE7Z0JBQ1I4dkIsUUFBUTF3QjtnQkFDUjJ3QixRQUFRMXdCO2dCQUNSRDtnQkFDQUM7WUFDSjtRQUNKO1FBQ0EydkIsbUJBQW1CMXFCO0lBQ3ZCO0lBQ0EsTUFBTTByQixjQUFjLENBQUMxckI7UUFDakIsTUFBTSxFQUFFeW9CLGlCQUFpQixFQUFFbmMsYUFBYSxFQUFFM0osS0FBSyxFQUFFNUcsU0FBUyxFQUFFNGMsYUFBYSxFQUFFQyxhQUFhLEVBQUU3TSxVQUFVLEVBQUVzRyxRQUFRLEVBQUUsR0FBR2xaLE1BQU1HLFFBQVE7UUFDakksSUFBSSxDQUFDaXhCLGVBQWUsQ0FBQzVYLGdCQUFnQi9XLE9BQU8sSUFBSSxDQUFDNnNCLG1CQUFtQjtZQUNoRTtRQUNKO1FBQ0F0dkIsTUFBTUksUUFBUSxDQUFDO1lBQUVLLHFCQUFxQjtZQUFNMHBCLHNCQUFzQjtRQUFNO1FBQ3hFLE1BQU1xSSxXQUFXaHJCLGlCQUFpQlgsT0FBTzJTLGdCQUFnQi9XLE9BQU87UUFDaEUsTUFBTTR2QixTQUFTL0Msa0JBQWtCK0MsTUFBTSxJQUFJO1FBQzNDLE1BQU1DLFNBQVNoRCxrQkFBa0JnRCxNQUFNLElBQUk7UUFDM0MsTUFBTUcscUJBQXFCO1lBQ3ZCLEdBQUduRCxpQkFBaUI7WUFDcEIzdEIsR0FBRzZ3QixTQUFTN3dCLENBQUMsR0FBRzB3QixTQUFTRyxTQUFTN3dCLENBQUMsR0FBRzB3QjtZQUN0Q3p3QixHQUFHNHdCLFNBQVM1d0IsQ0FBQyxHQUFHMHdCLFNBQVNFLFNBQVM1d0IsQ0FBQyxHQUFHMHdCO1lBQ3RDaHdCLE9BQU9xQixLQUFLSyxHQUFHLENBQUN3dUIsU0FBUzd3QixDQUFDLEdBQUcwd0I7WUFDN0I5dkIsUUFBUW9CLEtBQUtLLEdBQUcsQ0FBQ3d1QixTQUFTNXdCLENBQUMsR0FBRzB3QjtRQUNsQztRQUNBLE1BQU1qaUIsUUFBUTZJO1FBQ2QsTUFBTXNFLGdCQUFnQnRLLGVBQWVDLGVBQWVzZixvQkFBb0I3dkIsV0FBV3l1QixrQkFBa0J4bUIsY0FBYzZuQixPQUFPLEVBQUUsTUFBTTlmO1FBQ2xJLE1BQU0rZixrQkFBa0J2ZSxrQkFBa0JvSixlQUFlaFUsT0FBT2dILEdBQUcsQ0FBQyxDQUFDOUcsSUFBTUEsRUFBRXpLLEVBQUU7UUFDL0UsTUFBTTJ6QixrQkFBa0JwVixjQUFjaE4sR0FBRyxDQUFDLENBQUN4SyxJQUFNQSxFQUFFL0csRUFBRTtRQUNyRCxJQUFJOHlCLHVCQUF1QnR2QixPQUFPLEtBQUttd0IsZ0JBQWdCMWpCLE1BQU0sRUFBRTtZQUMzRDZpQix1QkFBdUJ0dkIsT0FBTyxHQUFHbXdCLGdCQUFnQjFqQixNQUFNO1lBQ3ZELE1BQU1rWixVQUFVd0ksb0JBQW9CdmdCLE9BQU91aUI7WUFDM0MsSUFBSXhLLFFBQVFsWixNQUFNLEVBQUU7Z0JBQ2hCc1EsZ0JBQWdCNEk7WUFDcEI7UUFDSjtRQUNBLElBQUk0Six1QkFBdUJ2dkIsT0FBTyxLQUFLa3dCLGdCQUFnQnpqQixNQUFNLEVBQUU7WUFDM0Q4aUIsdUJBQXVCdnZCLE9BQU8sR0FBR2t3QixnQkFBZ0J6akIsTUFBTTtZQUN2RCxNQUFNa1osVUFBVXdJLG9CQUFvQnBuQixPQUFPbXBCO1lBQzNDLElBQUl2SyxRQUFRbFosTUFBTSxFQUFFO2dCQUNoQnVRLGdCQUFnQjJJO1lBQ3BCO1FBQ0o7UUFDQXBvQixNQUFNSSxRQUFRLENBQUM7WUFDWGt2QixtQkFBbUJtRDtRQUN2QjtJQUNKO0lBQ0EsTUFBTUksWUFBWSxDQUFDaHNCO1FBQ2YsSUFBSUEsTUFBTXdWLE1BQU0sS0FBSyxHQUFHO1lBQ3BCO1FBQ0o7UUFDQSxNQUFNLEVBQUVpVCxpQkFBaUIsRUFBRSxHQUFHdHZCLE1BQU1HLFFBQVE7UUFDNUMsb0VBQW9FO1FBQ3BFLG1DQUFtQztRQUNuQyxJQUFJLENBQUNNLHVCQUF1QjZ1QixxQkFBcUJ6b0IsTUFBTXJGLE1BQU0sS0FBS3N3QixVQUFVcnZCLE9BQU8sRUFBRTtZQUNqRjZaLFVBQVV6VjtRQUNkO1FBQ0E3RyxNQUFNSSxRQUFRLENBQUM7WUFBRStwQixzQkFBc0I0SCx1QkFBdUJ0dkIsT0FBTyxHQUFHO1FBQUU7UUFDMUV3dkI7UUFDQVQsaUJBQWlCM3FCO0lBQ3JCO0lBQ0EsTUFBTWlzQixlQUFlLENBQUNqc0I7UUFDbEIsSUFBSXBHLHFCQUFxQjtZQUNyQlQsTUFBTUksUUFBUSxDQUFDO2dCQUFFK3BCLHNCQUFzQjRILHVCQUF1QnR2QixPQUFPLEdBQUc7WUFBRTtZQUMxRSt1QixpQkFBaUIzcUI7UUFDckI7UUFDQW9yQjtJQUNKO0lBQ0EsTUFBTWMscUJBQXFCclQsc0JBQXVCMFIsQ0FBQUEsZUFBZTN3QixtQkFBa0I7SUFDbkYscUJBQVF4RCxnREFBbUIsQ0FBQyxPQUFPO1FBQUU0RCxXQUFXbEQsb0RBQUVBLENBQUM7WUFBQztZQUFvQjtnQkFBRXVXO2dCQUFVZSxXQUFXbWM7WUFBWTtTQUFFO1FBQUc5VSxTQUFTeVcscUJBQXFCeHBCLFlBQVl5bkIsWUFBWTFVLFNBQVN3VjtRQUFZSyxlQUFlbkIsWUFBWW1CLGVBQWVMO1FBQVlNLFNBQVNwQixZQUFZb0IsU0FBU047UUFBWWtCLGNBQWNELHFCQUFxQnhwQixZQUFZb29CO1FBQWtCaFcsYUFBYW9YLHFCQUFxQnBYLGNBQWNwUztRQUFXZ3BCLGFBQWFRLHFCQUFxQlIsY0FBY1g7UUFBaUJpQixXQUFXRSxxQkFBcUJGLFlBQVl0cEI7UUFBV3VwQixjQUFjQyxxQkFBcUJELGVBQWVqQjtRQUFrQjV1QixLQUFLNnVCO1FBQVdoeEIsT0FBTzhwQjtJQUFlLEdBQ3JuQmhxQix3QkFDQTNELGdEQUFtQixDQUFDc3lCLGVBQWU7QUFDM0M7QUFDQTRCLEtBQUtsb0IsV0FBVyxHQUFHO0FBRW5CLFNBQVNncUIsaUJBQWlCN3ZCLElBQUksRUFBRStQLGFBQWE7SUFDekMsSUFBSSxDQUFDL1AsS0FBS3lnQixVQUFVLEVBQUU7UUFDbEIsT0FBTztJQUNYO0lBQ0EsTUFBTUEsYUFBYTFRLGNBQWMyUSxHQUFHLENBQUMxZ0IsS0FBS3lnQixVQUFVO0lBQ3BELElBQUksQ0FBQ0EsWUFBWTtRQUNiLE9BQU87SUFDWDtJQUNBLElBQUlBLFdBQVdwRyxRQUFRLEVBQUU7UUFDckIsT0FBTztJQUNYO0lBQ0EsT0FBT3dWLGlCQUFpQnBQLFlBQVkxUTtBQUN4QztBQUNBLFNBQVMrZixZQUFZMXhCLE1BQU0sRUFBRTFCLFFBQVEsRUFBRXF6QixPQUFPO0lBQzFDLElBQUkxd0IsVUFBVWpCO0lBQ2QsR0FBRztRQUNDLElBQUlpQixTQUFTMndCLFFBQVF0ekIsV0FDakIsT0FBTztRQUNYLElBQUkyQyxZQUFZMHdCLFFBQVExd0IsT0FBTyxFQUMzQixPQUFPO1FBQ1hBLFVBQVVBLFFBQVE0d0IsYUFBYTtJQUNuQyxRQUFTNXdCLFNBQVM7SUFDbEIsT0FBTztBQUNYO0FBQ0EsMkVBQTJFO0FBQzNFLFNBQVM2d0IsYUFBYW5nQixhQUFhLEVBQUU4TCxjQUFjLEVBQUV1VCxRQUFRLEVBQUV2aUIsTUFBTTtJQUNqRSxPQUFPbVMsTUFBTW1SLElBQUksQ0FBQ3BnQixjQUFjcWdCLE1BQU0sSUFDakNqakIsTUFBTSxDQUFDLENBQUN2SyxJQUFNLENBQUNBLEVBQUV5WCxRQUFRLElBQUl6WCxFQUFFL0csRUFBRSxLQUFLZ1IsTUFBSyxLQUMzQyxFQUFDakssRUFBRTZkLFVBQVUsSUFBSSxDQUFDb1AsaUJBQWlCanRCLEdBQUdtTixjQUFhLEtBQ25Ebk4sQ0FBQUEsRUFBRXl0QixTQUFTLElBQUt4VSxrQkFBa0IsT0FBT2paLEVBQUV5dEIsU0FBUyxLQUFLLFdBQVcsR0FDcEVqakIsR0FBRyxDQUFDLENBQUN4SyxJQUFPO1lBQ2IvRyxJQUFJK0csRUFBRS9HLEVBQUU7WUFDUjBCLFVBQVVxRixFQUFFckYsUUFBUSxJQUFJO2dCQUFFZ0IsR0FBRztnQkFBR0MsR0FBRztZQUFFO1lBQ3JDdUQsa0JBQWtCYSxFQUFFYixnQkFBZ0IsSUFBSTtnQkFBRXhELEdBQUc7Z0JBQUdDLEdBQUc7WUFBRTtZQUNyRG1LLFVBQVU7Z0JBQ05wSyxHQUFHNndCLFNBQVM3d0IsQ0FBQyxHQUFJcUUsQ0FBQUEsRUFBRWIsZ0JBQWdCLEVBQUV4RCxLQUFLO2dCQUMxQ0MsR0FBRzR3QixTQUFTNXdCLENBQUMsR0FBSW9FLENBQUFBLEVBQUViLGdCQUFnQixFQUFFdkQsS0FBSztZQUM5QztZQUNBOHhCLE9BQU87Z0JBQ0gveEIsR0FBRztnQkFDSEMsR0FBRztZQUNQO1lBQ0FpQyxRQUFRbUMsRUFBRW5DLE1BQU07WUFDaEJnZ0IsWUFBWTdkLEVBQUU2ZCxVQUFVO1lBQ3hCdmhCLE9BQU8wRCxFQUFFMUQsS0FBSztZQUNkQyxRQUFReUQsRUFBRXpELE1BQU07WUFDaEI4dEIsY0FBY3JxQixFQUFFcXFCLFlBQVk7UUFDaEM7QUFDSjtBQUNBLFNBQVNzRCxnQkFBZ0J2d0IsSUFBSSxFQUFFUyxNQUFNO0lBQ2pDLElBQUksQ0FBQ0EsVUFBVUEsV0FBVyxVQUFVO1FBQ2hDLE9BQU9BO0lBQ1g7SUFDQSxPQUFPO1FBQUNBLE1BQU0sQ0FBQyxFQUFFO1FBQUU7WUFBQ0EsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUlULENBQUFBLEtBQUtkLEtBQUssSUFBSTtZQUFJdUIsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUlULENBQUFBLEtBQUtiLE1BQU0sSUFBSTtTQUFHO0tBQUM7QUFDN0Y7QUFDQSxTQUFTcXhCLGlCQUFpQnh3QixJQUFJLEVBQUV5d0IsWUFBWSxFQUFFMWdCLGFBQWEsRUFBRW9NLFVBQVUsRUFBRTNNLGFBQWE7SUFBQztJQUFHO0NBQUUsRUFBRWlKLE9BQU87SUFDakcsTUFBTWlZLG9CQUFvQkgsZ0JBQWdCdndCLE1BQU1BLEtBQUtTLE1BQU0sSUFBSTBiO0lBQy9ELElBQUl3VSxnQkFBZ0JEO0lBQ3BCLElBQUkxd0IsS0FBS1MsTUFBTSxLQUFLLFlBQVksQ0FBQ1QsS0FBS2l0QixZQUFZLEVBQUU7UUFDaEQsSUFBSWp0QixLQUFLeWdCLFVBQVUsSUFBSXpnQixLQUFLZCxLQUFLLElBQUljLEtBQUtiLE1BQU0sRUFBRTtZQUM5QyxNQUFNb3RCLFNBQVN4YyxjQUFjMlEsR0FBRyxDQUFDMWdCLEtBQUt5Z0IsVUFBVTtZQUNoRCxNQUFNLEVBQUVsaUIsR0FBR3F5QixPQUFPLEVBQUVweUIsR0FBR3F5QixPQUFPLEVBQUUsR0FBR3RoQiwwQkFBMEJnZCxRQUFRL2MsWUFBWXpOLGdCQUFnQjtZQUNqRzR1QixnQkFDSXBFLFVBQVU1cEIsVUFBVWl1QixZQUFZanVCLFVBQVVrdUIsWUFBWWx1QixVQUFVNHBCLE9BQU9ydEIsS0FBSyxLQUFLeUQsVUFBVTRwQixPQUFPcHRCLE1BQU0sSUFDbEc7Z0JBQ0U7b0JBQUN5eEIsVUFBVTV3QixLQUFLZCxLQUFLLEdBQUdzUSxVQUFVLENBQUMsRUFBRTtvQkFBRXFoQixVQUFVN3dCLEtBQUtiLE1BQU0sR0FBR3FRLFVBQVUsQ0FBQyxFQUFFO2lCQUFDO2dCQUM3RTtvQkFDSW9oQixVQUFVckUsT0FBT3J0QixLQUFLLEdBQUdjLEtBQUtkLEtBQUssR0FBR2MsS0FBS2QsS0FBSyxHQUFHc1EsVUFBVSxDQUFDLEVBQUU7b0JBQ2hFcWhCLFVBQVV0RSxPQUFPcHRCLE1BQU0sR0FBR2EsS0FBS2IsTUFBTSxHQUFHYSxLQUFLYixNQUFNLEdBQUdxUSxVQUFVLENBQUMsRUFBRTtpQkFDdEU7YUFDSixHQUNDbWhCO1FBQ2QsT0FDSztZQUNEbFksVUFBVSxPQUFPcmQsYUFBYSxDQUFDLFdBQVc7WUFDMUN1MUIsZ0JBQWdCRDtRQUNwQjtJQUNKLE9BQ0ssSUFBSTF3QixLQUFLUyxNQUFNLElBQUlULEtBQUt5Z0IsVUFBVSxJQUFJemdCLEtBQUtTLE1BQU0sS0FBSyxVQUFVO1FBQ2pFLE1BQU04ckIsU0FBU3hjLGNBQWMyUSxHQUFHLENBQUMxZ0IsS0FBS3lnQixVQUFVO1FBQ2hELE1BQU0sRUFBRWxpQixHQUFHcXlCLE9BQU8sRUFBRXB5QixHQUFHcXlCLE9BQU8sRUFBRSxHQUFHdGhCLDBCQUEwQmdkLFFBQVEvYyxZQUFZek4sZ0JBQWdCO1FBQ2pHNHVCLGdCQUFnQjtZQUNaO2dCQUFDM3dCLEtBQUtTLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHbXdCO2dCQUFTNXdCLEtBQUtTLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHb3dCO2FBQVE7WUFDMUQ7Z0JBQUM3d0IsS0FBS1MsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdtd0I7Z0JBQVM1d0IsS0FBS1MsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdvd0I7YUFBUTtTQUM3RDtJQUNMO0lBQ0EsSUFBSUMsaUJBQWlCO1FBQUV2eUIsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFDbEMsSUFBSXdCLEtBQUt5Z0IsVUFBVSxFQUFFO1FBQ2pCLE1BQU1BLGFBQWExUSxjQUFjMlEsR0FBRyxDQUFDMWdCLEtBQUt5Z0IsVUFBVTtRQUNwRHFRLGlCQUFpQnZoQiwwQkFBMEJrUixZQUFZalIsWUFBWXpOLGdCQUFnQjtJQUN2RjtJQUNBLE1BQU1BLG1CQUFtQjR1QixpQkFBaUJBLGtCQUFrQixXQUN0RG53QixjQUFjaXdCLGNBQWNFLGlCQUM1QkY7SUFDTixPQUFPO1FBQ0hsekIsVUFBVTtZQUNOZ0IsR0FBR3dELGlCQUFpQnhELENBQUMsR0FBR3V5QixlQUFldnlCLENBQUM7WUFDeENDLEdBQUd1RCxpQkFBaUJ2RCxDQUFDLEdBQUdzeUIsZUFBZXR5QixDQUFDO1FBQzVDO1FBQ0F1RDtJQUNKO0FBQ0o7QUFDQSxzQkFBc0I7QUFDdEIsc0ZBQXNGO0FBQ3RGLG9EQUFvRDtBQUNwRCxTQUFTZ3ZCLHNCQUFzQixFQUFFbGtCLE1BQU0sRUFBRW1rQixTQUFTLEVBQUVqaEIsYUFBYSxFQUFHO0lBQ2hFLE1BQU1raEIsb0JBQW9CRCxVQUFVNWpCLEdBQUcsQ0FBQyxDQUFDeEs7UUFDckMsTUFBTTVDLE9BQU8rUCxjQUFjMlEsR0FBRyxDQUFDOWQsRUFBRS9HLEVBQUU7UUFDbkMsT0FBTztZQUNILEdBQUdtRSxJQUFJO1lBQ1B6QyxVQUFVcUYsRUFBRXJGLFFBQVE7WUFDcEJ3RSxrQkFBa0JhLEVBQUViLGdCQUFnQjtRQUN4QztJQUNKO0lBQ0EsT0FBTztRQUFDOEssU0FBU29rQixrQkFBa0I1cUIsSUFBSSxDQUFDLENBQUN6RCxJQUFNQSxFQUFFL0csRUFBRSxLQUFLZ1IsVUFBVW9rQixpQkFBaUIsQ0FBQyxFQUFFO1FBQUVBO0tBQWtCO0FBQzlHO0FBRUEsTUFBTUMsa0JBQWtCLENBQUN4MEIsVUFBVXkwQixhQUFhdjJCLE1BQU00VTtJQUNsRCxNQUFNK0MsVUFBVTRlLFlBQVlDLGdCQUFnQixDQUFDMTBCO0lBQzdDLElBQUksQ0FBQzZWLFdBQVcsQ0FBQ0EsUUFBUXpHLE1BQU0sRUFBRTtRQUM3QixPQUFPO0lBQ1g7SUFDQSxNQUFNdWxCLGVBQWVyUyxNQUFNbVIsSUFBSSxDQUFDNWQ7SUFDaEMsTUFBTStlLGFBQWFILFlBQVk5YSxxQkFBcUI7SUFDcEQsTUFBTWtiLGFBQWE7UUFDZmh6QixHQUFHK3lCLFdBQVdweUIsS0FBSyxHQUFHc1EsVUFBVSxDQUFDLEVBQUU7UUFDbkNoUixHQUFHOHlCLFdBQVdueUIsTUFBTSxHQUFHcVEsVUFBVSxDQUFDLEVBQUU7SUFDeEM7SUFDQSxPQUFPNmhCLGFBQWFqa0IsR0FBRyxDQUFDLENBQUNnRztRQUNyQixNQUFNbkIsZUFBZW1CLE9BQU9pRCxxQkFBcUI7UUFDakQsT0FBTztZQUNIeGEsSUFBSXVYLE9BQU9MLFlBQVksQ0FBQztZQUN4QnhWLFVBQVU2VixPQUFPTCxZQUFZLENBQUM7WUFDOUJ4VSxHQUFHLENBQUMwVCxhQUFhdE4sSUFBSSxHQUFHMnNCLFdBQVczc0IsSUFBSSxHQUFHNHNCLFdBQVdoekIsQ0FBQyxJQUFJM0Q7WUFDMUQ0RCxHQUFHLENBQUN5VCxhQUFhck4sR0FBRyxHQUFHMHNCLFdBQVcxc0IsR0FBRyxHQUFHMnNCLFdBQVcveUIsQ0FBQyxJQUFJNUQ7WUFDeEQsR0FBR21GLGNBQWNxVCxPQUFPO1FBQzVCO0lBQ0o7QUFDSjtBQUNBLFNBQVNvZSxnQkFBZ0IzMUIsRUFBRSxFQUFFa0IsUUFBUSxFQUFFbUosT0FBTztJQUMxQyxPQUFPQSxZQUFZQyxZQUNiRCxVQUNBLENBQUN6QztRQUNDLE1BQU16RCxPQUFPakQsV0FBV2dULGFBQWEsQ0FBQzJRLEdBQUcsQ0FBQzdrQjtRQUMxQyxJQUFJbUUsTUFBTTtZQUNOa0csUUFBUXpDLE9BQU87Z0JBQUUsR0FBR3pELElBQUk7WUFBQztRQUM3QjtJQUNKO0FBQ1I7QUFDQSw0QkFBNEI7QUFDNUIsK0VBQStFO0FBQy9FLEtBQUs7QUFDTCxtRkFBbUY7QUFDbkYsU0FBU3l4QixnQkFBZ0IsRUFBRTUxQixFQUFFLEVBQUVlLEtBQUssRUFBRTgwQixXQUFXLEtBQUssRUFBRTNCLE9BQU8sRUFBRztJQUM5RCxNQUFNLEVBQUU0QixnQkFBZ0IsRUFBRUMscUJBQXFCLEVBQUU1SyxvQkFBb0IsRUFBRWpYLGFBQWEsRUFBRTBJLE9BQU8sRUFBRSxHQUFHN2IsTUFBTUcsUUFBUTtJQUNoSCxNQUFNaUQsT0FBTytQLGNBQWMyUSxHQUFHLENBQUM3a0I7SUFDL0IsSUFBSSxDQUFDbUUsTUFBTTtRQUNQeVksVUFBVSxPQUFPcmQsYUFBYSxDQUFDLFdBQVcsQ0FBQ1M7UUFDM0M7SUFDSjtJQUNBZSxNQUFNSSxRQUFRLENBQUM7UUFBRStwQixzQkFBc0I7SUFBTTtJQUM3QyxJQUFJLENBQUMvbUIsS0FBS3FhLFFBQVEsRUFBRTtRQUNoQnNYLGlCQUFpQjtZQUFDOTFCO1NBQUc7SUFDekIsT0FDSyxJQUFJNjFCLFlBQWExeEIsS0FBS3FhLFFBQVEsSUFBSTJNLHNCQUF1QjtRQUMxRDRLLHNCQUFzQjtZQUFFM2tCLE9BQU87Z0JBQUNqTjthQUFLO1lBQUVvRyxPQUFPLEVBQUU7UUFBQztRQUNqRHVRLHNCQUFzQixJQUFNb1osU0FBUzF3QixTQUFTd3lCO0lBQ2xEO0FBQ0o7QUFFQSxTQUFTQztJQUNMLE1BQU1sMUIsUUFBUUU7SUFDZCxxRUFBcUU7SUFDckUsTUFBTWkxQixxQkFBcUJ6M0Isa0RBQVdBLENBQUMsQ0FBQyxFQUFFcXhCLFdBQVcsRUFBRTtRQUNuRCxNQUFNLEVBQUVuc0IsU0FBUyxFQUFFK2MsUUFBUSxFQUFFck4sVUFBVSxFQUFFLEdBQUd0UyxNQUFNRyxRQUFRO1FBQzFELE1BQU13QixJQUFJb3RCLFlBQVlubkIsT0FBTyxHQUFHbW5CLFlBQVlubkIsT0FBTyxDQUFDLEVBQUUsQ0FBQ0QsT0FBTyxHQUFHb25CLFlBQVlwbkIsT0FBTztRQUNwRixNQUFNL0YsSUFBSW10QixZQUFZbm5CLE9BQU8sR0FBR21uQixZQUFZbm5CLE9BQU8sQ0FBQyxFQUFFLENBQUNFLE9BQU8sR0FBR2luQixZQUFZam5CLE9BQU87UUFDcEYsTUFBTXN0QixhQUFhO1lBQ2Z6ekIsR0FBRyxDQUFDQSxJQUFJaUIsU0FBUyxDQUFDLEVBQUUsSUFBSUEsU0FBUyxDQUFDLEVBQUU7WUFDcENoQixHQUFHLENBQUNBLElBQUlnQixTQUFTLENBQUMsRUFBRSxJQUFJQSxTQUFTLENBQUMsRUFBRTtRQUN4QztRQUNBLG1GQUFtRjtRQUNuRixPQUFPO1lBQ0h5eUIsVUFBVS9pQixhQUFhcU4sUUFBUSxDQUFDLEVBQUUsR0FBR2hjLEtBQUs4TyxLQUFLLENBQUMyaUIsV0FBV3p6QixDQUFDLEdBQUdnZSxRQUFRLENBQUMsRUFBRSxJQUFJeVYsV0FBV3p6QixDQUFDO1lBQzFGMnpCLFVBQVVoakIsYUFBYXFOLFFBQVEsQ0FBQyxFQUFFLEdBQUdoYyxLQUFLOE8sS0FBSyxDQUFDMmlCLFdBQVd4ekIsQ0FBQyxHQUFHK2QsUUFBUSxDQUFDLEVBQUUsSUFBSXlWLFdBQVd4ekIsQ0FBQztZQUMxRixHQUFHd3pCLFVBQVU7UUFDakI7SUFDSixHQUFHLEVBQUU7SUFDTCxPQUFPRDtBQUNYO0FBRUEsU0FBU0ksc0JBQXNCQyxhQUFhO0lBQ3hDLE9BQU8sQ0FBQzN1QixPQUFPNHVCLEdBQUdwbEIsUUFBVW1sQixnQkFBZ0IzdUIsT0FBT3dKO0FBQ3ZEO0FBQ0EsU0FBU3FsQixRQUFRLEVBQUV2QyxPQUFPLEVBQUV3QyxXQUFXLEtBQUssRUFBRUMsZUFBZSxFQUFFQyxjQUFjLEVBQUU1bEIsTUFBTSxFQUFFNmxCLFlBQVksRUFBRUMsaUJBQWlCLEVBQUc7SUFDckgsTUFBTS8xQixRQUFRRTtJQUNkLE1BQU0sQ0FBQ2dVLFVBQVU4aEIsWUFBWSxHQUFHejRCLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU02MkIsWUFBWTkyQiw2Q0FBTUEsQ0FBQyxFQUFFO0lBQzNCLE1BQU0yNEIsVUFBVTM0Qiw2Q0FBTUEsQ0FBQztRQUFFcUUsR0FBRztRQUFNQyxHQUFHO0lBQUs7SUFDMUMsTUFBTXdYLFlBQVk5Yiw2Q0FBTUEsQ0FBQztJQUN6QixNQUFNa2Msa0JBQWtCbGMsNkNBQU1BLENBQUM7SUFDL0IsTUFBTTQ0QixnQkFBZ0I1NEIsNkNBQU1BLENBQUM7UUFBRXFFLEdBQUc7UUFBR0MsR0FBRztJQUFFO0lBQzFDLE1BQU11MEIsWUFBWTc0Qiw2Q0FBTUEsQ0FBQztJQUN6QixNQUFNc2MsaUJBQWlCdGMsNkNBQU1BLENBQUM7SUFDOUIsTUFBTTg0QixjQUFjOTRCLDZDQUFNQSxDQUFDO0lBQzNCLE1BQU02M0IscUJBQXFCRDtJQUMzQjEzQixnREFBU0EsQ0FBQztRQUNOLElBQUkyMUIsU0FBUzF3QixTQUFTO1lBQ2xCLE1BQU13UyxZQUFZaFgsd0RBQU1BLENBQUNrMUIsUUFBUTF3QixPQUFPO1lBQ3hDLE1BQU00ekIsY0FBYyxDQUFDLEVBQUUxMEIsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7Z0JBQ3pCLE1BQU0sRUFBRXVSLGFBQWEsRUFBRThNLFVBQVUsRUFBRUcsZUFBZSxFQUFFa1csbUJBQW1CLEVBQUUvVyxVQUFVLEVBQUVJLFFBQVEsRUFBRXJOLFVBQVUsRUFBRU0sVUFBVSxFQUFFaUosT0FBTyxFQUFHLEdBQUc3YixNQUFNRyxRQUFRO2dCQUNsSjgxQixRQUFReHpCLE9BQU8sR0FBRztvQkFBRWQ7b0JBQUdDO2dCQUFFO2dCQUN6QixJQUFJMjBCLFlBQVk7Z0JBQ2hCLElBQUlDLFdBQVc7b0JBQUU3MEIsR0FBRztvQkFBR0MsR0FBRztvQkFBR2tELElBQUk7b0JBQUdDLElBQUk7Z0JBQUU7Z0JBQzFDLElBQUlxdkIsVUFBVTN4QixPQUFPLENBQUN5TSxNQUFNLEdBQUcsS0FBS3FRLFlBQVk7b0JBQzVDLE1BQU1uTSxPQUFPUCxlQUFldWhCLFVBQVUzeEIsT0FBTyxFQUFFbVE7b0JBQy9DNGpCLFdBQVd4eEIsVUFBVW9PO2dCQUN6QjtnQkFDQWdoQixVQUFVM3hCLE9BQU8sR0FBRzJ4QixVQUFVM3hCLE9BQU8sQ0FBQytOLEdBQUcsQ0FBQyxDQUFDeEs7b0JBQ3ZDLE1BQU02dEIsZUFBZTt3QkFBRWx5QixHQUFHQSxJQUFJcUUsRUFBRStGLFFBQVEsQ0FBQ3BLLENBQUM7d0JBQUVDLEdBQUdBLElBQUlvRSxFQUFFK0YsUUFBUSxDQUFDbkssQ0FBQztvQkFBQztvQkFDaEUsSUFBSTBRLFlBQVk7d0JBQ1p1aEIsYUFBYWx5QixDQUFDLEdBQUdnZSxRQUFRLENBQUMsRUFBRSxHQUFHaGMsS0FBSzhPLEtBQUssQ0FBQ29oQixhQUFhbHlCLENBQUMsR0FBR2dlLFFBQVEsQ0FBQyxFQUFFO3dCQUN0RWtVLGFBQWFqeUIsQ0FBQyxHQUFHK2QsUUFBUSxDQUFDLEVBQUUsR0FBR2hjLEtBQUs4TyxLQUFLLENBQUNvaEIsYUFBYWp5QixDQUFDLEdBQUcrZCxRQUFRLENBQUMsRUFBRTtvQkFDMUU7b0JBQ0Esc0hBQXNIO29CQUN0SCwyRkFBMkY7b0JBQzNGLE1BQU04VyxxQkFBcUI7d0JBQ3ZCOzRCQUFDbFgsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFOzRCQUFFQSxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUU7eUJBQUM7d0JBQ3BDOzRCQUFDQSxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUU7NEJBQUVBLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRTt5QkFBQztxQkFDdkM7b0JBQ0QsSUFBSTZVLFVBQVUzeEIsT0FBTyxDQUFDeU0sTUFBTSxHQUFHLEtBQUtxUSxjQUFjLENBQUN2WixFQUFFbkMsTUFBTSxFQUFFO3dCQUN6RDR5QixrQkFBa0IsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHendCLEVBQUViLGdCQUFnQixDQUFDeEQsQ0FBQyxHQUFHNjBCLFNBQVM3MEIsQ0FBQyxHQUFHNGQsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO3dCQUMvRWtYLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUd6d0IsRUFBRWIsZ0JBQWdCLENBQUN4RCxDQUFDLEdBQUlxRSxDQUFBQSxFQUFFMUQsS0FBSyxJQUFJLEtBQUtrMEIsU0FBUzF4QixFQUFFLEdBQUd5YSxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUU7d0JBQ2pHa1gsa0JBQWtCLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR3p3QixFQUFFYixnQkFBZ0IsQ0FBQ3ZELENBQUMsR0FBRzQwQixTQUFTNTBCLENBQUMsR0FBRzJkLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRTt3QkFDL0VrWCxrQkFBa0IsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHendCLEVBQUViLGdCQUFnQixDQUFDdkQsQ0FBQyxHQUFJb0UsQ0FBQUEsRUFBRXpELE1BQU0sSUFBSSxLQUFLaTBCLFNBQVN6eEIsRUFBRSxHQUFHd2EsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO29CQUN0RztvQkFDQSxNQUFNbVgsYUFBYTlDLGlCQUFpQjV0QixHQUFHNnRCLGNBQWMxZ0IsZUFBZXNqQixvQkFBb0I3akIsWUFBWWlKO29CQUNwRywrRUFBK0U7b0JBQy9FMGEsWUFBWUEsYUFBYXZ3QixFQUFFckYsUUFBUSxDQUFDZ0IsQ0FBQyxLQUFLKzBCLFdBQVcvMUIsUUFBUSxDQUFDZ0IsQ0FBQyxJQUFJcUUsRUFBRXJGLFFBQVEsQ0FBQ2lCLENBQUMsS0FBSzgwQixXQUFXLzFCLFFBQVEsQ0FBQ2lCLENBQUM7b0JBQ3pHb0UsRUFBRXJGLFFBQVEsR0FBRysxQixXQUFXLzFCLFFBQVE7b0JBQ2hDcUYsRUFBRWIsZ0JBQWdCLEdBQUd1eEIsV0FBV3Z4QixnQkFBZ0I7b0JBQ2hELE9BQU9hO2dCQUNYO2dCQUNBLElBQUksQ0FBQ3V3QixXQUFXO29CQUNaO2dCQUNKO2dCQUNBRCxvQkFBb0JsQyxVQUFVM3hCLE9BQU8sRUFBRSxNQUFNO2dCQUM3Q3V6QixZQUFZO2dCQUNaLE1BQU1XLFNBQVMxbUIsU0FBU2dRLGFBQWFzVixzQkFBc0JuVjtnQkFDM0QsSUFBSXVXLFVBQVVSLFVBQVUxekIsT0FBTyxFQUFFO29CQUM3QixNQUFNLENBQUNtMEIsYUFBYXZtQixNQUFNLEdBQUc4akIsc0JBQXNCO3dCQUMvQ2xrQjt3QkFDQW1rQixXQUFXQSxVQUFVM3hCLE9BQU87d0JBQzVCMFE7b0JBQ0o7b0JBQ0F3akIsT0FBT1IsVUFBVTF6QixPQUFPLEVBQUVtMEIsYUFBYXZtQjtnQkFDM0M7WUFDSjtZQUNBLE1BQU15SixVQUFVO2dCQUNaLElBQUksQ0FBQ04sZ0JBQWdCL1csT0FBTyxFQUFFO29CQUMxQjtnQkFDSjtnQkFDQSxNQUFNLENBQUMyQixXQUFXQyxVQUFVLEdBQUdKLFlBQVlpeUIsY0FBY3p6QixPQUFPLEVBQUUrVyxnQkFBZ0IvVyxPQUFPO2dCQUN6RixJQUFJMkIsY0FBYyxLQUFLQyxjQUFjLEdBQUc7b0JBQ3BDLE1BQU0sRUFBRXpCLFNBQVMsRUFBRXFXLEtBQUssRUFBRSxHQUFHalosTUFBTUcsUUFBUTtvQkFDM0M4MUIsUUFBUXh6QixPQUFPLENBQUNkLENBQUMsR0FBRyxDQUFDczBCLFFBQVF4ekIsT0FBTyxDQUFDZCxDQUFDLElBQUksS0FBS3lDLFlBQVl4QixTQUFTLENBQUMsRUFBRTtvQkFDdkVxekIsUUFBUXh6QixPQUFPLENBQUNiLENBQUMsR0FBRyxDQUFDcTBCLFFBQVF4ekIsT0FBTyxDQUFDYixDQUFDLElBQUksS0FBS3lDLFlBQVl6QixTQUFTLENBQUMsRUFBRTtvQkFDdkUsSUFBSXFXLE1BQU07d0JBQUV0WCxHQUFHeUM7d0JBQVd4QyxHQUFHeUM7b0JBQVUsSUFBSTt3QkFDdkNneUIsWUFBWUosUUFBUXh6QixPQUFPO29CQUMvQjtnQkFDSjtnQkFDQTJXLFVBQVUzVyxPQUFPLEdBQUdzWCxzQkFBc0JEO1lBQzlDO1lBQ0EsTUFBTStjLFlBQVksQ0FBQ2h3QjtnQkFDZixNQUFNLEVBQUVzTSxhQUFhLEVBQUVpWCxvQkFBb0IsRUFBRW5MLGNBQWMsRUFBRStWLHFCQUFxQixFQUFFOVUsZUFBZSxFQUFFRyxvQkFBb0IsRUFBRyxHQUFHcmdCLE1BQU1HLFFBQVE7Z0JBQzdJaTJCLFlBQVkzekIsT0FBTyxHQUFHO2dCQUN0QixNQUFNcTBCLFVBQVU3bUIsU0FBU2lRLGtCQUFrQnFWLHNCQUFzQmxWO2dCQUNqRSxJQUFJLENBQUMsQ0FBQzBWLHFCQUFxQixDQUFDRCxZQUFXLEtBQU0sQ0FBQzFMLHdCQUF3Qm5hLFFBQVE7b0JBQzFFLElBQUksQ0FBQ2tELGNBQWMyUSxHQUFHLENBQUM3VCxTQUFTd04sVUFBVTt3QkFDdEMsK0RBQStEO3dCQUMvRHVYO29CQUNKO2dCQUNKO2dCQUNBLElBQUkva0IsVUFBVTZsQixnQkFBZ0JDLG1CQUFtQjtvQkFDN0NsQixnQkFBZ0I7d0JBQ1o1MUIsSUFBSWdSO3dCQUNKalE7d0JBQ0FtekIsU0FBU0E7b0JBQ2I7Z0JBQ0o7Z0JBQ0EsTUFBTWlDLGFBQWFELG1CQUFtQnR1QjtnQkFDdENvdkIsUUFBUXh6QixPQUFPLEdBQUcyeUI7Z0JBQ2xCaEIsVUFBVTN4QixPQUFPLEdBQUc2d0IsYUFBYW5nQixlQUFlOEwsZ0JBQWdCbVcsWUFBWW5sQjtnQkFDNUUsSUFBSTZtQixXQUFXMUMsVUFBVTN4QixPQUFPLEVBQUU7b0JBQzlCLE1BQU0sQ0FBQ20wQixhQUFhdm1CLE1BQU0sR0FBRzhqQixzQkFBc0I7d0JBQy9DbGtCO3dCQUNBbWtCLFdBQVdBLFVBQVUzeEIsT0FBTzt3QkFDNUIwUTtvQkFDSjtvQkFDQTJqQixRQUFRandCLE1BQU1rb0IsV0FBVyxFQUFFNkgsYUFBYXZtQjtnQkFDNUM7WUFDSjtZQUNBLElBQUlzbEIsVUFBVTtnQkFDVjFnQixVQUFVMFksRUFBRSxDQUFDLFNBQVM7WUFDMUIsT0FDSztnQkFDRCxNQUFNb0osY0FBYzU0QixtREFBSUEsR0FDbkJ3dkIsRUFBRSxDQUFDLFNBQVMsQ0FBQzltQjtvQkFDZCxNQUFNLEVBQUVpUyxPQUFPLEVBQUUwSCxpQkFBaUIsRUFBRSxHQUFHeGdCLE1BQU1HLFFBQVE7b0JBQ3JELElBQUlxZ0Isc0JBQXNCLEdBQUc7d0JBQ3pCcVcsVUFBVWh3QjtvQkFDZDtvQkFDQSxNQUFNdXVCLGFBQWFELG1CQUFtQnR1QjtvQkFDdENvdkIsUUFBUXh6QixPQUFPLEdBQUcyeUI7b0JBQ2xCNWIsZ0JBQWdCL1csT0FBTyxHQUFHcVcsU0FBU1csMkJBQTJCO29CQUM5RHljLGNBQWN6ekIsT0FBTyxHQUFHK0UsaUJBQWlCWCxNQUFNa29CLFdBQVcsRUFBRXZWLGdCQUFnQi9XLE9BQU87Z0JBQ3ZGLEdBQ0trckIsRUFBRSxDQUFDLFFBQVEsQ0FBQzltQjtvQkFDYixNQUFNdXVCLGFBQWFELG1CQUFtQnR1QjtvQkFDdEMsTUFBTSxFQUFFMFosaUJBQWlCLEVBQUVDLGlCQUFpQixFQUFFLEdBQUd4Z0IsTUFBTUcsUUFBUTtvQkFDL0QsSUFBSSxDQUFDeVosZUFBZW5YLE9BQU8sSUFBSTJ6QixZQUFZM3pCLE9BQU8sSUFBSThkLG1CQUFtQjt3QkFDckUzRyxlQUFlblgsT0FBTyxHQUFHO3dCQUN6QnFYO29CQUNKO29CQUNBLElBQUksQ0FBQ3NjLFlBQVkzekIsT0FBTyxFQUFFO3dCQUN0QixNQUFNZCxJQUFJeXpCLFdBQVdDLFFBQVEsR0FBSVksQ0FBQUEsU0FBU3h6QixTQUFTZCxLQUFLO3dCQUN4RCxNQUFNQyxJQUFJd3pCLFdBQVdFLFFBQVEsR0FBSVcsQ0FBQUEsU0FBU3h6QixTQUFTYixLQUFLO3dCQUN4RCxNQUFNbUssV0FBV3BJLEtBQUt1SSxJQUFJLENBQUN2SyxJQUFJQSxJQUFJQyxJQUFJQTt3QkFDdkMsSUFBSW1LLFdBQVd5VSxtQkFBbUI7NEJBQzlCcVcsVUFBVWh3Qjt3QkFDZDtvQkFDSjtvQkFDQSwrQkFBK0I7b0JBQy9CLElBQUksQ0FBQ292QixRQUFReHpCLE9BQU8sQ0FBQ2QsQ0FBQyxLQUFLeXpCLFdBQVdDLFFBQVEsSUFBSVksUUFBUXh6QixPQUFPLENBQUNiLENBQUMsS0FBS3d6QixXQUFXRSxRQUFRLEtBQ3ZGbEIsVUFBVTN4QixPQUFPLElBQ2pCMnpCLFlBQVkzekIsT0FBTyxFQUFFO3dCQUNyQjB6QixVQUFVMXpCLE9BQU8sR0FBR29FLE1BQU1rb0IsV0FBVzt3QkFDckNtSCxjQUFjenpCLE9BQU8sR0FBRytFLGlCQUFpQlgsTUFBTWtvQixXQUFXLEVBQUV2VixnQkFBZ0IvVyxPQUFPO3dCQUNuRjR6QixZQUFZakI7b0JBQ2hCO2dCQUNKLEdBQ0t6SCxFQUFFLENBQUMsT0FBTyxDQUFDOW1CO29CQUNaLElBQUksQ0FBQ3V2QixZQUFZM3pCLE9BQU8sRUFBRTt3QkFDdEI7b0JBQ0o7b0JBQ0F1ekIsWUFBWTtvQkFDWnBjLGVBQWVuWCxPQUFPLEdBQUc7b0JBQ3pCMnpCLFlBQVkzekIsT0FBTyxHQUFHO29CQUN0QmlZLHFCQUFxQnRCLFVBQVUzVyxPQUFPO29CQUN0QyxJQUFJMnhCLFVBQVUzeEIsT0FBTyxFQUFFO3dCQUNuQixNQUFNLEVBQUU2ekIsbUJBQW1CLEVBQUVuakIsYUFBYSxFQUFFZ04sY0FBYyxFQUFFRyxtQkFBbUIsRUFBRSxHQUFHdGdCLE1BQU1HLFFBQVE7d0JBQ2xHLE1BQU02MkIsU0FBUy9tQixTQUFTa1EsaUJBQWlCb1Ysc0JBQXNCalY7d0JBQy9EZ1csb0JBQW9CbEMsVUFBVTN4QixPQUFPLEVBQUUsT0FBTzt3QkFDOUMsSUFBSXUwQixRQUFROzRCQUNSLE1BQU0sQ0FBQ0osYUFBYXZtQixNQUFNLEdBQUc4akIsc0JBQXNCO2dDQUMvQ2xrQjtnQ0FDQW1rQixXQUFXQSxVQUFVM3hCLE9BQU87Z0NBQzVCMFE7NEJBQ0o7NEJBQ0E2akIsT0FBT253QixNQUFNa29CLFdBQVcsRUFBRTZILGFBQWF2bUI7d0JBQzNDO29CQUNKO2dCQUNKLEdBQ0tFLE1BQU0sQ0FBQyxDQUFDMUo7b0JBQ1QsTUFBTXJGLFNBQVNxRixNQUFNckYsTUFBTTtvQkFDM0IsTUFBTXkxQixjQUFjLENBQUNwd0IsTUFBTXdWLE1BQU0sSUFDNUIsRUFBQ3VaLG1CQUFtQixDQUFDMUMsWUFBWTF4QixRQUFRLENBQUMsQ0FBQyxFQUFFbzBCLGdCQUFnQixDQUFDLEVBQUV6QyxRQUFPLEtBQ3ZFLEVBQUMwQyxrQkFBa0IzQyxZQUFZMXhCLFFBQVFxMEIsZ0JBQWdCMUMsUUFBTztvQkFDbkUsT0FBTzhEO2dCQUNYO2dCQUNBaGlCLFVBQVVzWSxJQUFJLENBQUN3SjtnQkFDZixPQUFPO29CQUNIOWhCLFVBQVUwWSxFQUFFLENBQUMsU0FBUztnQkFDMUI7WUFDSjtRQUNKO0lBQ0osR0FBRztRQUNDd0Y7UUFDQXdDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0E5MUI7UUFDQWlRO1FBQ0E4bEI7UUFDQVo7S0FDSDtJQUNELE9BQU9qaEI7QUFDWDtBQUVBLFNBQVNnakI7SUFDTCxNQUFNbDNCLFFBQVFFO0lBQ2QsTUFBTWkzQixrQkFBa0J6NUIsa0RBQVdBLENBQUMsQ0FBQ3FlO1FBQ2pDLE1BQU0sRUFBRTVJLGFBQWEsRUFBRW9NLFVBQVUsRUFBRStXLG1CQUFtQixFQUFFcGQsUUFBUSxFQUFFNUcsVUFBVSxFQUFFcU4sUUFBUSxFQUFFOUQsT0FBTyxFQUFFb0QsY0FBYyxFQUFFLEdBQUdqZixNQUFNRyxRQUFRO1FBQ2xJLE1BQU1xZCxnQkFBZ0J0RSxXQUFXM0ksTUFBTSxDQUFDLENBQUN2SyxJQUFNQSxFQUFFeVgsUUFBUSxJQUFLelgsQ0FBQUEsRUFBRXl0QixTQUFTLElBQUt4VSxrQkFBa0IsT0FBT2paLEVBQUV5dEIsU0FBUyxLQUFLLFdBQVc7UUFDbEksNkVBQTZFO1FBQzdFLHlEQUF5RDtRQUN6RCxNQUFNMkQsUUFBUTlrQixhQUFhcU4sUUFBUSxDQUFDLEVBQUUsR0FBRztRQUN6QyxNQUFNMFgsUUFBUS9rQixhQUFhcU4sUUFBUSxDQUFDLEVBQUUsR0FBRztRQUN6QyxNQUFNMkwsU0FBU3ZQLE9BQU91YixjQUFjLEdBQUcsSUFBSTtRQUMzQyxNQUFNQyxnQkFBZ0J4YixPQUFPcGEsQ0FBQyxHQUFHeTFCLFFBQVE5TDtRQUN6QyxNQUFNa00sZ0JBQWdCemIsT0FBT25hLENBQUMsR0FBR3kxQixRQUFRL0w7UUFDekMsTUFBTW1NLGNBQWNqYSxjQUFjaE4sR0FBRyxDQUFDLENBQUN4SztZQUNuQyxJQUFJQSxFQUFFYixnQkFBZ0IsRUFBRTtnQkFDcEIsTUFBTTB1QixlQUFlO29CQUFFbHlCLEdBQUdxRSxFQUFFYixnQkFBZ0IsQ0FBQ3hELENBQUMsR0FBRzQxQjtvQkFBZTMxQixHQUFHb0UsRUFBRWIsZ0JBQWdCLENBQUN2RCxDQUFDLEdBQUc0MUI7Z0JBQWM7Z0JBQ3hHLElBQUlsbEIsWUFBWTtvQkFDWnVoQixhQUFhbHlCLENBQUMsR0FBR2dlLFFBQVEsQ0FBQyxFQUFFLEdBQUdoYyxLQUFLOE8sS0FBSyxDQUFDb2hCLGFBQWFseUIsQ0FBQyxHQUFHZ2UsUUFBUSxDQUFDLEVBQUU7b0JBQ3RFa1UsYUFBYWp5QixDQUFDLEdBQUcrZCxRQUFRLENBQUMsRUFBRSxHQUFHaGMsS0FBSzhPLEtBQUssQ0FBQ29oQixhQUFhanlCLENBQUMsR0FBRytkLFFBQVEsQ0FBQyxFQUFFO2dCQUMxRTtnQkFDQSxNQUFNLEVBQUV4YSxnQkFBZ0IsRUFBRXhFLFFBQVEsRUFBRSxHQUFHaXpCLGlCQUFpQjV0QixHQUFHNnRCLGNBQWMxZ0IsZUFBZW9NLFlBQVloVyxXQUFXc1M7Z0JBQy9HN1YsRUFBRXJGLFFBQVEsR0FBR0E7Z0JBQ2JxRixFQUFFYixnQkFBZ0IsR0FBR0E7WUFDekI7WUFDQSxPQUFPYTtRQUNYO1FBQ0Fzd0Isb0JBQW9CbUIsYUFBYSxNQUFNO0lBQzNDLEdBQUcsRUFBRTtJQUNMLE9BQU9OO0FBQ1g7QUFFQSxNQUFNTyxnQkFBZ0I7SUFDbEJDLFNBQVM7UUFBRWgyQixHQUFHO1FBQUdDLEdBQUcsQ0FBQztJQUFFO0lBQ3ZCZzJCLFdBQVc7UUFBRWoyQixHQUFHO1FBQUdDLEdBQUc7SUFBRTtJQUN4QmkyQixXQUFXO1FBQUVsMkIsR0FBRyxDQUFDO1FBQUdDLEdBQUc7SUFBRTtJQUN6QmsyQixZQUFZO1FBQUVuMkIsR0FBRztRQUFHQyxHQUFHO0lBQUU7QUFDN0I7QUFDQSxJQUFJbTJCLFdBQVcsQ0FBQ0M7SUFDWixNQUFNQyxjQUFjLENBQUMsRUFBRWg1QixFQUFFLEVBQUVFLElBQUksRUFBRTZkLElBQUksRUFBRWtiLElBQUksRUFBRUMsSUFBSSxFQUFFQyxVQUFVLEVBQUVDLFVBQVUsRUFBRTVhLFFBQVEsRUFBRW5CLE9BQU8sRUFBRTBXLFlBQVksRUFBRVQsV0FBVyxFQUFFTyxZQUFZLEVBQUVYLGFBQWEsRUFBRW1HLGFBQWEsRUFBRXgzQixLQUFLLEVBQUVELFNBQVMsRUFBRW8yQixXQUFXLEVBQUVuQixZQUFZLEVBQUUvZCxhQUFhLEVBQUV3Z0IsV0FBVyxFQUFFeEMsaUJBQWlCLEVBQUV4cUIsY0FBYyxFQUFFRSxjQUFjLEVBQUVrSSxNQUFNLEVBQUU0VyxjQUFjLEVBQUVpTyxVQUFVLEVBQUVoVSxNQUFNLEVBQUVMLFFBQVEsRUFBRXlSLGVBQWUsRUFBRTVhLGNBQWMsRUFBRXlkLFdBQVcsRUFBRWpYLG1CQUFtQixFQUFFa1gsU0FBUyxFQUFFNW5CLElBQUksRUFBRztRQUN4YSxNQUFNOVEsUUFBUUU7UUFDZCxNQUFNaXpCLFVBQVU3MUIsNkNBQU1BLENBQUM7UUFDdkIsTUFBTXE3QixxQkFBcUJyN0IsNkNBQU1BLENBQUNpTztRQUNsQyxNQUFNcXRCLHFCQUFxQnQ3Qiw2Q0FBTUEsQ0FBQ21PO1FBQ2xDLE1BQU1vdEIsV0FBV3Y3Qiw2Q0FBTUEsQ0FBQzZCO1FBQ3hCLE1BQU0yNUIsbUJBQW1CaEQsZ0JBQWdCbUIsZUFBZTNhLFdBQVcwVyxnQkFBZ0JULGVBQWVPO1FBQ2xHLE1BQU1xRSxrQkFBa0JEO1FBQ3hCLE1BQU02QixzQkFBc0JuRSxnQkFBZ0IzMUIsSUFBSWUsTUFBTUcsUUFBUSxFQUFFNnlCO1FBQ2hFLE1BQU1nRyxxQkFBcUJwRSxnQkFBZ0IzMUIsSUFBSWUsTUFBTUcsUUFBUSxFQUFFb3lCO1FBQy9ELE1BQU0wRyxzQkFBc0JyRSxnQkFBZ0IzMUIsSUFBSWUsTUFBTUcsUUFBUSxFQUFFMnlCO1FBQ2hFLE1BQU1vRyx1QkFBdUJ0RSxnQkFBZ0IzMUIsSUFBSWUsTUFBTUcsUUFBUSxFQUFFZ3lCO1FBQ2pFLE1BQU1nSCx1QkFBdUJ2RSxnQkFBZ0IzMUIsSUFBSWUsTUFBTUcsUUFBUSxFQUFFbTRCO1FBQ2pFLE1BQU1jLHNCQUFzQixDQUFDdnlCO1lBQ3pCLE1BQU0sRUFBRTJaLGlCQUFpQixFQUFFLEdBQUd4Z0IsTUFBTUcsUUFBUTtZQUM1QyxJQUFJMjFCLGdCQUFpQixFQUFDQyxxQkFBcUIsQ0FBQ2tCLGVBQWV6VyxvQkFBb0IsSUFBSTtnQkFDL0UsbUZBQW1GO2dCQUNuRnFVLGdCQUFnQjtvQkFDWjUxQjtvQkFDQWU7b0JBQ0FtekI7Z0JBQ0o7WUFDSjtZQUNBLElBQUk3VyxTQUFTO2dCQUNULE1BQU1sWixPQUFPcEQsTUFBTUcsUUFBUSxHQUFHZ1QsYUFBYSxDQUFDMlEsR0FBRyxDQUFDN2tCO2dCQUNoRCxJQUFJbUUsTUFBTTtvQkFDTmtaLFFBQVF6VixPQUFPO3dCQUFFLEdBQUd6RCxJQUFJO29CQUFDO2dCQUM3QjtZQUNKO1FBQ0o7UUFDQSxNQUFNaTJCLFlBQVksQ0FBQ3h5QjtZQUNmLElBQUlDLGVBQWVELFFBQVE7Z0JBQ3ZCO1lBQ0o7WUFDQSxJQUFJUCxxQkFBcUJhLFFBQVEsQ0FBQ04sTUFBTXNLLEdBQUcsS0FBSzJrQixjQUFjO2dCQUMxRCxNQUFNaEIsV0FBV2p1QixNQUFNc0ssR0FBRyxLQUFLO2dCQUMvQjBqQixnQkFBZ0I7b0JBQ1o1MUI7b0JBQ0FlO29CQUNBODBCO29CQUNBM0I7Z0JBQ0o7WUFDSixPQUNLLElBQUksQ0FBQzNSLHVCQUNOeVYsZUFDQXhaLFlBQ0F6TSxPQUFPc29CLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDaE0sSUFBSSxDQUFDbUssZUFBZTd3QixNQUFNc0ssR0FBRyxHQUFHO2dCQUNoRW5SLE1BQU1JLFFBQVEsQ0FBQztvQkFDWGloQixpQkFBaUIsQ0FBQyxvQkFBb0IsRUFBRXhhLE1BQU1zSyxHQUFHLENBQzVDcW9CLE9BQU8sQ0FBQyxTQUFTLElBQ2pCQyxXQUFXLEdBQUcsbUJBQW1CLEVBQUUsQ0FBQyxDQUFDdkIsS0FBSyxLQUFLLEVBQUUsQ0FBQyxDQUFDQyxLQUFLLENBQUM7Z0JBQ2xFO2dCQUNBaEIsZ0JBQWdCO29CQUNaeDFCLEdBQUcrMUIsYUFBYSxDQUFDN3dCLE1BQU1zSyxHQUFHLENBQUMsQ0FBQ3hQLENBQUM7b0JBQzdCQyxHQUFHODFCLGFBQWEsQ0FBQzd3QixNQUFNc0ssR0FBRyxDQUFDLENBQUN2UCxDQUFDO29CQUM3QjAxQixnQkFBZ0J6d0IsTUFBTStiLFFBQVE7Z0JBQ2xDO1lBQ0o7UUFDSjtRQUNBcGxCLGdEQUFTQSxDQUFDO1lBQ04sSUFBSTIxQixRQUFRMXdCLE9BQU8sSUFBSSxDQUFDa1IsUUFBUTtnQkFDNUIsTUFBTStsQixXQUFXdkcsUUFBUTF3QixPQUFPO2dCQUNoQzhuQixnQkFBZ0JHLFFBQVFnUDtnQkFDeEIsT0FBTyxJQUFNblAsZ0JBQWdCSSxVQUFVK087WUFDM0M7UUFDSixHQUFHO1lBQUMvbEI7U0FBTztRQUNYblcsZ0RBQVNBLENBQUM7WUFDTixrR0FBa0c7WUFDbEcsTUFBTW04QixjQUFjZCxTQUFTcDJCLE9BQU8sS0FBS3REO1lBQ3pDLE1BQU15NkIsbUJBQW1CakIsbUJBQW1CbDJCLE9BQU8sS0FBSzhJO1lBQ3hELE1BQU1zdUIsbUJBQW1CakIsbUJBQW1CbjJCLE9BQU8sS0FBS2dKO1lBQ3hELElBQUkwbkIsUUFBUTF3QixPQUFPLElBQUtrM0IsQ0FBQUEsZUFBZUMsb0JBQW9CQyxnQkFBZSxHQUFJO2dCQUMxRSxJQUFJRixhQUFhO29CQUNiZCxTQUFTcDJCLE9BQU8sR0FBR3REO2dCQUN2QjtnQkFDQSxJQUFJeTZCLGtCQUFrQjtvQkFDbEJqQixtQkFBbUJsMkIsT0FBTyxHQUFHOEk7Z0JBQ2pDO2dCQUNBLElBQUlzdUIsa0JBQWtCO29CQUNsQmpCLG1CQUFtQm4yQixPQUFPLEdBQUdnSjtnQkFDakM7Z0JBQ0F6TCxNQUFNRyxRQUFRLEdBQUcyNUIsb0JBQW9CLENBQUM7b0JBQUM7d0JBQUU3NkI7d0JBQUlzMUIsYUFBYXBCLFFBQVExd0IsT0FBTzt3QkFBRXMzQixhQUFhO29CQUFLO2lCQUFFO1lBQ25HO1FBQ0osR0FBRztZQUFDOTZCO1lBQUlFO1lBQU1vTTtZQUFnQkU7U0FBZTtRQUM3QyxNQUFNeUksV0FBV3doQixRQUFRO1lBQ3JCdkM7WUFDQXdDLFVBQVVoaUIsVUFBVSxDQUFDc2pCO1lBQ3JCckI7WUFDQUMsZ0JBQWdCMkM7WUFDaEJ2b0IsUUFBUWhSO1lBQ1I2MkI7WUFDQUM7UUFDSjtRQUNBLElBQUlwaUIsUUFBUTtZQUNSLE9BQU87UUFDWDtRQUNBLHFCQUFRMVcsZ0RBQW1CLENBQUMsT0FBTztZQUFFNEQsV0FBV2xELG9EQUFFQSxDQUFDO2dCQUMzQztnQkFDQSxDQUFDLGlCQUFpQixFQUFFd0IsS0FBSyxDQUFDO2dCQUMxQjtvQkFDSSwwREFBMEQ7b0JBQzFELENBQUM2YixlQUFlLEVBQUVpYztnQkFDdEI7Z0JBQ0FwMkI7Z0JBQ0E7b0JBQ0k0YztvQkFDQS9KLFlBQVlvaUI7b0JBQ1puRyxRQUFReEw7b0JBQ1JqUTtnQkFDSjthQUNIO1lBQUdqUixLQUFLa3dCO1lBQVNyeUIsT0FBTztnQkFDckIwakI7Z0JBQ0E1aEIsV0FBVyxDQUFDLFVBQVUsRUFBRXcxQixXQUFXLEdBQUcsRUFBRUMsV0FBVyxHQUFHLENBQUM7Z0JBQ3ZEcjNCLGVBQWU4M0IsbUJBQW1CLFFBQVE7Z0JBQzFDajJCLFlBQVk0MUIsY0FBYyxZQUFZO2dCQUN0QyxHQUFHMzNCLEtBQUs7WUFDWjtZQUFHLFdBQVc3QjtZQUFJLGVBQWUsQ0FBQyxTQUFTLEVBQUVBLEdBQUcsQ0FBQztZQUFFK3pCLGNBQWMrRjtZQUFxQnhHLGFBQWF5RztZQUFvQmxHLGNBQWNtRztZQUFxQjlHLGVBQWUrRztZQUFzQjVjLFNBQVM4YztZQUFxQmQsZUFBZWE7WUFBc0JFLFdBQVdkLGNBQWNjLFlBQVk5dkI7WUFBV3l3QixVQUFVekIsY0FBYyxJQUFJaHZCO1lBQVcwd0IsTUFBTTFCLGNBQWMsV0FBV2h2QjtZQUFXLG9CQUFvQmlZLHNCQUFzQmpZLFlBQVksQ0FBQyxFQUFFMFgsbUJBQW1CLENBQUMsRUFBRW5RLEtBQUssQ0FBQztZQUFFLGNBQWM0bkI7UUFBVSxpQkFDbGZ6N0IsZ0RBQW1CLENBQUNzQixVQUFVO1lBQUV3RixPQUFPOUU7UUFBRyxpQkFDdENoQyxnREFBbUIsQ0FBQys2QixlQUFlO1lBQUUvNEIsSUFBSUE7WUFBSStkLE1BQU1BO1lBQU03ZCxNQUFNQTtZQUFNKzRCLE1BQU1BO1lBQU1DLE1BQU1BO1lBQU0xYSxVQUFVQTtZQUFVMUYsZUFBZUE7WUFBZXhNLGdCQUFnQkE7WUFBZ0JFLGdCQUFnQkE7WUFBZ0J5SSxVQUFVQTtZQUFVc2tCLFlBQVlBO1lBQVloVSxRQUFRQTtRQUFPO0lBQ3RSO0lBQ0F5VCxZQUFZaHZCLFdBQVcsR0FBRztJQUMxQixxQkFBTzVMLDJDQUFJQSxDQUFDNDZCO0FBQ2hCO0FBRUE7OztDQUdDLEdBQ0QsTUFBTWlDLGFBQWEsQ0FBQzE1QjtJQUNoQixNQUFNZ2QsZ0JBQWdCaGQsRUFBRTBZLFFBQVEsR0FBRzNJLE1BQU0sQ0FBQyxDQUFDdkssSUFBTUEsRUFBRXlYLFFBQVE7SUFDM0QsT0FBTztRQUNILEdBQUc1SyxlQUFlMkssZUFBZWhkLEVBQUVvUyxVQUFVLENBQUM7UUFDOUN1bkIsaUJBQWlCLENBQUMsVUFBVSxFQUFFMzVCLEVBQUVvQyxTQUFTLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRXBDLEVBQUVvQyxTQUFTLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRXBDLEVBQUVvQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM5Rm5DLHFCQUFxQkQsRUFBRUMsbUJBQW1CO0lBQzlDO0FBQ0o7QUFDQSxTQUFTMjVCLGVBQWUsRUFBRUMsc0JBQXNCLEVBQUVyZixjQUFjLEVBQUV3RyxtQkFBbUIsRUFBRTtJQUNuRixNQUFNeGhCLFFBQVFFO0lBQ2QsTUFBTSxFQUFFb0MsS0FBSyxFQUFFQyxNQUFNLEVBQUVaLEdBQUdvRyxJQUFJLEVBQUVuRyxHQUFHb0csR0FBRyxFQUFFbXlCLGVBQWUsRUFBRTE1QixtQkFBbUIsRUFBRSxHQUFHWixTQUFTcTZCLFlBQVlwOEIsb0RBQU9BO0lBQzdHLE1BQU1xNUIsa0JBQWtCRDtJQUN4QixNQUFNL0QsVUFBVTcxQiw2Q0FBTUEsQ0FBQztJQUN2QkUsZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUNna0IscUJBQXFCO1lBQ3RCMlIsUUFBUTF3QixPQUFPLEVBQUU2M0IsTUFBTTtnQkFDbkJDLGVBQWU7WUFDbkI7UUFDSjtJQUNKLEdBQUc7UUFBQy9ZO0tBQW9CO0lBQ3hCa1UsUUFBUTtRQUNKdkM7SUFDSjtJQUNBLElBQUkxeUIsdUJBQXVCLENBQUM2QixTQUFTLENBQUNDLFFBQVE7UUFDMUMsT0FBTztJQUNYO0lBQ0EsTUFBTTR2QixnQkFBZ0JrSSx5QkFDaEIsQ0FBQ3h6QjtRQUNDLE1BQU0yVyxnQkFBZ0J4ZCxNQUNqQkcsUUFBUSxHQUNSK1ksUUFBUSxHQUNSM0ksTUFBTSxDQUFDLENBQUN2SyxJQUFNQSxFQUFFeVgsUUFBUTtRQUM3QjRjLHVCQUF1Qnh6QixPQUFPMlc7SUFDbEMsSUFDRWpVO0lBQ04sTUFBTTh2QixZQUFZLENBQUN4eUI7UUFDZixJQUFJbUssT0FBT3NvQixTQUFTLENBQUNDLGNBQWMsQ0FBQ2hNLElBQUksQ0FBQ21LLGVBQWU3d0IsTUFBTXNLLEdBQUcsR0FBRztZQUNoRWdtQixnQkFBZ0I7Z0JBQ1p4MUIsR0FBRysxQixhQUFhLENBQUM3d0IsTUFBTXNLLEdBQUcsQ0FBQyxDQUFDeFAsQ0FBQztnQkFDN0JDLEdBQUc4MUIsYUFBYSxDQUFDN3dCLE1BQU1zSyxHQUFHLENBQUMsQ0FBQ3ZQLENBQUM7Z0JBQzdCMDFCLGdCQUFnQnp3QixNQUFNK2IsUUFBUTtZQUNsQztRQUNKO0lBQ0o7SUFDQSxxQkFBUTNsQixnREFBbUIsQ0FBQyxPQUFPO1FBQUU0RCxXQUFXbEQsb0RBQUVBLENBQUM7WUFBQztZQUE4QjtZQUF5QnFkO1NBQWU7UUFBR2xhLE9BQU87WUFDNUg4QixXQUFXdTNCO1FBQ2Y7SUFBRSxpQkFDRmw5QixnREFBbUIsQ0FBQyxPQUFPO1FBQUVnRyxLQUFLa3dCO1FBQVN0eUIsV0FBVztRQUFtQ3N4QixlQUFlQTtRQUFlNkgsVUFBVXhZLHNCQUFzQmpZLFlBQVksQ0FBQztRQUFHOHZCLFdBQVc3WCxzQkFBc0JqWSxZQUFZOHZCO1FBQVd2NEIsT0FBTztZQUM5TndCO1lBQ0FDO1lBQ0F5RjtZQUNBRDtRQUNKO0lBQUU7QUFDZDtBQUNBLElBQUl5eUIsaUNBQW1CbjlCLDJDQUFJQSxDQUFDKzhCO0FBRTVCLE1BQU1LLGFBQWEsQ0FBQ2o2QixJQUFNQSxFQUFFMnBCLG9CQUFvQjtBQUNoRCxNQUFNdVEsZUFBZSxDQUFDLEVBQUU5NUIsUUFBUSxFQUFFNndCLFdBQVcsRUFBRUUsZ0JBQWdCLEVBQUVDLGVBQWUsRUFBRUMsZ0JBQWdCLEVBQUU5RixpQkFBaUIsRUFBRTJGLFlBQVksRUFBRTNILGFBQWEsRUFBRTZCLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUU2TyxnQkFBZ0IsRUFBRUMsZUFBZSxFQUFFdkosYUFBYSxFQUFFRSxnQkFBZ0IsRUFBRUMsY0FBYyxFQUFFeEgscUJBQXFCLEVBQUU2USxvQkFBb0IsRUFBRXJPLHFCQUFxQixFQUFFOU0sa0JBQWtCLEVBQUVzTSxZQUFZLEVBQUVDLFdBQVcsRUFBRUMsYUFBYTRPLFlBQVksRUFBRTNPLGdCQUFnQixFQUFFQyxlQUFlLEVBQUVFLGlCQUFpQixFQUFFbkIsV0FBVzRQLFVBQVUsRUFBRXhPLGVBQWUsRUFBRTNNLGVBQWUsRUFBRXJMLE9BQU8sRUFBRUMsT0FBTyxFQUFFaVksZ0JBQWdCLEVBQUU0TixzQkFBc0IsRUFBRTNOLGdCQUFnQixFQUFFMVIsY0FBYyxFQUFFd0csbUJBQW1CLEVBQUc7SUFDcm5CLE1BQU0ySSx1QkFBdUJ0cUIsU0FBUzQ2QjtJQUN0QyxNQUFNTyxzQkFBc0J2WixZQUFZa1o7SUFDeEMsTUFBTU0sMEJBQTBCeFosWUFBWW9aO0lBQzVDLE1BQU0xUCxZQUFZOFAsMkJBQTJCRjtJQUM3QyxNQUFNN08sY0FBYytPLDJCQUEyQkg7SUFDL0MsTUFBTTFKLGNBQWM0Six1QkFBd0JKLG1CQUFtQnpQLGNBQWM7SUFDN0VyQixvQkFBb0I7UUFBRUM7UUFBZUM7SUFBc0I7SUFDM0QscUJBQVEvc0IsZ0RBQW1CLENBQUMwdUIsVUFBVTtRQUFFQyxRQUFRQTtRQUFRQyxhQUFhQTtRQUFhQyxXQUFXQTtRQUFXQyxtQkFBbUJBO1FBQW1Cck0sb0JBQW9CQTtRQUFvQnNNLGNBQWNBO1FBQWNDLGFBQWFBO1FBQWFDLGFBQWFBO1FBQWFDLGtCQUFrQkE7UUFBa0JDLGlCQUFpQkE7UUFBaUJFLG1CQUFtQkE7UUFBbUJuQixXQUFXLENBQUM2UCx1QkFBdUI3UDtRQUFXb0IsaUJBQWlCQTtRQUFpQjNNLGlCQUFpQkE7UUFBaUJyTCxTQUFTQTtRQUFTQyxTQUFTQTtRQUFTZ1ksdUJBQXVCQTtRQUF1QkMsa0JBQWtCQTtRQUFrQkMsa0JBQWtCQTtRQUFrQjFSLGdCQUFnQkE7SUFBZSxpQkFDenBCL2QsZ0RBQW1CLENBQUNrMEIsTUFBTTtRQUFFSSxrQkFBa0JBO1FBQWtCQyxnQkFBZ0JBO1FBQWdCQyxhQUFhQTtRQUFhRSxrQkFBa0JBO1FBQWtCQyxpQkFBaUJBO1FBQWlCQyxrQkFBa0JBO1FBQWtCOUYsbUJBQW1CQTtRQUFtQjJGLGNBQWNBO1FBQWN2RyxXQUFXQTtRQUFXaUcsYUFBYSxDQUFDLENBQUNBO1FBQWFDLGVBQWVBO0lBQWMsR0FDalh6d0IsVUFDQXVwQixzQ0FBeUJsdEIsZ0RBQW1CLENBQUN1OUIsa0JBQWtCO1FBQUVILHdCQUF3QkE7UUFBd0JyZixnQkFBZ0JBO1FBQWdCd0cscUJBQXFCQTtJQUFvQjtBQUN0TTtBQUNBa1osYUFBYXp4QixXQUFXLEdBQUc7QUFDM0IsSUFBSWl5QiwrQkFBaUI3OUIsMkNBQUlBLENBQUNxOUI7QUFFMUIsU0FBU1MsZ0JBQWdCQyxpQkFBaUI7SUFDdEMsTUFBTS9xQixRQUFReFEsU0FBU25DLGtEQUFXQSxDQUFDLENBQUM4QyxJQUFNNDZCLG9CQUNwQ2xvQixlQUFlMVMsRUFBRTJTLGFBQWEsRUFBRTtZQUFFeFIsR0FBRztZQUFHQyxHQUFHO1lBQUdVLE9BQU85QixFQUFFOEIsS0FBSztZQUFFQyxRQUFRL0IsRUFBRStCLE1BQU07UUFBQyxHQUFHL0IsRUFBRW9DLFNBQVMsRUFBRSxRQUMvRnBDLEVBQUUwWSxRQUFRLElBQUk7UUFBQ2tpQjtLQUFrQjtJQUN2QyxPQUFPL3FCO0FBQ1g7QUFFQSxTQUFTZ3JCLGdCQUFnQkMsU0FBUztJQUM5QixNQUFNQyxnQkFBZ0I7UUFDbEJDLE9BQU96RCxTQUFVdUQsVUFBVUUsS0FBSyxJQUFJcmU7UUFDcENzZSxTQUFTMUQsU0FBVXVELFVBQVVHLE9BQU8sSUFBSXhlO1FBQ3hDeWUsUUFBUTNELFNBQVV1RCxVQUFVSSxNQUFNLElBQUlyZTtRQUN0Q3NlLE9BQU81RCxTQUFVdUQsVUFBVUssS0FBSyxJQUFJcmU7SUFDeEM7SUFDQSxNQUFNc2UsZUFBZSxDQUFDO0lBQ3RCLE1BQU1DLGVBQWU3cUIsT0FBT0MsSUFBSSxDQUFDcXFCLFdBQzVCL3FCLE1BQU0sQ0FBQyxDQUFDa1QsSUFBTSxDQUFDO1lBQUM7WUFBUztZQUFXO1lBQVU7U0FBUSxDQUFDdGMsUUFBUSxDQUFDc2MsSUFDaEU1VSxNQUFNLENBQUMsQ0FBQ0MsS0FBS3FDO1FBQ2RyQyxHQUFHLENBQUNxQyxJQUFJLEdBQUc0bUIsU0FBVXVELFNBQVMsQ0FBQ25xQixJQUFJLElBQUk4TDtRQUN2QyxPQUFPbk87SUFDWCxHQUFHOHNCO0lBQ0gsT0FBTztRQUNILEdBQUdMLGFBQWE7UUFDaEIsR0FBR00sWUFBWTtJQUNuQjtBQUNKO0FBQ0EsTUFBTUMsd0JBQXdCLENBQUMsRUFBRW42QixDQUFDLEVBQUVDLENBQUMsRUFBRVUsS0FBSyxFQUFFQyxNQUFNLEVBQUV3NUIsTUFBTSxFQUFHO0lBQzNELElBQUksQ0FBQ3o1QixTQUFTLENBQUNDLFFBQVE7UUFDbkIsT0FBTztZQUFFWjtZQUFHQztRQUFFO0lBQ2xCO0lBQ0EsSUFBSW02QixNQUFNLENBQUMsRUFBRSxHQUFHLEtBQUtBLE1BQU0sQ0FBQyxFQUFFLEdBQUcsS0FBS0EsTUFBTSxDQUFDLEVBQUUsR0FBRyxLQUFLQSxNQUFNLENBQUMsRUFBRSxHQUFHLEdBQUc7UUFDbEUsT0FBTztZQUFFcDZCO1lBQUdDO1FBQUU7SUFDbEI7SUFDQSxPQUFPO1FBQ0hELEdBQUdBLElBQUlXLFFBQVF5NUIsTUFBTSxDQUFDLEVBQUU7UUFDeEJuNkIsR0FBR0EsSUFBSVcsU0FBU3c1QixNQUFNLENBQUMsRUFBRTtJQUM3QjtBQUNKO0FBRUEsTUFBTUMsYUFBYSxDQUFDeDdCLElBQU87UUFDdkJ5ZSxnQkFBZ0J6ZSxFQUFFeWUsY0FBYztRQUNoQ0Msa0JBQWtCMWUsRUFBRTBlLGdCQUFnQjtRQUNwQ0MsZ0JBQWdCM2UsRUFBRTJlLGNBQWM7UUFDaENPLG9CQUFvQmxmLEVBQUVrZixrQkFBa0I7UUFDeENvYSxzQkFBc0J0NUIsRUFBRXM1QixvQkFBb0I7UUFDNUNqZSxTQUFTcmIsRUFBRXFiLE9BQU87SUFDdEI7QUFDQSxNQUFNb2dCLGVBQWUsQ0FBQzNzQjtJQUNsQixNQUFNLEVBQUUyUCxjQUFjLEVBQUVDLGdCQUFnQixFQUFFQyxjQUFjLEVBQUVPLGtCQUFrQixFQUFFb2Esb0JBQW9CLEVBQUVqZSxPQUFPLEVBQUUsR0FBR2hjLFNBQVNtOEIsWUFBWWwrQixvREFBT0E7SUFDNUksTUFBTXVTLFFBQVE4cUIsZ0JBQWdCN3JCLE1BQU00c0IseUJBQXlCO0lBQzdELE1BQU1DLG9CQUFvQjcrQiw2Q0FBTUE7SUFDaEMsTUFBTWl0QixpQkFBaUJudEIsOENBQU9BLENBQUM7UUFDM0IsSUFBSSxPQUFPcXRCLG1CQUFtQixhQUFhO1lBQ3ZDLE9BQU87UUFDWDtRQUNBLE1BQU0yUixXQUFXLElBQUkzUixlQUFlLENBQUM0UjtZQUNqQyxNQUFNQyxVQUFVRCxRQUFRN3JCLEdBQUcsQ0FBQyxDQUFDK3JCLFFBQVc7b0JBQ3BDdDlCLElBQUlzOUIsTUFBTS82QixNQUFNLENBQUMyVSxZQUFZLENBQUM7b0JBQzlCb2UsYUFBYWdJLE1BQU0vNkIsTUFBTTtvQkFDekJ1NEIsYUFBYTtnQkFDakI7WUFDQUQscUJBQXFCd0M7UUFDekI7UUFDQUgsa0JBQWtCMTVCLE9BQU8sR0FBRzI1QjtRQUM1QixPQUFPQTtJQUNYLEdBQUcsRUFBRTtJQUNMNStCLGdEQUFTQSxDQUFDO1FBQ04sT0FBTztZQUNIMitCLG1CQUFtQjE1QixTQUFTKzVCO1FBQ2hDO0lBQ0osR0FBRyxFQUFFO0lBQ0wscUJBQVF2L0IsZ0RBQW1CLENBQUMsT0FBTztRQUFFNEQsV0FBVztRQUFxQkMsT0FBTzhwQjtJQUFlLEdBQUd2YSxNQUFNRyxHQUFHLENBQUMsQ0FBQ3BOO1FBQ3JHLElBQUl4RSxXQUFXd0UsS0FBS2pFLElBQUksSUFBSTtRQUM1QixJQUFJLENBQUNtUSxNQUFNZ3NCLFNBQVMsQ0FBQzE4QixTQUFTLEVBQUU7WUFDNUJpZCxVQUFVLE9BQU9yZCxhQUFhLENBQUMsV0FBVyxDQUFDSTtZQUMzQ0EsV0FBVztRQUNmO1FBQ0EsTUFBTW81QixnQkFBaUIxb0IsTUFBTWdzQixTQUFTLENBQUMxOEIsU0FBUyxJQUFJMFEsTUFBTWdzQixTQUFTLENBQUNHLE9BQU87UUFDM0UsTUFBTXhFLGNBQWMsQ0FBQyxDQUFFN3pCLENBQUFBLEtBQUtxd0IsU0FBUyxJQUFLeFUsa0JBQWtCLE9BQU83YixLQUFLcXdCLFNBQVMsS0FBSyxXQUFXO1FBQ2pHLE1BQU1xQyxlQUFlLENBQUMsQ0FBRTF5QixDQUFBQSxLQUFLc1EsVUFBVSxJQUFLZ00sc0JBQXNCLE9BQU90YyxLQUFLc1EsVUFBVSxLQUFLLFdBQVc7UUFDeEcsTUFBTXFFLGdCQUFnQixDQUFDLENBQUUzVSxDQUFBQSxLQUFLeVUsV0FBVyxJQUFLcUgsb0JBQW9CLE9BQU85YixLQUFLeVUsV0FBVyxLQUFLLFdBQVc7UUFDekcsTUFBTTBnQixjQUFjLENBQUMsQ0FBRW4xQixDQUFBQSxLQUFLcTVCLFNBQVMsSUFBS3RkLGtCQUFrQixPQUFPL2IsS0FBS3E1QixTQUFTLEtBQUssV0FBVztRQUNqRyxNQUFNQyxrQkFBa0JwdEIsTUFBTWlRLFVBQVUsR0FDbEMzYixjQUFjUixLQUFLK0IsZ0JBQWdCLEVBQUVtSyxNQUFNaVEsVUFBVSxJQUNyRG5jLEtBQUsrQixnQkFBZ0I7UUFDM0IsTUFBTXczQixPQUFPRCxpQkFBaUIvNkIsS0FBSztRQUNuQyxNQUFNaTdCLE9BQU9GLGlCQUFpQjk2QixLQUFLO1FBQ25DLE1BQU1pN0IsWUFBWWYsc0JBQXNCO1lBQ3BDbjZCLEdBQUdnN0I7WUFDSC82QixHQUFHZzdCO1lBQ0h0NkIsT0FBT2MsS0FBS2QsS0FBSyxJQUFJO1lBQ3JCQyxRQUFRYSxLQUFLYixNQUFNLElBQUk7WUFDdkJ3NUIsUUFBUXpzQixNQUFNc0QsVUFBVTtRQUM1QjtRQUNBLHFCQUFRM1YsZ0RBQW1CLENBQUMrNkIsZUFBZTtZQUFFN21CLEtBQUsvTixLQUFLbkUsRUFBRTtZQUFFQSxJQUFJbUUsS0FBS25FLEVBQUU7WUFBRTRCLFdBQVd1QyxLQUFLdkMsU0FBUztZQUFFQyxPQUFPc0MsS0FBS3RDLEtBQUs7WUFBRTNCLE1BQU1QO1lBQVVvZSxNQUFNNVosS0FBSzRaLElBQUk7WUFBRXpSLGdCQUFnQm5JLEtBQUttSSxjQUFjLElBQUlQLFNBQVNRLE1BQU07WUFBRUMsZ0JBQWdCckksS0FBS3FJLGNBQWMsSUFBSVQsU0FBU1UsR0FBRztZQUFFaUksUUFBUXZRLEtBQUt1USxNQUFNO1lBQUV1a0IsTUFBTXlFO1lBQU14RSxNQUFNeUU7WUFBTXhFLFlBQVl5RSxVQUFVbDdCLENBQUM7WUFBRTAyQixZQUFZd0UsVUFBVWo3QixDQUFDO1lBQUVtMEIsbUJBQW1Cem1CLE1BQU15bUIsaUJBQWlCO1lBQUV6WixTQUFTaE4sTUFBTXd0QixXQUFXO1lBQUU5SixjQUFjMWpCLE1BQU15dEIsZ0JBQWdCO1lBQUV4SyxhQUFhampCLE1BQU0wdEIsZUFBZTtZQUFFbEssY0FBY3hqQixNQUFNMnRCLGdCQUFnQjtZQUFFOUssZUFBZTdpQixNQUFNNHRCLGlCQUFpQjtZQUFFNUUsZUFBZWhwQixNQUFNNnRCLGlCQUFpQjtZQUFFMWYsVUFBVSxDQUFDLENBQUNyYSxLQUFLcWEsUUFBUTtZQUFFd1osYUFBYUE7WUFBYW5CLGNBQWNBO1lBQWMvZCxlQUFlQTtZQUFld2dCLGFBQWFBO1lBQWFoTyxnQkFBZ0JBO1lBQWdCaU8sWUFBWXAxQixLQUFLbzFCLFVBQVU7WUFBRWhVLFFBQVFwaEIsSUFBSSxDQUFDK0MsZ0JBQWdCLEVBQUU2ZCxLQUFLO1lBQUdHLFVBQVUsQ0FBQyxDQUFDL2dCLElBQUksQ0FBQytDLGdCQUFnQixFQUFFZ2U7WUFBVXlSLGlCQUFpQnRtQixNQUFNc21CLGVBQWU7WUFBRTVhLGdCQUFnQjFMLE1BQU0wTCxjQUFjO1lBQUV5ZCxhQUFhLENBQUMsQ0FBQ3IxQixLQUFLZCxLQUFLLElBQUksQ0FBQyxDQUFDYyxLQUFLYixNQUFNO1lBQUV1TyxNQUFNeEIsTUFBTXdCLElBQUk7WUFBRTBRLHFCQUFxQmxTLE1BQU1rUyxtQkFBbUI7WUFBRWtYLFdBQVd0MUIsS0FBS3MxQixTQUFTO1FBQUM7SUFDL2xDO0FBQ0o7QUFDQXVELGFBQWFoekIsV0FBVyxHQUFHO0FBQzNCLElBQUltMEIsK0JBQWlCLy9CLDJDQUFJQSxDQUFDNCtCO0FBRTFCLE1BQU1vQixTQUFTLENBQUMxN0IsR0FBRzI3QixPQUFPMzhCO0lBQ3RCLElBQUlBLGFBQWFxSyxTQUFTSSxJQUFJLEVBQzFCLE9BQU96SixJQUFJMjdCO0lBQ2YsSUFBSTM4QixhQUFhcUssU0FBU0ssS0FBSyxFQUMzQixPQUFPMUosSUFBSTI3QjtJQUNmLE9BQU8zN0I7QUFDWDtBQUNBLE1BQU00N0IsU0FBUyxDQUFDMzdCLEdBQUcwN0IsT0FBTzM4QjtJQUN0QixJQUFJQSxhQUFhcUssU0FBU1UsR0FBRyxFQUN6QixPQUFPOUosSUFBSTA3QjtJQUNmLElBQUkzOEIsYUFBYXFLLFNBQVNRLE1BQU0sRUFDNUIsT0FBTzVKLElBQUkwN0I7SUFDZixPQUFPMTdCO0FBQ1g7QUFDQSxNQUFNNDdCLHVCQUF1QjtBQUM3QixNQUFNQyxhQUFhLENBQUMsRUFBRTk4QixRQUFRLEVBQUVzSixPQUFPLEVBQUVFLE9BQU8sRUFBRXV6QixTQUFTLEVBQUUsRUFBRS9oQixXQUFXLEVBQUVxWCxZQUFZLEVBQUUySyxVQUFVLEVBQUV4K0IsSUFBSSxFQUFHLGlCQUFNbEMsZ0RBQW1CLENBQUMsVUFBVTtRQUFFMGUsYUFBYUE7UUFBYXFYLGNBQWNBO1FBQWMySyxZQUFZQTtRQUFZOThCLFdBQVdsRCxvREFBRUEsQ0FBQztZQUFDNi9CO1lBQXNCLENBQUMsRUFBRUEscUJBQXFCLENBQUMsRUFBRXIrQixLQUFLLENBQUM7U0FBQztRQUFHeStCLElBQUlQLE9BQU9wekIsU0FBU3l6QixRQUFRLzhCO1FBQVdrOUIsSUFBSU4sT0FBT3B6QixTQUFTdXpCLFFBQVEvOEI7UUFBV205QixHQUFHSjtRQUFRSyxRQUFRO1FBQWVqMUIsTUFBTTtJQUFjO0FBRS9hLE1BQU1rMUIsd0JBQXdCLElBQU07QUFDcEMsSUFBSUMsV0FBVyxDQUFDQztJQUNaLE1BQU1DLGNBQWMsQ0FBQyxFQUFFbC9CLEVBQUUsRUFBRTRCLFNBQVMsRUFBRTFCLElBQUksRUFBRTZkLElBQUksRUFBRVYsT0FBTyxFQUFFOGhCLGlCQUFpQixFQUFFM2dCLFFBQVEsRUFBRTRnQixRQUFRLEVBQUV4OEIsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFQyxjQUFjLEVBQUVDLG1CQUFtQixFQUFFcEIsS0FBSyxFQUFFZ0wsTUFBTSxFQUFFdEssTUFBTSxFQUFFb0ksT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFd0IsY0FBYyxFQUFFRSxjQUFjLEVBQUVpVSxrQkFBa0IsRUFBRS9MLE1BQU0sRUFBRTJxQixjQUFjLEVBQUVDLGNBQWMsRUFBRXBNLGFBQWEsRUFBRWEsWUFBWSxFQUFFVCxXQUFXLEVBQUVPLFlBQVksRUFBRTBMLGlCQUFpQixFQUFFQyxZQUFZLEVBQUVDLGlCQUFpQixFQUFFN2xCLGVBQWUsRUFBRXBRLFNBQVMsRUFBRUMsV0FBVyxFQUFFb0ksSUFBSSxFQUFFNG5CLFNBQVMsRUFBRUgsV0FBVyxFQUFFb0csV0FBVyxFQUFFdnZCLFdBQVcsRUFBRXpHLGdCQUFnQixFQUFHO1FBQ3hpQixNQUFNeEcsVUFBVTdFLDZDQUFNQSxDQUFDO1FBQ3ZCLE1BQU0sQ0FBQ3NoQyxhQUFhQyxlQUFlLEdBQUd0aEMsK0NBQVFBLENBQUM7UUFDL0MsTUFBTSxDQUFDdWhDLFVBQVVDLFlBQVksR0FBR3hoQywrQ0FBUUEsQ0FBQztRQUN6QyxNQUFNeUMsUUFBUUU7UUFDZCxNQUFNOCtCLGlCQUFpQjVoQyw4Q0FBT0EsQ0FBQyxJQUFNLENBQUMsS0FBSyxFQUFFd1QsWUFBWWxJLGFBQWFvSSxNQUFNLENBQUMsQ0FBQyxFQUFFO1lBQUNwSTtZQUFhb0k7U0FBSztRQUNuRyxNQUFNbXVCLGVBQWU3aEMsOENBQU9BLENBQUMsSUFBTSxDQUFDLEtBQUssRUFBRXdULFlBQVluSSxXQUFXcUksTUFBTSxDQUFDLENBQUMsRUFBRTtZQUFDckk7WUFBV3FJO1NBQUs7UUFDN0YsSUFBSTZDLFFBQVE7WUFDUixPQUFPO1FBQ1g7UUFDQSxNQUFNdXJCLGNBQWMsQ0FBQ3I0QjtZQUNqQixNQUFNLEVBQUUyQyxLQUFLLEVBQUUyMUIsZ0JBQWdCLEVBQUVuSyxxQkFBcUIsRUFBRTVLLG9CQUFvQixFQUFFLEdBQUdwcUIsTUFBTUcsUUFBUTtZQUMvRixNQUFNYixPQUFPa0ssTUFBTUMsSUFBSSxDQUFDLENBQUNDLElBQU1BLEVBQUV6SyxFQUFFLEtBQUtBO1lBQ3hDLElBQUksQ0FBQ0ssTUFBTTtnQkFDUDtZQUNKO1lBQ0EsSUFBSW9nQixvQkFBb0I7Z0JBQ3BCMWYsTUFBTUksUUFBUSxDQUFDO29CQUFFK3BCLHNCQUFzQjtnQkFBTTtnQkFDN0MsSUFBSTdxQixLQUFLbWUsUUFBUSxJQUFJMk0sc0JBQXNCO29CQUN2QzRLLHNCQUFzQjt3QkFBRTNrQixPQUFPLEVBQUU7d0JBQUU3RyxPQUFPOzRCQUFDbEs7eUJBQUs7b0JBQUM7b0JBQ2pENkMsUUFBUU0sT0FBTyxFQUFFd3lCO2dCQUNyQixPQUNLO29CQUNEa0ssaUJBQWlCO3dCQUFDbGdDO3FCQUFHO2dCQUN6QjtZQUNKO1lBQ0EsSUFBSXFkLFNBQVM7Z0JBQ1RBLFFBQVF6VixPQUFPdkg7WUFDbkI7UUFDSjtRQUNBLE1BQU04L0IsMkJBQTJCLzFCLGtCQUFrQnBLLElBQUllLE1BQU1HLFFBQVEsRUFBRWkrQjtRQUN2RSxNQUFNaUIsb0JBQW9CaDJCLGtCQUFrQnBLLElBQUllLE1BQU1HLFFBQVEsRUFBRWd5QjtRQUNoRSxNQUFNbU4sbUJBQW1CajJCLGtCQUFrQnBLLElBQUllLE1BQU1HLFFBQVEsRUFBRTZ5QjtRQUMvRCxNQUFNdU0sa0JBQWtCbDJCLGtCQUFrQnBLLElBQUllLE1BQU1HLFFBQVEsRUFBRW95QjtRQUM5RCxNQUFNaU4sbUJBQW1CbjJCLGtCQUFrQnBLLElBQUllLE1BQU1HLFFBQVEsRUFBRTJ5QjtRQUMvRCxNQUFNMk0sb0JBQW9CLENBQUM1NEIsT0FBTzY0QjtZQUM5Qix5REFBeUQ7WUFDekQsSUFBSTc0QixNQUFNd1YsTUFBTSxLQUFLLEdBQUc7Z0JBQ3BCO1lBQ0o7WUFDQSxNQUFNLEVBQUU3UyxLQUFLLEVBQUVnTyxtQkFBbUJpRixzQkFBc0IsRUFBRSxHQUFHemMsTUFBTUcsUUFBUTtZQUMzRSxNQUFNOFAsU0FBU3l2QixpQkFBaUJsK0IsU0FBU3NLO1lBQ3pDLE1BQU13SyxXQUFXLENBQUNvcEIsaUJBQWlCbkIsaUJBQWlCRCxjQUFhLEtBQU07WUFDdkUsTUFBTWxvQixhQUFhc3BCLGlCQUFpQixXQUFXO1lBQy9DLE1BQU1sb0Isb0JBQW9CaUYsMEJBQTBCdWhCO1lBQ3BELE1BQU12bUIsV0FBV2lvQjtZQUNqQixNQUFNcGdDLE9BQU9rSyxNQUFNQyxJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRXpLLEVBQUUsS0FBS0E7WUFDeEM4L0IsWUFBWTtZQUNaTCxvQkFBb0I3M0IsT0FBT3ZILE1BQU04VztZQUNqQyxNQUFNdXBCLG1CQUFtQixDQUFDQztnQkFDdEJiLFlBQVk7Z0JBQ1psbUIsa0JBQWtCK21CLEtBQUt0Z0MsTUFBTThXO1lBQ2pDO1lBQ0EsTUFBTXlwQixnQkFBZ0IsQ0FBQzVvQixhQUFld25CLGVBQWVuL0IsTUFBTTJYO1lBQzNEMEIsa0JBQWtCO2dCQUNkOVI7Z0JBQ0F5UDtnQkFDQXJHO2dCQUNBMkksV0FBV2luQjtnQkFDWHBvQjtnQkFDQXRYLFVBQVVILE1BQU1HLFFBQVE7Z0JBQ3hCQyxVQUFVSixNQUFNSSxRQUFRO2dCQUN4Qm9YO2dCQUNBWSxpQkFBaUJoQztnQkFDakJ5QyxpQkFBaUI4bUI7WUFDckI7UUFDSjtRQUNBLE1BQU1HLCtCQUErQixDQUFDajVCLFFBQVU0NEIsa0JBQWtCNTRCLE9BQU87UUFDekUsTUFBTWs1QiwrQkFBK0IsQ0FBQ2w1QixRQUFVNDRCLGtCQUFrQjU0QixPQUFPO1FBQ3pFLE1BQU1tNUIsMEJBQTBCLElBQU1uQixlQUFlO1FBQ3JELE1BQU1vQix3QkFBd0IsSUFBTXBCLGVBQWU7UUFDbkQsTUFBTXFCLFdBQVcsQ0FBQ3hnQixzQkFBc0IsQ0FBQ3BEO1FBQ3pDLE1BQU0rYyxZQUFZLENBQUN4eUI7WUFDZixJQUFJUCxxQkFBcUJhLFFBQVEsQ0FBQ04sTUFBTXNLLEdBQUcsS0FBS3VPLG9CQUFvQjtnQkFDaEUsTUFBTSxFQUFFc1YscUJBQXFCLEVBQUVtSyxnQkFBZ0IsRUFBRTMxQixLQUFLLEVBQUUsR0FBR3hKLE1BQU1HLFFBQVE7Z0JBQ3pFLE1BQU0yMEIsV0FBV2p1QixNQUFNc0ssR0FBRyxLQUFLO2dCQUMvQixJQUFJMmpCLFVBQVU7b0JBQ1YzeUIsUUFBUU0sT0FBTyxFQUFFd3lCO29CQUNqQkQsc0JBQXNCO3dCQUFFeHJCLE9BQU87NEJBQUNBLE1BQU1DLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxFQUFFekssRUFBRSxLQUFLQTt5QkFBSTtvQkFBQztnQkFDcEUsT0FDSztvQkFDRGtnQyxpQkFBaUI7d0JBQUNsZ0M7cUJBQUc7Z0JBQ3pCO1lBQ0o7UUFDSjtRQUNBLHFCQUFRaEMsZ0RBQW1CLENBQUMsS0FBSztZQUFFNEQsV0FBV2xELG9EQUFFQSxDQUFDO2dCQUN6QztnQkFDQSxDQUFDLGlCQUFpQixFQUFFd0IsS0FBSyxDQUFDO2dCQUMxQjBCO2dCQUNBO29CQUFFNGM7b0JBQVU0Z0I7b0JBQVU2QjtvQkFBVXBCLFVBQVVGO2dCQUFZO2FBQ3pEO1lBQUd0aUIsU0FBUzRpQjtZQUFhNUcsZUFBZThHO1lBQTBCak4sZUFBZWtOO1lBQW1Cck0sY0FBY3NNO1lBQWtCL00sYUFBYWdOO1lBQWlCek0sY0FBYzBNO1lBQWtCbkcsV0FBV2QsY0FBY2MsWUFBWTl2QjtZQUFXeXdCLFVBQVV6QixjQUFjLElBQUlodkI7WUFBVzB3QixNQUFNMUIsY0FBYyxXQUFXO1lBQU8sZUFBZSxDQUFDLFNBQVMsRUFBRXQ1QixHQUFHLENBQUM7WUFBRSxjQUFjeTVCLGNBQWMsT0FBT252QixZQUFZbXZCLFlBQVlBLFlBQVksQ0FBQyxVQUFVLEVBQUU1c0IsT0FBTyxJQUFJLEVBQUV0SyxPQUFPLENBQUM7WUFBRSxvQkFBb0IrMkIsY0FBYyxDQUFDLEVBQUVyWCxtQkFBbUIsQ0FBQyxFQUFFcFEsS0FBSyxDQUFDLEdBQUd2SDtZQUFXdEcsS0FBS2Q7UUFBUSxHQUN4aUIsQ0FBQzI4QiwwQkFBYTdoQyxnREFBbUIsQ0FBQ2loQyxlQUFlO1lBQUVqL0IsSUFBSUE7WUFBSTZNLFFBQVFBO1lBQVF0SyxRQUFRQTtZQUFRaWMsVUFBVUE7WUFBVTRnQixVQUFVQTtZQUFVeDhCLE9BQU9BO1lBQU9DLFlBQVlBO1lBQVlDLGFBQWFBO1lBQWFDLGNBQWNBO1lBQWNDLGdCQUFnQkE7WUFBZ0JDLHFCQUFxQkE7WUFBcUI4YSxNQUFNQTtZQUFNbGMsT0FBT0E7WUFBTzhJLFNBQVNBO1lBQVNDLFNBQVNBO1lBQVNDLFNBQVNBO1lBQVNDLFNBQVNBO1lBQVN3QixnQkFBZ0JBO1lBQWdCRSxnQkFBZ0JBO1lBQWdCNnlCLGdCQUFnQkE7WUFBZ0JDLGdCQUFnQkE7WUFBZ0I3MUIsYUFBYXMyQjtZQUFnQnYyQixXQUFXdzJCO1lBQWM3dkIsYUFBYUE7WUFBYXpHLGtCQUFrQkE7UUFBaUIsSUFDOW5CZzJCLDZCQUFnQjFoQyxnREFBbUIsQ0FBQ0EsMkNBQWMsRUFBRSxNQUNoRCxDQUFDMGhDLGdCQUFnQixZQUFZQSxnQkFBZ0IsSUFBRyxtQkFBTzFoQyxnREFBbUIsQ0FBQ3dnQyxZQUFZO1lBQUU5OEIsVUFBVTRLO1lBQWdCdEIsU0FBU0w7WUFBU08sU0FBU047WUFBUzZ6QixRQUFRYztZQUFtQjdpQixhQUFhbWtCO1lBQThCOU0sY0FBY2dOO1lBQXlCckMsWUFBWXNDO1lBQXVCOWdDLE1BQU07UUFBUyxJQUN0VCxDQUFDdy9CLGdCQUFnQixZQUFZQSxnQkFBZ0IsSUFBRyxtQkFBTzFoQyxnREFBbUIsQ0FBQ3dnQyxZQUFZO1lBQUU5OEIsVUFBVThLO1lBQWdCeEIsU0FBU0g7WUFBU0ssU0FBU0o7WUFBUzJ6QixRQUFRYztZQUFtQjdpQixhQUFhb2tCO1lBQThCL00sY0FBY2dOO1lBQXlCckMsWUFBWXNDO1lBQXVCOWdDLE1BQU07UUFBUztJQUNsVTtJQUNBZy9CLFlBQVlsMUIsV0FBVyxHQUFHO0lBQzFCLHFCQUFPNUwsMkNBQUlBLENBQUM4Z0M7QUFDaEI7QUFFQSxTQUFTZ0MsZ0JBQWdCQyxTQUFTO0lBQzlCLE1BQU03RSxnQkFBZ0I7UUFDbEJFLFNBQVN3QyxTQUFVbUMsVUFBVTNFLE9BQU8sSUFBSTVyQjtRQUN4Q3d3QixVQUFVcEMsU0FBVW1DLFVBQVVFLE1BQU0sSUFBSTl3QjtRQUN4Qyt3QixNQUFNdEMsU0FBVW1DLFVBQVVHLElBQUksSUFBSWx4QjtRQUNsQ214QixZQUFZdkMsU0FBVW1DLFVBQVVHLElBQUksSUFBSXB4QjtRQUN4Q3N4QixjQUFjeEMsU0FBVW1DLFVBQVVLLFlBQVksSUFBSTkwQjtJQUN0RDtJQUNBLE1BQU1pd0IsZUFBZSxDQUFDO0lBQ3RCLE1BQU1DLGVBQWU3cUIsT0FBT0MsSUFBSSxDQUFDbXZCLFdBQzVCN3ZCLE1BQU0sQ0FBQyxDQUFDa1QsSUFBTSxDQUFDO1lBQUM7WUFBVztTQUFTLENBQUN0YyxRQUFRLENBQUNzYyxJQUM5QzVVLE1BQU0sQ0FBQyxDQUFDQyxLQUFLcUM7UUFDZHJDLEdBQUcsQ0FBQ3FDLElBQUksR0FBRzhzQixTQUFVbUMsU0FBUyxDQUFDanZCLElBQUksSUFBSXRCO1FBQ3ZDLE9BQU9mO0lBQ1gsR0FBRzhzQjtJQUNILE9BQU87UUFDSCxHQUFHTCxhQUFhO1FBQ2hCLEdBQUdNLFlBQVk7SUFDbkI7QUFDSjtBQUNBLFNBQVM2RSxrQkFBa0IvL0IsUUFBUSxFQUFFaVQsUUFBUSxFQUFFNEMsU0FBUyxJQUFJO0lBQ3hELE1BQU03VSxJQUFJLENBQUM2VSxRQUFRN1UsS0FBSyxLQUFLaVMsU0FBU2pTLENBQUM7SUFDdkMsTUFBTUMsSUFBSSxDQUFDNFUsUUFBUTVVLEtBQUssS0FBS2dTLFNBQVNoUyxDQUFDO0lBQ3ZDLE1BQU1VLFFBQVFrVSxRQUFRbFUsU0FBU3NSLFNBQVN0UixLQUFLO0lBQzdDLE1BQU1DLFNBQVNpVSxRQUFRalUsVUFBVXFSLFNBQVNyUixNQUFNO0lBQ2hELE9BQVE1QjtRQUNKLEtBQUtxSyxTQUFTVSxHQUFHO1lBQ2IsT0FBTztnQkFDSC9KLEdBQUdBLElBQUlXLFFBQVE7Z0JBQ2ZWO1lBQ0o7UUFDSixLQUFLb0osU0FBU0ssS0FBSztZQUNmLE9BQU87Z0JBQ0gxSixHQUFHQSxJQUFJVztnQkFDUFYsR0FBR0EsSUFBSVcsU0FBUztZQUNwQjtRQUNKLEtBQUt5SSxTQUFTUSxNQUFNO1lBQ2hCLE9BQU87Z0JBQ0g3SixHQUFHQSxJQUFJVyxRQUFRO2dCQUNmVixHQUFHQSxJQUFJVztZQUNYO1FBQ0osS0FBS3lJLFNBQVNJLElBQUk7WUFDZCxPQUFPO2dCQUNIeko7Z0JBQ0FDLEdBQUdBLElBQUlXLFNBQVM7WUFDcEI7SUFDUjtBQUNKO0FBQ0EsU0FBU28rQixVQUFVeDhCLE1BQU0sRUFBRW1TLFFBQVE7SUFDL0IsSUFBSSxDQUFDblMsUUFBUTtRQUNULE9BQU87SUFDWDtJQUNBLElBQUlBLE9BQU8rSyxNQUFNLEtBQUssS0FBSyxDQUFDb0gsVUFBVTtRQUNsQyxPQUFPblMsTUFBTSxDQUFDLEVBQUU7SUFDcEIsT0FDSyxJQUFJbVMsVUFBVTtRQUNmLE9BQU9uUyxPQUFPc0YsSUFBSSxDQUFDLENBQUNaLElBQU1BLEVBQUU1SixFQUFFLEtBQUtxWCxhQUFhO0lBQ3BEO0lBQ0EsT0FBTztBQUNYO0FBQ0EsTUFBTXNxQixtQkFBbUIsQ0FBQ0MsZ0JBQWdCeGhDLGNBQWNrTSxnQkFBZ0J1MUIsZ0JBQWdCdmhDLGNBQWNrTTtJQUNsRyxNQUFNczFCLGtCQUFrQkwsa0JBQWtCbjFCLGdCQUFnQnMxQixnQkFBZ0J4aEM7SUFDMUUsTUFBTTJoQyxrQkFBa0JOLGtCQUFrQmoxQixnQkFBZ0JxMUIsZ0JBQWdCdmhDO0lBQzFFLE9BQU87UUFDSHFLLFNBQVNtM0IsZ0JBQWdCcC9CLENBQUM7UUFDMUJrSSxTQUFTazNCLGdCQUFnQm4vQixDQUFDO1FBQzFCa0ksU0FBU2szQixnQkFBZ0JyL0IsQ0FBQztRQUMxQm9JLFNBQVNpM0IsZ0JBQWdCcC9CLENBQUM7SUFDOUI7QUFDSjtBQUNBLFNBQVNxL0IsY0FBYyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFai9CLEtBQUssRUFBRUMsTUFBTSxFQUFFSyxTQUFTLEVBQUc7SUFDNUgsTUFBTTQrQixVQUFVO1FBQ1o3L0IsR0FBR2dDLEtBQUtGLEdBQUcsQ0FBQ3k5QixVQUFVdi9CLENBQUMsRUFBRXcvQixVQUFVeC9CLENBQUM7UUFDcENDLEdBQUcrQixLQUFLRixHQUFHLENBQUN5OUIsVUFBVXQvQixDQUFDLEVBQUV1L0IsVUFBVXYvQixDQUFDO1FBQ3BDa0QsSUFBSW5CLEtBQUtELEdBQUcsQ0FBQ3c5QixVQUFVdi9CLENBQUMsR0FBR3kvQixhQUFhRCxVQUFVeC9CLENBQUMsR0FBRzIvQjtRQUN0RHY4QixJQUFJcEIsS0FBS0QsR0FBRyxDQUFDdzlCLFVBQVV0L0IsQ0FBQyxHQUFHeS9CLGNBQWNGLFVBQVV2L0IsQ0FBQyxHQUFHMi9CO0lBQzNEO0lBQ0EsSUFBSUMsUUFBUTcvQixDQUFDLEtBQUs2L0IsUUFBUTE4QixFQUFFLEVBQUU7UUFDMUIwOEIsUUFBUTE4QixFQUFFLElBQUk7SUFDbEI7SUFDQSxJQUFJMDhCLFFBQVE1L0IsQ0FBQyxLQUFLNC9CLFFBQVF6OEIsRUFBRSxFQUFFO1FBQzFCeThCLFFBQVF6OEIsRUFBRSxJQUFJO0lBQ2xCO0lBQ0EsTUFBTTA4QixVQUFVejhCLFVBQVU7UUFDdEJyRCxHQUFHLENBQUMsSUFBSWlCLFNBQVMsQ0FBQyxFQUFFLElBQUlBLFNBQVMsQ0FBQyxFQUFFO1FBQ3BDaEIsR0FBRyxDQUFDLElBQUlnQixTQUFTLENBQUMsRUFBRSxJQUFJQSxTQUFTLENBQUMsRUFBRTtRQUNwQ04sT0FBT0EsUUFBUU0sU0FBUyxDQUFDLEVBQUU7UUFDM0JMLFFBQVFBLFNBQVNLLFNBQVMsQ0FBQyxFQUFFO0lBQ2pDO0lBQ0EsTUFBTThDLFdBQVcvQixLQUFLRCxHQUFHLENBQUMsR0FBR0MsS0FBS0YsR0FBRyxDQUFDZytCLFFBQVEzOEIsRUFBRSxFQUFFMDhCLFFBQVExOEIsRUFBRSxJQUFJbkIsS0FBS0QsR0FBRyxDQUFDKzlCLFFBQVE5L0IsQ0FBQyxFQUFFNi9CLFFBQVE3L0IsQ0FBQztJQUM3RixNQUFNZ0UsV0FBV2hDLEtBQUtELEdBQUcsQ0FBQyxHQUFHQyxLQUFLRixHQUFHLENBQUNnK0IsUUFBUTE4QixFQUFFLEVBQUV5OEIsUUFBUXo4QixFQUFFLElBQUlwQixLQUFLRCxHQUFHLENBQUMrOUIsUUFBUTcvQixDQUFDLEVBQUU0L0IsUUFBUTUvQixDQUFDO0lBQzdGLE1BQU1pUyxrQkFBa0JsUSxLQUFLaUMsSUFBSSxDQUFDRixXQUFXQztJQUM3QyxPQUFPa08sa0JBQWtCO0FBQzdCO0FBQ0EsU0FBUzZ0QixZQUFZdCtCLElBQUk7SUFDckIsTUFBTWlTLGVBQWVqUyxNQUFNLENBQUMrQyxnQkFBZ0IsRUFBRWtQLGdCQUFnQjtJQUM5RCxNQUFNd0IsVUFBVXhCLGdCQUNaalMsTUFBTWQsU0FDTmMsTUFBTWIsVUFDTixPQUFPYSxNQUFNK0Isa0JBQWtCeEQsTUFBTSxlQUNyQyxPQUFPeUIsTUFBTStCLGtCQUFrQnZELE1BQU07SUFDekMsT0FBTztRQUNIO1lBQ0lELEdBQUd5QixNQUFNK0Isa0JBQWtCeEQsS0FBSztZQUNoQ0MsR0FBR3dCLE1BQU0rQixrQkFBa0J2RCxLQUFLO1lBQ2hDVSxPQUFPYyxNQUFNZCxTQUFTO1lBQ3RCQyxRQUFRYSxNQUFNYixVQUFVO1FBQzVCO1FBQ0E4UztRQUNBLENBQUMsQ0FBQ3dCO0tBQ0w7QUFDTDtBQUVBLE1BQU04cUIsa0JBQWtCO0lBQUM7UUFBRUMsT0FBTztRQUFHQyxZQUFZO1FBQU1yNEIsT0FBTyxFQUFFO0lBQUM7Q0FBRTtBQUNuRSxTQUFTczRCLG1CQUFtQnQ0QixLQUFLLEVBQUUySixhQUFhLEVBQUU0dUIsdUJBQXVCLEtBQUs7SUFDMUUsSUFBSUMsV0FBVyxDQUFDO0lBQ2hCLE1BQU1DLGNBQWN6NEIsTUFBTXFGLE1BQU0sQ0FBQyxDQUFDcXpCLE1BQU01aUM7UUFDcEMsTUFBTTZpQyxZQUFZcDhCLFVBQVV6RyxLQUFLa2xCLE1BQU07UUFDdkMsSUFBSVIsSUFBSW1lLFlBQVk3aUMsS0FBS2tsQixNQUFNLEdBQUc7UUFDbEMsSUFBSXVkLHNCQUFzQjtZQUN0QixNQUFNSyxhQUFhanZCLGNBQWMyUSxHQUFHLENBQUN4a0IsS0FBS2tDLE1BQU07WUFDaEQsTUFBTTZnQyxhQUFhbHZCLGNBQWMyUSxHQUFHLENBQUN4a0IsS0FBS3dNLE1BQU07WUFDaEQsTUFBTXcyQiw4QkFBOEJoakMsS0FBS21lLFFBQVEsSUFBSTJrQixZQUFZM2tCLFlBQVk0a0IsWUFBWTVrQjtZQUN6RixNQUFNOGtCLGlCQUFpQjUrQixLQUFLRCxHQUFHLENBQUMyK0IsWUFBWSxDQUFDbDhCLGdCQUFnQixFQUFFNmQsS0FBSyxHQUFHb2UsWUFBWSxDQUFDajhCLGdCQUFnQixFQUFFNmQsS0FBSyxHQUFHO1lBQzlHQSxJQUFJLENBQUNtZSxZQUFZN2lDLEtBQUtrbEIsTUFBTSxHQUFHLEtBQU04ZCxDQUFBQSw4QkFBOEJDLGlCQUFpQjtRQUN4RjtRQUNBLElBQUlMLElBQUksQ0FBQ2xlLEVBQUUsRUFBRTtZQUNUa2UsSUFBSSxDQUFDbGUsRUFBRSxDQUFDN1AsSUFBSSxDQUFDN1U7UUFDakIsT0FDSztZQUNENGlDLElBQUksQ0FBQ2xlLEVBQUUsR0FBRztnQkFBQzFrQjthQUFLO1FBQ3BCO1FBQ0EwaUMsV0FBV2hlLElBQUlnZSxXQUFXaGUsSUFBSWdlO1FBQzlCLE9BQU9FO0lBQ1gsR0FBRyxDQUFDO0lBQ0osTUFBTU0sV0FBV3h4QixPQUFPcXJCLE9BQU8sQ0FBQzRGLGFBQWF6eEIsR0FBRyxDQUFDLENBQUMsQ0FBQ1csS0FBSzNILE1BQU07UUFDMUQsTUFBTW80QixRQUFRLENBQUN6d0I7UUFDZixPQUFPO1lBQ0gzSDtZQUNBbzRCO1lBQ0FDLFlBQVlELFVBQVVJO1FBQzFCO0lBQ0o7SUFDQSxJQUFJUSxTQUFTdHpCLE1BQU0sS0FBSyxHQUFHO1FBQ3ZCLE9BQU95eUI7SUFDWDtJQUNBLE9BQU9hO0FBQ1g7QUFDQSxTQUFTQyxnQkFBZ0JySCxpQkFBaUIsRUFBRWpvQixhQUFhLEVBQUU0dUIsb0JBQW9CO0lBQzNFLE1BQU12NEIsUUFBUTNKLFNBQVNuQyxrREFBV0EsQ0FBQyxDQUFDOEM7UUFDaEMsSUFBSSxDQUFDNDZCLG1CQUFtQjtZQUNwQixPQUFPNTZCLEVBQUVnSixLQUFLO1FBQ2xCO1FBQ0EsT0FBT2hKLEVBQUVnSixLQUFLLENBQUMrRyxNQUFNLENBQUMsQ0FBQzdHO1lBQ25CLE1BQU0yNEIsYUFBYWx2QixjQUFjMlEsR0FBRyxDQUFDcGEsRUFBRW9DLE1BQU07WUFDN0MsTUFBTXMyQixhQUFhanZCLGNBQWMyUSxHQUFHLENBQUNwYSxFQUFFbEksTUFBTTtZQUM3QyxPQUFRNmdDLFlBQVkvL0IsU0FDaEIrL0IsWUFBWTkvQixVQUNaNi9CLFlBQVk5L0IsU0FDWjgvQixZQUFZNy9CLFVBQ1owK0IsY0FBYztnQkFDVkMsV0FBV21CLFdBQVdsOUIsZ0JBQWdCLElBQUk7b0JBQUV4RCxHQUFHO29CQUFHQyxHQUFHO2dCQUFFO2dCQUN2RHUvQixXQUFXaUIsV0FBV2o5QixnQkFBZ0IsSUFBSTtvQkFBRXhELEdBQUc7b0JBQUdDLEdBQUc7Z0JBQUU7Z0JBQ3ZEdy9CLGFBQWFpQixXQUFXLy9CLEtBQUs7Z0JBQzdCKytCLGNBQWNnQixXQUFXOS9CLE1BQU07Z0JBQy9CKytCLGFBQWFjLFdBQVc5L0IsS0FBSztnQkFDN0JpL0IsY0FBY2EsV0FBVzcvQixNQUFNO2dCQUMvQkQsT0FBTzlCLEVBQUU4QixLQUFLO2dCQUNkQyxRQUFRL0IsRUFBRStCLE1BQU07Z0JBQ2hCSyxXQUFXcEMsRUFBRW9DLFNBQVM7WUFDMUI7UUFDUjtJQUNKLEdBQUc7UUFBQ3c0QjtRQUFtQmpvQjtLQUFjO0lBQ3JDLE9BQU8ydUIsbUJBQW1CdDRCLE9BQU8ySixlQUFlNHVCO0FBQ3BEO0FBRUEsTUFBTVcsY0FBYyxDQUFDLEVBQUVDLFFBQVEsTUFBTSxFQUFFMzVCLGNBQWMsQ0FBQyxFQUFFO0lBQ3BELHFCQUFRL0wsZ0RBQW1CLENBQUMsWUFBWTtRQUFFNkQsT0FBTztZQUN6Q2k5QixRQUFRNEU7WUFDUjM1QjtRQUNKO1FBQUc0NUIsZUFBZTtRQUFTQyxnQkFBZ0I7UUFBUy81QixNQUFNO1FBQVFnRSxRQUFRO0lBQWlCO0FBQ25HO0FBQ0EsTUFBTWcyQixvQkFBb0IsQ0FBQyxFQUFFSCxRQUFRLE1BQU0sRUFBRTM1QixjQUFjLENBQUMsRUFBRTtJQUMxRCxxQkFBUS9MLGdEQUFtQixDQUFDLFlBQVk7UUFBRTZELE9BQU87WUFDekNpOUIsUUFBUTRFO1lBQ1I3NUIsTUFBTTY1QjtZQUNOMzVCO1FBQ0o7UUFBRzQ1QixlQUFlO1FBQVNDLGdCQUFnQjtRQUFTLzFCLFFBQVE7SUFBdUI7QUFDM0Y7QUFDQSxNQUFNaTJCLGdCQUFnQjtJQUNsQixDQUFDaDRCLFdBQVdpNEIsS0FBSyxDQUFDLEVBQUVOO0lBQ3BCLENBQUMzM0IsV0FBV2s0QixXQUFXLENBQUMsRUFBRUg7QUFDOUI7QUFDQSxTQUFTSSxnQkFBZ0IvakMsSUFBSTtJQUN6QixNQUFNYSxRQUFRRTtJQUNkLE1BQU1pakMsU0FBUy9sQyw4Q0FBT0EsQ0FBQztRQUNuQixNQUFNZ21DLGVBQWVweUIsT0FBT3NvQixTQUFTLENBQUNDLGNBQWMsQ0FBQ2hNLElBQUksQ0FBQ3dWLGVBQWU1akM7UUFDekUsSUFBSSxDQUFDaWtDLGNBQWM7WUFDZnBqQyxNQUFNRyxRQUFRLEdBQUcwYixPQUFPLEdBQUcsT0FBT3JkLGFBQWEsQ0FBQyxXQUFXLENBQUNXO1lBQzVELE9BQU87UUFDWDtRQUNBLE9BQU80akMsYUFBYSxDQUFDNWpDLEtBQUs7SUFDOUIsR0FBRztRQUFDQTtLQUFLO0lBQ1QsT0FBT2drQztBQUNYO0FBRUEsTUFBTUUsU0FBUyxDQUFDLEVBQUVwa0MsRUFBRSxFQUFFRSxJQUFJLEVBQUV3akMsS0FBSyxFQUFFcmdDLFFBQVEsSUFBSSxFQUFFQyxTQUFTLElBQUksRUFBRStnQyxjQUFjLGFBQWEsRUFBRXQ2QixXQUFXLEVBQUV1NkIsU0FBUyxvQkFBb0IsRUFBRztJQUN0SSxNQUFNbjlCLFVBQVM4OEIsZ0JBQWdCL2pDO0lBQy9CLElBQUksQ0FBQ2lILFNBQVE7UUFDVCxPQUFPO0lBQ1g7SUFDQSxxQkFBUW5KLGdEQUFtQixDQUFDLFVBQVU7UUFBRTRELFdBQVc7UUFBeUI1QixJQUFJQTtRQUFJdWtDLGFBQWEsQ0FBQyxFQUFFbGhDLE1BQU0sQ0FBQztRQUFFbWhDLGNBQWMsQ0FBQyxFQUFFbGhDLE9BQU8sQ0FBQztRQUFFay9CLFNBQVM7UUFBaUI2QixhQUFhQTtRQUFhQyxRQUFRQTtRQUFRRyxNQUFNO1FBQUtDLE1BQU07SUFBSSxpQkFDN04xbUMsZ0RBQW1CLENBQUNtSixTQUFRO1FBQUV1OEIsT0FBT0E7UUFBTzM1QixhQUFhQTtJQUFZO0FBQzdFO0FBQ0EsTUFBTTQ2QixpQkFBaUIsQ0FBQyxFQUFFQyxZQUFZLEVBQUUveUIsSUFBSSxFQUFFLEdBQUssQ0FBQ3RRO1FBQ2hELE1BQU1zakMsTUFBTSxFQUFFO1FBQ2QsT0FBT3RqQyxFQUFFZ0osS0FBSyxDQUNUcUYsTUFBTSxDQUFDLENBQUNrMUIsU0FBU3prQztZQUNsQjtnQkFBQ0EsS0FBS29KLFdBQVc7Z0JBQUVwSixLQUFLbUosU0FBUzthQUFDLENBQUNnTCxPQUFPLENBQUMsQ0FBQzVDO2dCQUN4QyxJQUFJQSxVQUFVLE9BQU9BLFdBQVcsVUFBVTtvQkFDdEMsTUFBTW16QixXQUFXcHpCLFlBQVlDLFFBQVFDO29CQUNyQyxJQUFJLENBQUNnekIsSUFBSTM4QixRQUFRLENBQUM2OEIsV0FBVzt3QkFDekJELFFBQVE1dkIsSUFBSSxDQUFDOzRCQUFFbFYsSUFBSStrQzs0QkFBVXJCLE9BQU85eEIsT0FBTzh4QixLQUFLLElBQUlrQjs0QkFBYyxHQUFHaHpCLE1BQU07d0JBQUM7d0JBQzVFaXpCLElBQUkzdkIsSUFBSSxDQUFDNnZCO29CQUNiO2dCQUNKO1lBQ0o7WUFDQSxPQUFPRDtRQUNYLEdBQUcsRUFBRSxFQUNBN3lCLElBQUksQ0FBQyxDQUFDbEYsR0FBR0MsSUFBTUQsRUFBRS9NLEVBQUUsQ0FBQ2dsQyxhQUFhLENBQUNoNEIsRUFBRWhOLEVBQUU7SUFDL0M7QUFDQSw0R0FBNEc7QUFDNUcsdUhBQXVIO0FBQ3ZILDBEQUEwRDtBQUMxRCxNQUFNaWxDLG9CQUFvQixDQUFDLEVBQUVMLFlBQVksRUFBRS95QixJQUFJLEVBQUU7SUFDN0MsTUFBTWl6QixVQUFVbGtDLFNBQVNuQyxrREFBV0EsQ0FBQ2ttQyxlQUFlO1FBQUVDO1FBQWMveUI7SUFBSyxJQUFJO1FBQUMreUI7UUFBYy95QjtLQUFLLEdBQ2pHLHlGQUF5RjtJQUN6RixDQUFDOUUsR0FBR0MsSUFBTSxDQUFFRCxDQUFBQSxFQUFFa0QsTUFBTSxLQUFLakQsRUFBRWlELE1BQU0sSUFBSWxELEVBQUVzRixJQUFJLENBQUMsQ0FBQzZ5QixHQUFHbjFCLElBQU1tMUIsRUFBRWxsQyxFQUFFLEtBQUtnTixDQUFDLENBQUMrQyxFQUFFLENBQUMvUCxFQUFFO0lBQ3RFLHFCQUFRaEMsZ0RBQW1CLENBQUMsUUFBUSxNQUFNOG1DLFFBQVF2ekIsR0FBRyxDQUFDLENBQUNLLHVCQUFZNVQsZ0RBQW1CLENBQUNvbUMsUUFBUTtZQUFFcGtDLElBQUk0UixPQUFPNVIsRUFBRTtZQUFFa1MsS0FBS04sT0FBTzVSLEVBQUU7WUFBRUUsTUFBTTBSLE9BQU8xUixJQUFJO1lBQUV3akMsT0FBTzl4QixPQUFPOHhCLEtBQUs7WUFBRXJnQyxPQUFPdU8sT0FBT3ZPLEtBQUs7WUFBRUMsUUFBUXNPLE9BQU90TyxNQUFNO1lBQUUrZ0MsYUFBYXp5QixPQUFPeXlCLFdBQVc7WUFBRXQ2QixhQUFhNkgsT0FBTzdILFdBQVc7WUFBRXU2QixRQUFRMXlCLE9BQU8weUIsTUFBTTtRQUFDO0FBQ2hUO0FBQ0FXLGtCQUFrQmo3QixXQUFXLEdBQUc7QUFDaEMsSUFBSW03QixvQ0FBc0IvbUMsMkNBQUlBLENBQUM2bUM7QUFFL0IsTUFBTUcsYUFBYSxDQUFDN2pDLElBQU87UUFDdkIwZSxrQkFBa0IxZSxFQUFFMGUsZ0JBQWdCO1FBQ3BDRSxnQkFBZ0I1ZSxFQUFFNGUsY0FBYztRQUNoQ0MsZ0JBQWdCN2UsRUFBRTZlLGNBQWM7UUFDaENLLG9CQUFvQmxmLEVBQUVrZixrQkFBa0I7UUFDeENwZCxPQUFPOUIsRUFBRThCLEtBQUs7UUFDZEMsUUFBUS9CLEVBQUUrQixNQUFNO1FBQ2hCNlUsZ0JBQWdCNVcsRUFBRTRXLGNBQWM7UUFDaENqRSxlQUFlM1MsRUFBRTJTLGFBQWE7UUFDOUIwSSxTQUFTcmIsRUFBRXFiLE9BQU87SUFDdEI7QUFDQSxNQUFNeW9CLGVBQWUsQ0FBQyxFQUFFQyxrQkFBa0IsRUFBRXJJLHlCQUF5QixFQUFFNkYsb0JBQW9CLEVBQUVqeEIsSUFBSSxFQUFFc3ZCLFNBQVMsRUFBRXBsQixjQUFjLEVBQUV5akIsWUFBWSxFQUFFWSxpQkFBaUIsRUFBRUMsZ0JBQWdCLEVBQUVDLGVBQWUsRUFBRUMsZ0JBQWdCLEVBQUVOLFdBQVcsRUFBRVYsaUJBQWlCLEVBQUVKLGlCQUFpQixFQUFFTSxpQkFBaUIsRUFBRTdsQixlQUFlLEVBQUVqWSxRQUFRLEVBQUc7SUFDbFQsTUFBTSxFQUFFd2UsY0FBYyxFQUFFQyxjQUFjLEVBQUVLLGtCQUFrQixFQUFFcGQsS0FBSyxFQUFFQyxNQUFNLEVBQUU2VSxjQUFjLEVBQUVqRSxhQUFhLEVBQUUwSSxPQUFPLEVBQUUsR0FBR2hjLFNBQVN3a0MsWUFBWXZtQyxvREFBT0E7SUFDbEosTUFBTTBrQyxXQUFXQyxnQkFBZ0J2RywyQkFBMkIvb0IsZUFBZTR1QjtJQUMzRSxJQUFJLENBQUN6L0IsT0FBTztRQUNSLE9BQU87SUFDWDtJQUNBLHFCQUFRckYsZ0RBQW1CLENBQUNBLDJDQUFjLEVBQUUsTUFDeEN1bEMsU0FBU2h5QixHQUFHLENBQUMsQ0FBQyxFQUFFb3hCLEtBQUssRUFBRXA0QixLQUFLLEVBQUVxNEIsVUFBVSxFQUFFLGlCQUFNNWtDLGdEQUFtQixDQUFDLE9BQU87WUFBRWtVLEtBQUt5d0I7WUFBTzlnQyxPQUFPO2dCQUFFMGpCLFFBQVFvZDtZQUFNO1lBQUd0L0IsT0FBT0E7WUFBT0MsUUFBUUE7WUFBUTFCLFdBQVc7UUFBMEMsR0FDbE1naEMsNEJBQWM1a0MsZ0RBQW1CLENBQUNtbkMscUJBQXFCO1lBQUVQLGNBQWNVO1lBQW9CenpCLE1BQU1BO1FBQUssa0JBQ3RHN1QsZ0RBQW1CLENBQUMsS0FBSyxNQUFNdU0sTUFBTWdILEdBQUcsQ0FBQyxDQUFDbFI7WUFDdEMsTUFBTSxDQUFDdWhDLGdCQUFnQjJELG9CQUFvQkMsY0FBYyxHQUFHL0MsWUFBWXZ1QixjQUFjMlEsR0FBRyxDQUFDeGtCLEtBQUt3TSxNQUFNO1lBQ3JHLE1BQU0sQ0FBQ2cxQixnQkFBZ0I0RCxvQkFBb0JDLGNBQWMsR0FBR2pELFlBQVl2dUIsY0FBYzJRLEdBQUcsQ0FBQ3hrQixLQUFLa0MsTUFBTTtZQUNyRyxJQUFJLENBQUNpakMsaUJBQWlCLENBQUNFLGVBQWU7Z0JBQ2xDLE9BQU87WUFDWDtZQUNBLElBQUlqbEMsV0FBV0osS0FBS0gsSUFBSSxJQUFJO1lBQzVCLElBQUksQ0FBQ2loQyxTQUFTLENBQUMxZ0MsU0FBUyxFQUFFO2dCQUN0Qm1jLFVBQVUsT0FBT3JkLGFBQWEsQ0FBQyxXQUFXLENBQUNrQjtnQkFDM0NBLFdBQVc7WUFDZjtZQUNBLE1BQU13K0IsZ0JBQWdCa0MsU0FBUyxDQUFDMWdDLFNBQVMsSUFBSTBnQyxVQUFVM0UsT0FBTztZQUM5RCxrR0FBa0c7WUFDbEcsTUFBTW1KLG9CQUFvQnh0QixtQkFBbUJ6TSxlQUFlcU4sTUFBTSxHQUM1RDBzQixtQkFBbUJsakMsTUFBTSxHQUN6QixDQUFDa2pDLG1CQUFtQmxqQyxNQUFNLElBQUksRUFBRSxFQUFFa1EsTUFBTSxDQUFDZ3pCLG1CQUFtQjU0QixNQUFNLElBQUksRUFBRTtZQUM5RSxNQUFNek0sZUFBZXNoQyxVQUFVNkQsbUJBQW1CMTRCLE1BQU0sRUFBRXhNLEtBQUtELFlBQVk7WUFDM0UsTUFBTUUsZUFBZW9oQyxVQUFVaUUsbUJBQW1CdGxDLEtBQUtDLFlBQVk7WUFDbkUsTUFBTWdNLGlCQUFpQmxNLGNBQWNzQixZQUFZcUssU0FBU1EsTUFBTTtZQUNoRSxNQUFNQyxpQkFBaUJsTSxjQUFjb0IsWUFBWXFLLFNBQVNVLEdBQUc7WUFDN0QsTUFBTTZzQixjQUFjLENBQUMsQ0FBRWo1QixDQUFBQSxLQUFLbTlCLFNBQVMsSUFBS3JkLGtCQUFrQixPQUFPOWYsS0FBS205QixTQUFTLEtBQUssV0FBVztZQUNqRyxNQUFNa0MsY0FBYyxPQUFPRixpQkFBaUIsZUFDdkNuL0IsQ0FBQUEsS0FBS3VsQyxTQUFTLElBQUt4bEIsa0JBQWtCLE9BQU8vZixLQUFLdWxDLFNBQVMsS0FBSyxXQUFXO1lBQy9FLElBQUksQ0FBQ3hsQyxnQkFBZ0IsQ0FBQ0UsY0FBYztnQkFDaENzYyxVQUFVLE9BQU9yZCxhQUFhLENBQUMsV0FBVyxDQUFDYSxjQUFjQztnQkFDekQsT0FBTztZQUNYO1lBQ0EsTUFBTSxFQUFFc0ssT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFLEdBQUc2MkIsaUJBQWlCQyxnQkFBZ0J4aEMsY0FBY2tNLGdCQUFnQnUxQixnQkFBZ0J2aEMsY0FBY2tNO1lBQzVJLHFCQUFReE8sZ0RBQW1CLENBQUNpaEMsZUFBZTtnQkFBRS9zQixLQUFLN1IsS0FBS0wsRUFBRTtnQkFBRUEsSUFBSUssS0FBS0wsRUFBRTtnQkFBRTRCLFdBQVdsRCxvREFBRUEsQ0FBQztvQkFBQzJCLEtBQUt1QixTQUFTO29CQUFFbWE7aUJBQWU7Z0JBQUc3YixNQUFNTztnQkFBVXNkLE1BQU0xZCxLQUFLMGQsSUFBSTtnQkFBRVMsVUFBVSxDQUFDLENBQUNuZSxLQUFLbWUsUUFBUTtnQkFBRTRnQixVQUFVLENBQUMsQ0FBQy8rQixLQUFLKytCLFFBQVE7Z0JBQUUxcUIsUUFBUSxDQUFDLENBQUNyVSxLQUFLcVUsTUFBTTtnQkFBRTlSLE9BQU92QyxLQUFLdUMsS0FBSztnQkFBRUMsWUFBWXhDLEtBQUt3QyxVQUFVO2dCQUFFQyxhQUFhekMsS0FBS3lDLFdBQVc7Z0JBQUVDLGNBQWMxQyxLQUFLMEMsWUFBWTtnQkFBRUMsZ0JBQWdCM0MsS0FBSzJDLGNBQWM7Z0JBQUVDLHFCQUFxQjVDLEtBQUs0QyxtQkFBbUI7Z0JBQUVwQixPQUFPeEIsS0FBS3dCLEtBQUs7Z0JBQUVnTCxRQUFReE0sS0FBS3dNLE1BQU07Z0JBQUV0SyxRQUFRbEMsS0FBS2tDLE1BQU07Z0JBQUU4OEIsZ0JBQWdCaC9CLEtBQUtELFlBQVk7Z0JBQUVrL0IsZ0JBQWdCai9CLEtBQUtDLFlBQVk7Z0JBQUVrSixXQUFXbkosS0FBS21KLFNBQVM7Z0JBQUVDLGFBQWFwSixLQUFLb0osV0FBVztnQkFBRWtCLFNBQVNBO2dCQUFTQyxTQUFTQTtnQkFBU0MsU0FBU0E7Z0JBQVNDLFNBQVNBO2dCQUFTd0IsZ0JBQWdCQTtnQkFBZ0JFLGdCQUFnQkE7Z0JBQWdCaVUsb0JBQW9CQTtnQkFBb0IrZSxjQUFjQTtnQkFBY3RNLGVBQWVrTjtnQkFBbUJyTSxjQUFjc007Z0JBQWtCL00sYUFBYWdOO2dCQUFpQnpNLGNBQWMwTTtnQkFBa0JsakIsU0FBUzRpQjtnQkFBYVYsbUJBQW1CQTtnQkFBbUJKLG1CQUFtQkE7Z0JBQW1CTSxtQkFBbUJBO2dCQUFtQjdsQixpQkFBaUJBO2dCQUFpQi9ILE1BQU1BO2dCQUFNNG5CLFdBQVdwNUIsS0FBS281QixTQUFTO2dCQUFFSCxhQUFhQTtnQkFBYW9HLGFBQWFBO2dCQUFhdnZCLGFBQWEsaUJBQWlCOVAsT0FBT0EsS0FBSzhQLFdBQVcsR0FBRzdGO2dCQUFXWixrQkFBa0JySixLQUFLcUosZ0JBQWdCO1lBQUM7UUFDeHlDLE9BQ0ovSDtBQUNSO0FBQ0EwakMsYUFBYXI3QixXQUFXLEdBQUc7QUFDM0IsSUFBSTY3QiwrQkFBaUJ6bkMsMkNBQUlBLENBQUNpbkM7QUFFMUIsTUFBTVMsYUFBYSxDQUFDdmtDLElBQU0sQ0FBQyxVQUFVLEVBQUVBLEVBQUVvQyxTQUFTLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRXBDLEVBQUVvQyxTQUFTLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRXBDLEVBQUVvQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUN2RyxTQUFTb2lDLFNBQVMsRUFBRXBrQyxRQUFRLEVBQUU7SUFDMUIsTUFBTWdDLFlBQVkvQyxTQUFTa2xDO0lBQzNCLHFCQUFROW5DLGdEQUFtQixDQUFDLE9BQU87UUFBRTRELFdBQVc7UUFBOENDLE9BQU87WUFBRThCO1FBQVU7SUFBRSxHQUFHaEM7QUFDMUg7QUFFQSxTQUFTcWtDLGlCQUFpQkMsTUFBTTtJQUM1QixNQUFNQyxhQUFhdGQ7SUFDbkIsTUFBTXVkLGdCQUFnQjluQyw2Q0FBTUEsQ0FBQztJQUM3QkUsZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUM0bkMsY0FBYzNpQyxPQUFPLElBQUkwaUMsV0FBV2xlLG1CQUFtQixJQUFJaWUsUUFBUTtZQUNwRXJXLFdBQVcsSUFBTXFXLE9BQU9DLGFBQWE7WUFDckNDLGNBQWMzaUMsT0FBTyxHQUFHO1FBQzVCO0lBQ0osR0FBRztRQUFDeWlDO1FBQVFDLFdBQVdsZSxtQkFBbUI7S0FBQztBQUMvQztBQUVBLE1BQU1vZSxtQkFBbUI7SUFDckIsQ0FBQ3I2QixTQUFTSSxJQUFJLENBQUMsRUFBRUosU0FBU0ssS0FBSztJQUMvQixDQUFDTCxTQUFTSyxLQUFLLENBQUMsRUFBRUwsU0FBU0ksSUFBSTtJQUMvQixDQUFDSixTQUFTVSxHQUFHLENBQUMsRUFBRVYsU0FBU1EsTUFBTTtJQUMvQixDQUFDUixTQUFTUSxNQUFNLENBQUMsRUFBRVIsU0FBU1UsR0FBRztBQUNuQztBQUNBLE1BQU00NUIsaUJBQWlCLENBQUMsRUFBRXIxQixNQUFNLEVBQUVtRyxVQUFVLEVBQUV0VixLQUFLLEVBQUUzQixPQUFPMkwsbUJBQW1CeTZCLE1BQU0sRUFBRUMsZUFBZSxFQUFFOXNCLGdCQUFnQixFQUFHO0lBQ3ZILE1BQU0sRUFBRStzQixRQUFRLEVBQUVudkIsUUFBUSxFQUFFb3ZCLEdBQUcsRUFBRUMsR0FBRyxFQUFFdnVCLGNBQWMsRUFBRSxHQUFHdlgsU0FBU25DLGtEQUFXQSxDQUFDLENBQUM4QyxJQUFPO1lBQ2xGaWxDLFVBQVVqbEMsRUFBRTJTLGFBQWEsQ0FBQzJRLEdBQUcsQ0FBQzdUO1lBQzlCcUcsVUFBVTlWLEVBQUV5WixrQkFBa0I7WUFDOUJ5ckIsS0FBSyxDQUFDbGxDLEVBQUVtWixrQkFBa0IsQ0FBQ2hZLENBQUMsR0FBR25CLEVBQUVvQyxTQUFTLENBQUMsRUFBRSxJQUFJcEMsRUFBRW9DLFNBQVMsQ0FBQyxFQUFFO1lBQy9EK2lDLEtBQUssQ0FBQ25sQyxFQUFFbVosa0JBQWtCLENBQUMvWCxDQUFDLEdBQUdwQixFQUFFb0MsU0FBUyxDQUFDLEVBQUUsSUFBSXBDLEVBQUVvQyxTQUFTLENBQUMsRUFBRTtZQUMvRHdVLGdCQUFnQjVXLEVBQUU0VyxjQUFjO1FBQ3BDLElBQUk7UUFBQ25IO0tBQU8sR0FBR25TLG9EQUFPQTtJQUN0QixNQUFNOG5DLG1CQUFtQkgsVUFBVSxDQUFDdC9CLGdCQUFnQixFQUFFa1A7SUFDdEQsSUFBSUEsZUFBZXV3QixrQkFBa0IsQ0FBQ3h2QixXQUFXO0lBQ2pELElBQUlnQixtQkFBbUJ6TSxlQUFlazdCLEtBQUssRUFBRTtRQUN6Q3h3QixlQUFlQSxlQUFlQSxlQUFldXdCLGtCQUFrQixDQUFDeHZCLGVBQWUsV0FBVyxXQUFXLFNBQVM7SUFDbEg7SUFDQSxJQUFJLENBQUNxdkIsWUFBWSxDQUFDcHdCLGNBQWM7UUFDNUIsT0FBTztJQUNYO0lBQ0EsTUFBTXl3QixhQUFheHZCLFdBQVdqQixhQUFhNUwsSUFBSSxDQUFDLENBQUNaLElBQU1BLEVBQUU1SixFQUFFLEtBQUtxWCxZQUFZakIsWUFBWSxDQUFDLEVBQUU7SUFDM0YsTUFBTTB3QixjQUFjRCxhQUFhQSxXQUFXbmtDLENBQUMsR0FBR21rQyxXQUFXeGpDLEtBQUssR0FBRyxJQUFJLENBQUNtakMsU0FBU25qQyxLQUFLLElBQUksS0FBSztJQUMvRixNQUFNMGpDLGNBQWNGLGFBQWFBLFdBQVdsa0MsQ0FBQyxHQUFHa2tDLFdBQVd2akMsTUFBTSxHQUFHLElBQUlrakMsU0FBU2xqQyxNQUFNLElBQUk7SUFDM0YsTUFBTTBqQyxRQUFRLENBQUNSLFNBQVN0Z0MsZ0JBQWdCLEVBQUV4RCxLQUFLLEtBQUtva0M7SUFDcEQsTUFBTUcsUUFBUSxDQUFDVCxTQUFTdGdDLGdCQUFnQixFQUFFdkQsS0FBSyxLQUFLb2tDO0lBQ3BELE1BQU1HLGVBQWVMLFlBQVlubEM7SUFDakMsTUFBTXlsQyxhQUFhRCxlQUFlZCxnQkFBZ0IsQ0FBQ2MsYUFBYSxHQUFHO0lBQ25FLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUNDLFlBQVk7UUFDOUIsT0FBTztJQUNYO0lBQ0EsSUFBSVosaUJBQWlCO1FBQ2pCLHFCQUFRdm9DLGdEQUFtQixDQUFDdW9DLGlCQUFpQjtZQUFFYSxvQkFBb0JsbkM7WUFBTW1uQyxxQkFBcUJ4bEM7WUFBTzJrQyxVQUFVQTtZQUFVSyxZQUFZQTtZQUFZRyxPQUFPQTtZQUFPQyxPQUFPQTtZQUFPUixLQUFLQTtZQUFLQyxLQUFLQTtZQUFLUSxjQUFjQTtZQUFjQyxZQUFZQTtZQUFZMXRCLGtCQUFrQkE7UUFBaUI7SUFDNVI7SUFDQSxJQUFJNnRCLFFBQVE7SUFDWixNQUFNQyxhQUFhO1FBQ2Y1OEIsU0FBU3E4QjtRQUNUcDhCLFNBQVNxOEI7UUFDVDM2QixnQkFBZ0I0NkI7UUFDaEJyOEIsU0FBUzQ3QjtRQUNUMzdCLFNBQVM0N0I7UUFDVGw2QixnQkFBZ0IyNkI7SUFDcEI7SUFDQSxJQUFJam5DLFNBQVMyTCxtQkFBbUJ5NkIsTUFBTSxFQUFFO1FBQ3BDLHdFQUF3RTtRQUN4RSxDQUFDZ0IsTUFBTSxHQUFHMzJCLGNBQWM0MkI7SUFDNUIsT0FDSyxJQUFJcm5DLFNBQVMyTCxtQkFBbUIyN0IsSUFBSSxFQUFFO1FBQ3ZDLENBQUNGLE1BQU0sR0FBRzUzQixrQkFBa0I7WUFDeEIsR0FBRzYzQixVQUFVO1lBQ2I1M0IsY0FBYztRQUNsQjtJQUNKLE9BQ0ssSUFBSXpQLFNBQVMyTCxtQkFBbUI0N0IsVUFBVSxFQUFFO1FBQzdDLENBQUNILE1BQU0sR0FBRzUzQixrQkFBa0I2M0I7SUFDaEMsT0FDSyxJQUFJcm5DLFNBQVMyTCxtQkFBbUI2N0IsWUFBWSxFQUFFO1FBQy9DLENBQUNKLE1BQU0sR0FBR2o3QixvQkFBb0JrN0I7SUFDbEMsT0FDSztRQUNERCxRQUFRLENBQUMsQ0FBQyxFQUFFTixNQUFNLENBQUMsRUFBRUMsTUFBTSxDQUFDLEVBQUVSLElBQUksQ0FBQyxFQUFFQyxJQUFJLENBQUM7SUFDOUM7SUFDQSxxQkFBTzFvQyxnREFBbUIsQ0FBQyxRQUFRO1FBQUU0TCxHQUFHMDlCO1FBQU96OUIsTUFBTTtRQUFRakksV0FBVztRQUErQkMsT0FBT0E7SUFBTTtBQUN4SDtBQUNBd2tDLGVBQWVyOEIsV0FBVyxHQUFHO0FBQzdCLE1BQU0yOUIsYUFBYSxDQUFDcG1DLElBQU87UUFDdkJ5UCxRQUFRelAsRUFBRXdaLGdCQUFnQjtRQUMxQjVELFlBQVk1VixFQUFFMFosb0JBQW9CO1FBQ2xDZ0Ysa0JBQWtCMWUsRUFBRTBlLGdCQUFnQjtRQUNwQ3hHLGtCQUFrQmxZLEVBQUVrWSxnQkFBZ0I7UUFDcENwVyxPQUFPOUIsRUFBRThCLEtBQUs7UUFDZEMsUUFBUS9CLEVBQUUrQixNQUFNO0lBQ3BCO0FBQ0EsU0FBU3NrQyxzQkFBc0IsRUFBRWpjLGNBQWMsRUFBRTlwQixLQUFLLEVBQUUzQixJQUFJLEVBQUUybkMsU0FBUyxFQUFFO0lBQ3JFLE1BQU0sRUFBRTcyQixNQUFNLEVBQUVtRyxVQUFVLEVBQUU4SSxnQkFBZ0IsRUFBRTVjLEtBQUssRUFBRUMsTUFBTSxFQUFFbVcsZ0JBQWdCLEVBQUUsR0FBRzdZLFNBQVMrbUMsWUFBWTlvQyxvREFBT0E7SUFDOUcsTUFBTStZLFVBQVUsQ0FBQyxDQUFFNUcsQ0FBQUEsVUFBVW1HLGNBQWM5VCxTQUFTNGMsZ0JBQWU7SUFDbkUsSUFBSSxDQUFDckksU0FBUztRQUNWLE9BQU87SUFDWDtJQUNBLHFCQUFRNVosZ0RBQW1CLENBQUMsT0FBTztRQUFFNkQsT0FBTzhwQjtRQUFnQnRvQixPQUFPQTtRQUFPQyxRQUFRQTtRQUFRMUIsV0FBVztJQUFxRSxpQkFDdEs1RCxnREFBbUIsQ0FBQyxLQUFLO1FBQUU0RCxXQUFXbEQsb0RBQUVBLENBQUM7WUFBQztZQUEwQithO1NBQWlCO0lBQUUsaUJBQ25GemIsZ0RBQW1CLENBQUNxb0MsZ0JBQWdCO1FBQUVyMUIsUUFBUUE7UUFBUW1HLFlBQVlBO1FBQVl0VixPQUFPQTtRQUFPM0IsTUFBTUE7UUFBTXFtQyxpQkFBaUJzQjtRQUFXcHVCLGtCQUFrQkE7SUFBaUI7QUFDbkw7QUFFQSw4REFBOEQ7QUFDOUQsU0FBU3F1QixtQkFBbUJDLGVBQWUsRUFBRUMsV0FBVztJQUNwRCxNQUFNQyxlQUFlNXBDLDZDQUFNQSxDQUFDO0lBQzVCLE1BQU0wQyxRQUFRRTtJQUNkLE1BQU1pbkMsY0FBYy9wQyw4Q0FBT0EsQ0FBQztRQUN4QixJQUFJcUosSUFBeUIsRUFBZTtZQUN4QyxNQUFNMmdDLFdBQVdwMkIsT0FBT0MsSUFBSSxDQUFDKzFCO1lBQzdCLElBQUlscEMsd0RBQU9BLENBQUNvcEMsYUFBYXprQyxPQUFPLEVBQUUya0MsV0FBVztnQkFDekNwbkMsTUFBTUcsUUFBUSxHQUFHMGIsT0FBTyxHQUFHLE9BQU9yZCxhQUFhLENBQUMsV0FBVztZQUMvRDtZQUNBMG9DLGFBQWF6a0MsT0FBTyxHQUFHMmtDO1FBQzNCO1FBQ0EsT0FBT0gsWUFBWUQ7SUFDdkIsR0FBRztRQUFDQTtLQUFnQjtJQUNwQixPQUFPRztBQUNYO0FBRUEsTUFBTUUsWUFBWSxDQUFDLEVBQUUvTCxTQUFTLEVBQUU4RSxTQUFTLEVBQUV4VSxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsU0FBUyxFQUFFb1osTUFBTSxFQUFFcEksV0FBVyxFQUFFb0MsV0FBVyxFQUFFL0IsaUJBQWlCLEVBQUVpQixpQkFBaUIsRUFBRXJCLGdCQUFnQixFQUFFQyxlQUFlLEVBQUVDLGdCQUFnQixFQUFFQyxpQkFBaUIsRUFBRTdDLHNCQUFzQixFQUFFOUksZ0JBQWdCLEVBQUVDLGNBQWMsRUFBRTZVLGtCQUFrQixFQUFFQyxtQkFBbUIsRUFBRWdCLHVCQUF1QixFQUFFQyw0QkFBNEIsRUFBRTVNLGdCQUFnQixFQUFFQyxlQUFlLEVBQUV2SixhQUFhLEVBQUVySCxxQkFBcUIsRUFBRTZRLG9CQUFvQixFQUFFck8scUJBQXFCLEVBQUV6QyxhQUFhLEVBQUVtUyx5QkFBeUIsRUFBRXhjLGtCQUFrQixFQUFFcVcsaUJBQWlCLEVBQUV4SixlQUFlLEVBQUUzTSxlQUFlLEVBQUVyTCxPQUFPLEVBQUVDLE9BQU8sRUFBRWlZLGdCQUFnQixFQUFFOFgsa0JBQWtCLEVBQUV2WSxZQUFZLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxnQkFBZ0IsRUFBRUMsZUFBZSxFQUFFRSxpQkFBaUIsRUFBRW5CLFNBQVMsRUFBRXNHLFdBQVcsRUFBRUUsZ0JBQWdCLEVBQUVDLGVBQWUsRUFBRUMsZ0JBQWdCLEVBQUVILFlBQVksRUFBRTNGLGlCQUFpQixFQUFFMFMsWUFBWSxFQUFFWSxpQkFBaUIsRUFBRUMsZ0JBQWdCLEVBQUVDLGVBQWUsRUFBRUMsZ0JBQWdCLEVBQUVoQixpQkFBaUIsRUFBRUUsaUJBQWlCLEVBQUU3bEIsZUFBZSxFQUFFK2MsZUFBZSxFQUFFbEosZ0JBQWdCLEVBQUUxUixjQUFjLEVBQUUrbUIsb0JBQW9CLEVBQUV2Z0IsbUJBQW1CLEVBQUU1TyxVQUFVLEVBQUUyTSxVQUFVLEVBQUV6TyxJQUFJLEVBQUc7SUFDeG1DLE1BQU0wMkIsbUJBQW1CVCxtQkFBbUJ6TCxXQUFXRDtJQUN2RCxNQUFNb00sbUJBQW1CVixtQkFBbUIzRyxXQUFXRDtJQUN2RDhFLGlCQUFpQkM7SUFDakIscUJBQVFqb0MsZ0RBQW1CLENBQUNpK0IsZ0JBQWdCO1FBQUV6SixhQUFhQTtRQUFhRSxrQkFBa0JBO1FBQWtCQyxpQkFBaUJBO1FBQWlCQyxrQkFBa0JBO1FBQWtCOUYsbUJBQW1CQTtRQUFtQjJGLGNBQWNBO1FBQWMzSCxlQUFlQTtRQUFlNFEsa0JBQWtCQTtRQUFrQkMsaUJBQWlCQTtRQUFpQnZKLGVBQWVBO1FBQWVFLGtCQUFrQkE7UUFBa0JDLGdCQUFnQkE7UUFBZ0J4SCx1QkFBdUJBO1FBQXVCNlEsc0JBQXNCQTtRQUFzQnJPLHVCQUF1QkE7UUFBdUI5TSxvQkFBb0JBO1FBQW9Ca00sUUFBUUE7UUFBUUMsYUFBYUE7UUFBYUMsV0FBV0E7UUFBV0UsY0FBY0E7UUFBY0MsYUFBYUE7UUFBYUssbUJBQW1CQTtRQUFtQkosYUFBYUE7UUFBYUMsa0JBQWtCQTtRQUFrQkMsaUJBQWlCQTtRQUFpQmpCLFdBQVdBO1FBQVdvQixpQkFBaUJBO1FBQWlCM00saUJBQWlCQTtRQUFpQnJMLFNBQVNBO1FBQVNDLFNBQVNBO1FBQVM2bEIsd0JBQXdCQTtRQUF3QjVOLGtCQUFrQkE7UUFBa0JtSixpQkFBaUJBO1FBQWlCbEosa0JBQWtCQTtRQUFrQjFSLGdCQUFnQkE7UUFBZ0J3RyxxQkFBcUJBO0lBQW9CLGlCQUNuc0N2a0IsZ0RBQW1CLENBQUMrbkMsVUFBVSxvQkFDMUIvbkMsZ0RBQW1CLENBQUM2bkMsZ0JBQWdCO1FBQUUxRSxXQUFXcUg7UUFBa0J2SSxhQUFhQTtRQUFhZCxtQkFBbUJBO1FBQW1CSyxjQUFjQTtRQUFjdkMsMkJBQTJCQTtRQUEyQm1ELG1CQUFtQkE7UUFBbUJDLGtCQUFrQkE7UUFBa0JDLGlCQUFpQkE7UUFBaUJDLGtCQUFrQkE7UUFBa0JkLG1CQUFtQkE7UUFBbUI3bEIsaUJBQWlCQTtRQUFpQjJsQixtQkFBbUJBO1FBQW1CK0Ysb0JBQW9CQTtRQUFvQnZwQixnQkFBZ0JBO1FBQWdCK21CLHNCQUFzQixDQUFDLENBQUNBO1FBQXNCdmdCLHFCQUFxQkE7UUFBcUIxUSxNQUFNQTtJQUFLLGlCQUMxbkI3VCxnREFBbUIsQ0FBQzRwQyx1QkFBdUI7UUFBRS9sQyxPQUFPd2xDO1FBQXFCbm5DLE1BQU1rbkM7UUFBb0JTLFdBQVdRO1FBQXlCMWMsZ0JBQWdCMmM7SUFBNkIsbUJBQ3hMdHFDLGdEQUFtQixDQUFDLE9BQU87UUFBRTRELFdBQVc7SUFBaUMsa0JBQ3pFNUQsZ0RBQW1CLENBQUNtZ0MsZ0JBQWdCO1FBQUU5QixXQUFXa007UUFBa0IxSyxhQUFhQTtRQUFhSyxtQkFBbUJBO1FBQW1CSixrQkFBa0JBO1FBQWtCQyxpQkFBaUJBO1FBQWlCQyxrQkFBa0JBO1FBQWtCQyxtQkFBbUJBO1FBQW1CbkgsbUJBQW1CQTtRQUFtQm1HLDJCQUEyQkE7UUFBMkJsaEIsZ0JBQWdCQTtRQUFnQjRhLGlCQUFpQkE7UUFBaUJwVSxxQkFBcUJBO1FBQXFCNU8sWUFBWUE7UUFBWTJNLFlBQVlBO1FBQVl6TyxNQUFNQTtJQUFLO0FBQ2xpQjtBQUNBdTJCLFVBQVVwK0IsV0FBVyxHQUFHO0FBQ3hCLElBQUl5K0IsNEJBQWNycUMsMkNBQUlBLENBQUNncUM7QUFFdkIsTUFBTU0saUJBQWlCO0lBQ25CO1FBQUNDLE9BQU9DLGlCQUFpQjtRQUFFRCxPQUFPQyxpQkFBaUI7S0FBQztJQUNwRDtRQUFDRCxPQUFPRSxpQkFBaUI7UUFBRUYsT0FBT0UsaUJBQWlCO0tBQUM7Q0FDdkQ7QUFDRCxNQUFNQyxlQUFlO0lBQ2pCajNCLE1BQU07SUFDTnhPLE9BQU87SUFDUEMsUUFBUTtJQUNSSyxXQUFXO1FBQUM7UUFBRztRQUFHO0tBQUU7SUFDcEJ1USxlQUFlLElBQUltUjtJQUNuQjlhLE9BQU8sRUFBRTtJQUNUZ1csZUFBZTtJQUNmQyxlQUFlO0lBQ2YwRyxpQkFBaUI7SUFDakJqSyxpQkFBaUI7SUFDakI0SSxRQUFRO0lBQ1JDLGFBQWE7SUFDYjJHLGVBQWVuaUI7SUFDZmdMLFNBQVM7SUFDVEMsU0FBUztJQUNUb0wsaUJBQWlCK25CO0lBQ2pCcG9CLFlBQVlvb0I7SUFDWnhkLHNCQUFzQjtJQUN0QjFwQixxQkFBcUI7SUFDckI2dUIsbUJBQW1CO0lBQ25CdFYsa0JBQWtCO0lBQ2xCQyxvQkFBb0I7SUFDcEJDLHNCQUFzQjtJQUN0QlAsb0JBQW9CO1FBQUVoWSxHQUFHO1FBQUdDLEdBQUc7SUFBRTtJQUNqQzhXLGtCQUFrQjtJQUNsQnRCLGdCQUFnQnpNLGVBQWVxTixNQUFNO0lBQ3JDYyxTQUFTO0lBQ1RtVyxjQUFjO0lBQ2RqVSxnQkFBZ0I7SUFDaEJwSSxZQUFZO1FBQUM7UUFBRztLQUFFO0lBQ2xCNE4sbUJBQW1CO0lBQ25CYixVQUFVO1FBQUM7UUFBSTtLQUFHO0lBQ2xCck4sWUFBWTtJQUNaMk0sZ0JBQWdCO0lBQ2hCQyxrQkFBa0I7SUFDbEJDLGdCQUFnQjtJQUNoQkMsZ0JBQWdCO0lBQ2hCQyxnQkFBZ0I7SUFDaEJLLG9CQUFvQjtJQUNwQkosc0JBQXNCO0lBQ3RCMkYsZUFBZTtJQUNmRCxtQkFBbUI7SUFDbkJnakIsc0JBQXNCeitCO0lBQ3RCdVUsbUJBQW1CLEVBQUU7SUFDckJzTSxzQkFBc0I7SUFDdEJqUSx1QkFBdUI7SUFDdkJDLHFCQUFxQjtJQUNyQmdCLDRCQUE0QjtJQUM1QkwsZ0JBQWdCO0lBQ2hCc0csaUJBQWlCO0lBQ2pCdEksa0JBQWtCO0lBQ2xCd0gsbUJBQW1CO0lBQ25CN0ssa0JBQWtCO0lBQ2xCbUcsU0FBU3RWO0lBQ1RpUixtQkFBbUJqTztBQUN2QjtBQUVBLE1BQU0wK0IsZ0JBQWdCLElBQU1wcUMseUVBQW9CQSxDQUFDLENBQUNnbkIsS0FBS2YsTUFBUztZQUM1RCxHQUFHaWtCLFlBQVk7WUFDZjNwQixVQUFVLENBQUMvTjtnQkFDUCxNQUFNLEVBQUU4QyxhQUFhLEVBQUVQLFVBQVUsRUFBRTBNLG9CQUFvQixFQUFFLEdBQUd3RTtnQkFDNURlLElBQUk7b0JBQUUxUixlQUFlaVIsb0JBQW9CL1QsT0FBTzhDLGVBQWVQLFlBQVkwTTtnQkFBc0I7WUFDckc7WUFDQXBHLFVBQVU7Z0JBQ04sT0FBT2tKLE1BQU1tUixJQUFJLENBQUN6UCxNQUFNM1EsYUFBYSxDQUFDcWdCLE1BQU07WUFDaEQ7WUFDQXJYLFVBQVUsQ0FBQzNTO2dCQUNQLE1BQU0sRUFBRXdTLHFCQUFxQixDQUFDLENBQUMsRUFBRSxHQUFHOEg7Z0JBQ3BDZSxJQUFJO29CQUFFcmIsT0FBT0EsTUFBTWdILEdBQUcsQ0FBQyxDQUFDOUcsSUFBTzs0QkFBRSxHQUFHc1Msa0JBQWtCOzRCQUFFLEdBQUd0UyxDQUFDO3dCQUFDO2dCQUFJO1lBQ3JFO1lBQ0EyVSx5QkFBeUIsQ0FBQ2hPLE9BQU83RztnQkFDN0IsTUFBTTJjLGtCQUFrQixPQUFPOVYsVUFBVTtnQkFDekMsTUFBTTZMLGtCQUFrQixPQUFPMVMsVUFBVTtnQkFDekMsTUFBTTJKLGdCQUFnQmdULGtCQUNoQi9CLG9CQUFvQi9ULE9BQU8sSUFBSWlVLE9BQU9SLE1BQU1sUixVQUFVLEVBQUVrUixNQUFNeEUsb0JBQW9CLElBQ2xGLElBQUlnRjtnQkFDVixNQUFNK0QsWUFBWW5NLGtCQUFrQjFTLFFBQVEsRUFBRTtnQkFDOUNxYixJQUFJO29CQUFFMVI7b0JBQWUzSixPQUFPNmU7b0JBQVdsQztvQkFBaUJqSztnQkFBZ0I7WUFDNUU7WUFDQTRkLHNCQUFzQixDQUFDd0M7Z0JBQ25CLE1BQU0sRUFBRTljLGFBQWEsRUFBRXJNLGFBQWEsRUFBRThSLGFBQWEsRUFBRUQsaUJBQWlCLEVBQUVnakIsb0JBQW9CLEVBQUVsdkIsT0FBTyxFQUFFbEcsVUFBVSxFQUFHLEdBQUdrUjtnQkFDdkgsTUFBTW9rQixlQUFlcHZCLFNBQVNuQixjQUFjO2dCQUM1QyxJQUFJLENBQUN1d0IsY0FBYztvQkFDZjtnQkFDSjtnQkFDQSxNQUFNcG5DLFFBQVEyRCxPQUFPMGpDLGdCQUFnQixDQUFDRDtnQkFDdEMsTUFBTSxFQUFFRSxLQUFLcHFDLElBQUksRUFBRSxHQUFHLElBQUl5RyxPQUFPNGpDLGlCQUFpQixDQUFDdm5DLE1BQU04QixTQUFTO2dCQUNsRSxNQUFNd2xCLFVBQVVrVSxRQUFRenRCLE1BQU0sQ0FBQyxDQUFDQyxLQUFLdzVCO29CQUNqQyxNQUFNbGxDLE9BQU8rUCxjQUFjMlEsR0FBRyxDQUFDd2tCLE9BQU9ycEMsRUFBRTtvQkFDeEMsSUFBSW1FLE1BQU07d0JBQ04sTUFBTWt0QixhQUFhbnRCLGNBQWNtbEMsT0FBTy9ULFdBQVc7d0JBQ25ELE1BQU1nVSxXQUFXLENBQUMsQ0FBRWpZLENBQUFBLFdBQVdodUIsS0FBSyxJQUNoQ2d1QixXQUFXL3RCLE1BQU0sSUFDaEJhLENBQUFBLEtBQUtkLEtBQUssS0FBS2d1QixXQUFXaHVCLEtBQUssSUFBSWMsS0FBS2IsTUFBTSxLQUFLK3RCLFdBQVcvdEIsTUFBTSxJQUFJK2xDLE9BQU92TyxXQUFXO3dCQUMvRixJQUFJd08sVUFBVTs0QkFDVnAxQixjQUFjMFIsR0FBRyxDQUFDemhCLEtBQUtuRSxFQUFFLEVBQUU7Z0NBQ3ZCLEdBQUdtRSxJQUFJO2dDQUNQLENBQUMrQyxnQkFBZ0IsRUFBRTtvQ0FDZixHQUFHL0MsSUFBSSxDQUFDK0MsZ0JBQWdCO29DQUN4QmtQLGNBQWM7d0NBQ1Z2SixRQUFRd29CLGdCQUFnQixXQUFXZ1UsT0FBTy9ULFdBQVcsRUFBRXYyQixNQUFNNFU7d0NBQzdEcFIsUUFBUTh5QixnQkFBZ0IsV0FBV2dVLE9BQU8vVCxXQUFXLEVBQUV2MkIsTUFBTTRVO29DQUNqRTtnQ0FDSjtnQ0FDQSxHQUFHMGQsVUFBVTs0QkFDakI7NEJBQ0F4aEIsSUFBSXFGLElBQUksQ0FBQztnQ0FDTGxWLElBQUltRSxLQUFLbkUsRUFBRTtnQ0FDWEUsTUFBTTtnQ0FDTm14Qjs0QkFDSjt3QkFDSjtvQkFDSjtvQkFDQSxPQUFPeGhCO2dCQUNYLEdBQUcsRUFBRTtnQkFDTG1WLDRCQUE0QjlRLGVBQWVQO2dCQUMzQyxNQUFNNDFCLHdCQUF3QnhqQixxQkFDekJDLGlCQUFpQixDQUFDRCxxQkFBcUJuRixRQUFRaUUsS0FBSztvQkFBRXFCLFNBQVM7b0JBQU0sR0FBRzZpQixvQkFBb0I7Z0JBQUM7Z0JBQ2xHbmpCLElBQUk7b0JBQUUxUixlQUFlLElBQUltUixJQUFJblI7b0JBQWdCNlIsbUJBQW1Cd2pCO2dCQUFzQjtnQkFDdEYsSUFBSXBnQixTQUFTbFosU0FBUyxHQUFHO29CQUNyQnNRLGdCQUFnQjRJO2dCQUNwQjtZQUNKO1lBQ0FrTyxxQkFBcUIsQ0FBQ21TLGVBQWVDLGtCQUFrQixJQUFJLEVBQUV4MEIsV0FBVyxLQUFLO2dCQUN6RSxNQUFNLEVBQUV5MEIsa0JBQWtCLEVBQUUsR0FBRzdrQjtnQkFDL0IsTUFBTXNFLFVBQVVxZ0IsY0FBY2o0QixHQUFHLENBQUMsQ0FBQ3BOO29CQUMvQixNQUFNeWlCLFNBQVM7d0JBQ1g1bUIsSUFBSW1FLEtBQUtuRSxFQUFFO3dCQUNYRSxNQUFNO3dCQUNOK1U7b0JBQ0o7b0JBQ0EsSUFBSXcwQixpQkFBaUI7d0JBQ2pCN2lCLE9BQU8xZ0IsZ0JBQWdCLEdBQUcvQixLQUFLK0IsZ0JBQWdCO3dCQUMvQzBnQixPQUFPbGxCLFFBQVEsR0FBR3lDLEtBQUt6QyxRQUFRO29CQUNuQztvQkFDQSxPQUFPa2xCO2dCQUNYO2dCQUNBOGlCLG1CQUFtQnZnQjtZQUN2QjtZQUNBdWdCLG9CQUFvQixDQUFDdmdCO2dCQUNqQixNQUFNLEVBQUU1SSxhQUFhLEVBQUVyTSxhQUFhLEVBQUVnVCxlQUFlLEVBQUV2VCxVQUFVLEVBQUVzRyxRQUFRLEVBQUVvRyxvQkFBb0IsRUFBRSxHQUFHd0U7Z0JBQ3RHLElBQUlzRSxTQUFTbFosUUFBUTtvQkFDakIsSUFBSWlYLGlCQUFpQjt3QkFDakIsTUFBTTlWLFFBQVFvZ0IsaUJBQWlCckksU0FBU2xQO3dCQUN4QyxNQUFNbUwsb0JBQW9CRCxvQkFBb0IvVCxPQUFPOEMsZUFBZVAsWUFBWTBNO3dCQUNoRnVGLElBQUk7NEJBQUUxUixlQUFla1I7d0JBQWtCO29CQUMzQztvQkFDQTdFLGdCQUFnQjRJO2dCQUNwQjtZQUNKO1lBQ0EyTSxrQkFBa0IsQ0FBQ25DO2dCQUNmLE1BQU0sRUFBRXhJLG9CQUFvQixFQUFFNWdCLEtBQUssRUFBRTBQLFFBQVEsRUFBRSxHQUFHNEs7Z0JBQ2xELElBQUltQztnQkFDSixJQUFJQyxlQUFlO2dCQUNuQixJQUFJa0Usc0JBQXNCO29CQUN0Qm5FLGVBQWUyTSxnQkFBZ0JwaUIsR0FBRyxDQUFDLENBQUNQLFNBQVcwZ0Isc0JBQXNCMWdCLFFBQVE7Z0JBQ2pGLE9BQ0s7b0JBQ0RnVyxlQUFlMkssb0JBQW9CMVgsWUFBWTBaO29CQUMvQzFNLGVBQWUwSyxvQkFBb0JwbkIsT0FBTyxFQUFFO2dCQUNoRDtnQkFDQXdjLDhCQUE4QjtvQkFDMUJDO29CQUNBQztvQkFDQXBDO29CQUNBZTtnQkFDSjtZQUNKO1lBQ0FzYSxrQkFBa0IsQ0FBQ3hNO2dCQUNmLE1BQU0sRUFBRXZJLG9CQUFvQixFQUFFNWdCLEtBQUssRUFBRTBQLFFBQVEsRUFBRSxHQUFHNEs7Z0JBQ2xELElBQUlvQztnQkFDSixJQUFJRCxlQUFlO2dCQUNuQixJQUFJbUUsc0JBQXNCO29CQUN0QmxFLGVBQWV5TSxnQkFBZ0JuaUIsR0FBRyxDQUFDLENBQUNvNEIsU0FBV2pZLHNCQUFzQmlZLFFBQVE7Z0JBQ2pGLE9BQ0s7b0JBQ0QxaUIsZUFBZTBLLG9CQUFvQnBuQixPQUFPbXBCO29CQUMxQzFNLGVBQWUySyxvQkFBb0IxWCxZQUFZLEVBQUU7Z0JBQ3JEO2dCQUNBOE0sOEJBQThCO29CQUMxQkM7b0JBQ0FDO29CQUNBcEM7b0JBQ0FlO2dCQUNKO1lBQ0o7WUFDQW1RLHVCQUF1QixDQUFDLEVBQUUza0IsS0FBSyxFQUFFN0csS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUN6QyxNQUFNLEVBQUVBLE9BQU9xL0IsVUFBVSxFQUFFM3ZCLFFBQVEsRUFBRSxHQUFHNEs7Z0JBQ3hDLE1BQU1nbEIsa0JBQWtCejRCLFFBQVFBLFFBQVE2STtnQkFDeEMsTUFBTTZ2QixrQkFBa0J2L0IsUUFBUUEsUUFBUXEvQjtnQkFDeEMsTUFBTTVpQixlQUFlNmlCLGdCQUFnQnQ0QixHQUFHLENBQUMsQ0FBQ3hLO29CQUN0Q0EsRUFBRXlYLFFBQVEsR0FBRztvQkFDYixPQUFPa1Qsc0JBQXNCM3FCLEVBQUUvRyxFQUFFLEVBQUU7Z0JBQ3ZDO2dCQUNBLE1BQU1pbkIsZUFBZTZpQixnQkFBZ0J2NEIsR0FBRyxDQUFDLENBQUNsUixPQUFTcXhCLHNCQUFzQnJ4QixLQUFLTCxFQUFFLEVBQUU7Z0JBQ2xGK21CLDhCQUE4QjtvQkFDMUJDO29CQUNBQztvQkFDQXBDO29CQUNBZTtnQkFDSjtZQUNKO1lBQ0F2RyxZQUFZLENBQUMvSjtnQkFDVCxNQUFNLEVBQUV1USxNQUFNLEVBQUV0USxPQUFPLEVBQUUsR0FBR3NQO2dCQUM1QmdCLFFBQVF3SSxZQUFZO29CQUFDL1k7b0JBQVNDO2lCQUFRO2dCQUN0Q3FRLElBQUk7b0JBQUV0UTtnQkFBUTtZQUNsQjtZQUNBZ0ssWUFBWSxDQUFDL0o7Z0JBQ1QsTUFBTSxFQUFFc1EsTUFBTSxFQUFFdlEsT0FBTyxFQUFFLEdBQUd1UDtnQkFDNUJnQixRQUFRd0ksWUFBWTtvQkFBQy9ZO29CQUFTQztpQkFBUTtnQkFDdENxUSxJQUFJO29CQUFFclE7Z0JBQVE7WUFDbEI7WUFDQWdLLG9CQUFvQixDQUFDb0I7Z0JBQ2pCa0UsTUFBTWdCLE1BQU0sRUFBRWxGLGdCQUFnQkE7Z0JBQzlCaUYsSUFBSTtvQkFBRWpGO2dCQUFnQjtZQUMxQjtZQUNBc1MsdUJBQXVCO2dCQUNuQixNQUFNLEVBQUUxb0IsS0FBSyxFQUFFMFAsUUFBUSxFQUFFLEdBQUc0SztnQkFDNUIsTUFBTXpULFFBQVE2STtnQkFDZCxNQUFNNHZCLGtCQUFrQno0QixNQUNuQkUsTUFBTSxDQUFDLENBQUM3RyxJQUFNQSxFQUFFK1QsUUFBUSxFQUN4QmpOLEdBQUcsQ0FBQyxDQUFDeEssSUFBTTJxQixzQkFBc0IzcUIsRUFBRS9HLEVBQUUsRUFBRTtnQkFDNUMsTUFBTThwQyxrQkFBa0J2L0IsTUFDbkIrRyxNQUFNLENBQUMsQ0FBQzdHLElBQU1BLEVBQUUrVCxRQUFRLEVBQ3hCak4sR0FBRyxDQUFDLENBQUM5RyxJQUFNaW5CLHNCQUFzQmpuQixFQUFFekssRUFBRSxFQUFFO2dCQUM1QyttQiw4QkFBOEI7b0JBQzFCQyxjQUFjNmlCO29CQUNkNWlCLGNBQWM2aUI7b0JBQ2RqbEI7b0JBQ0FlO2dCQUNKO1lBQ0o7WUFDQXBHLGVBQWUsQ0FBQ2M7Z0JBQ1osTUFBTSxFQUFFcE0sYUFBYSxFQUFFLEdBQUcyUTtnQkFDMUIzUSxjQUFjTSxPQUFPLENBQUMsQ0FBQ3JRO29CQUNuQkEsS0FBSytCLGdCQUFnQixHQUFHdkIsY0FBY1IsS0FBS3pDLFFBQVEsRUFBRTRlO2dCQUN6RDtnQkFDQXNGLElBQUk7b0JBQ0F0RjtvQkFDQXBNLGVBQWUsSUFBSW1SLElBQUluUjtnQkFDM0I7WUFDSjtZQUNBOEYsT0FBTyxDQUFDeWE7Z0JBQ0osTUFBTSxFQUFFOXdCLFNBQVMsRUFBRU4sS0FBSyxFQUFFQyxNQUFNLEVBQUV1aUIsTUFBTSxFQUFFQyxXQUFXLEVBQUVuRixlQUFlLEVBQUUsR0FBR2tFO2dCQUMzRSxJQUFJLENBQUNnQixVQUFVLENBQUNDLGVBQWdCLENBQUMyTyxNQUFNL3hCLENBQUMsSUFBSSxDQUFDK3hCLE1BQU05eEIsQ0FBQyxFQUFHO29CQUNuRCxPQUFPO2dCQUNYO2dCQUNBLE1BQU00akIsZ0JBQWdCem5CLGlEQUFZQSxDQUM3QjBuQixTQUFTLENBQUM3aUIsU0FBUyxDQUFDLEVBQUUsR0FBRzh3QixNQUFNL3hCLENBQUMsRUFBRWlCLFNBQVMsQ0FBQyxFQUFFLEdBQUc4d0IsTUFBTTl4QixDQUFDLEVBQ3hEOGpCLEtBQUssQ0FBQzlpQixTQUFTLENBQUMsRUFBRTtnQkFDdkIsTUFBTWlCLFNBQVM7b0JBQ1g7d0JBQUM7d0JBQUc7cUJBQUU7b0JBQ047d0JBQUN2Qjt3QkFBT0M7cUJBQU87aUJBQ2xCO2dCQUNELE1BQU1rckIsdUJBQXVCM0ksUUFBUTRJLFlBQVlsSSxlQUFlM2hCLFFBQVErYjtnQkFDeEVrRixPQUFPbGlCLFNBQVMsQ0FBQ21pQixhQUFhMEk7Z0JBQzlCLE1BQU11YixtQkFBbUJwbUMsU0FBUyxDQUFDLEVBQUUsS0FBSzZxQixxQkFBcUI5ckIsQ0FBQyxJQUM1RGlCLFNBQVMsQ0FBQyxFQUFFLEtBQUs2cUIscUJBQXFCN3JCLENBQUMsSUFDdkNnQixTQUFTLENBQUMsRUFBRSxLQUFLNnFCLHFCQUFxQmhLLENBQUM7Z0JBQzNDLE9BQU91bEI7WUFDWDtZQUNBN3ZCLGtCQUFrQixJQUFNMEwsSUFBSTtvQkFDeEI3SyxrQkFBa0IrdEIsYUFBYS90QixnQkFBZ0I7b0JBQy9DQyxvQkFBb0I4dEIsYUFBYTl0QixrQkFBa0I7b0JBQ25EQyxzQkFBc0I2dEIsYUFBYTd0QixvQkFBb0I7b0JBQ3ZEeEIsa0JBQWtCcXZCLGFBQWFydkIsZ0JBQWdCO29CQUMvQ3lCLHVCQUF1QjR0QixhQUFhNXRCLHFCQUFxQjtvQkFDekRDLHFCQUFxQjJ0QixhQUFhM3RCLG1CQUFtQjtnQkFDekQ7WUFDQXNFLE9BQU8sSUFBTW1HLElBQUk7b0JBQUUsR0FBR2tqQixZQUFZO2dCQUFDO1FBQ3ZDLElBQUkvMkIsT0FBT2k0QixFQUFFO0FBRWIsTUFBTUMsb0JBQW9CLENBQUMsRUFBRXRvQyxRQUFRLEVBQUU7SUFDbkMsTUFBTXVvQyxXQUFXN3JDLDZDQUFNQSxDQUFDO0lBQ3hCLElBQUksQ0FBQzZyQyxTQUFTMW1DLE9BQU8sRUFBRTtRQUNuQjBtQyxTQUFTMW1DLE9BQU8sR0FBR3dsQztJQUN2QjtJQUNBLHFCQUFPaHJDLGdEQUFtQixDQUFDcUIsWUFBWTtRQUFFeUYsT0FBT29sQyxTQUFTMW1DLE9BQU87SUFBQyxHQUFHN0I7QUFDeEU7QUFDQXNvQyxrQkFBa0JqZ0MsV0FBVyxHQUFHO0FBRWhDLE1BQU1tZ0MsVUFBVSxDQUFDLEVBQUV4b0MsUUFBUSxFQUFFO0lBQ3pCLE1BQU15b0MsWUFBWWxzQyxpREFBVUEsQ0FBQ2tCO0lBQzdCLElBQUlnckMsV0FBVztRQUNYLDZGQUE2RjtRQUM3RixrRUFBa0U7UUFDbEUscUJBQU9wc0MsZ0RBQW1CLENBQUNBLDJDQUFjLEVBQUUsTUFBTTJEO0lBQ3JEO0lBQ0EscUJBQU8zRCxnREFBbUIsQ0FBQ2lzQyxtQkFBbUIsTUFBTXRvQztBQUN4RDtBQUNBd29DLFFBQVFuZ0MsV0FBVyxHQUFHO0FBRXRCLE1BQU1xZ0MsbUJBQW1CO0lBQ3JCOU4sT0FBT3JlO0lBQ1BzZSxTQUFTeGU7SUFDVHllLFFBQVFyZTtJQUNSc2UsT0FBT3JlO0FBQ1g7QUFDQSxNQUFNaXNCLG1CQUFtQjtJQUNyQjlOLFNBQVM1ckI7SUFDVHd3QixVQUFVN3dCO0lBQ1Yrd0IsTUFBTWx4QjtJQUNObXhCLFlBQVlyeEI7SUFDWnN4QixjQUFjOTBCO0FBQ2xCO0FBQ0EsTUFBTTY5QixpQkFBaUI7SUFBQztJQUFHO0NBQUU7QUFDN0IsTUFBTUMsZUFBZTtJQUFDO0lBQUk7Q0FBRztBQUM3QixNQUFNQyxzQkFBc0I7SUFBRS9uQyxHQUFHO0lBQUdDLEdBQUc7SUFBRzVELE1BQU07QUFBRTtBQUNsRCxNQUFNMnJDLGVBQWU7SUFDakJybkMsT0FBTztJQUNQQyxRQUFRO0lBQ1J1ZSxVQUFVO0lBQ1ZuZ0IsVUFBVTtJQUNWNmpCLFFBQVE7QUFDWjtBQUNBLE1BQU1vbEIsMEJBQVluc0MsaURBQVVBLENBQUMsQ0FBQyxFQUFFNFMsS0FBSyxFQUFFN0csS0FBSyxFQUFFdVYsWUFBWSxFQUFFQyxZQUFZLEVBQUVuZSxTQUFTLEVBQUV5NkIsWUFBWWdPLGdCQUFnQixFQUFFbEosWUFBWW1KLGdCQUFnQixFQUFFek0sV0FBVyxFQUFFb0MsV0FBVyxFQUFFZ0csTUFBTSxFQUFFdFosTUFBTSxFQUFFQyxXQUFXLEVBQUVDLFNBQVMsRUFBRWxULFNBQVMsRUFBRUksY0FBYyxFQUFFeUIsWUFBWSxFQUFFOEIsbUJBQW1CLEVBQUVDLGlCQUFpQixFQUFFdWdCLGdCQUFnQixFQUFFQyxlQUFlLEVBQUVDLGdCQUFnQixFQUFFQyxpQkFBaUIsRUFBRUMsaUJBQWlCLEVBQUVqZCxlQUFlLEVBQUVELFVBQVUsRUFBRUUsY0FBYyxFQUFFSixhQUFhLEVBQUVDLGFBQWEsRUFBRWxDLGlCQUFpQixFQUFFdUMsb0JBQW9CLEVBQUVELGVBQWUsRUFBRUUsbUJBQW1CLEVBQUUrWixzQkFBc0IsRUFBRTlJLGdCQUFnQixFQUFFQyxjQUFjLEVBQUVwYSxpQkFBaUJ6TSxlQUFlcU4sTUFBTSxFQUFFcXVCLHFCQUFxQnY3QixtQkFBbUJ5NkIsTUFBTSxFQUFFZSxtQkFBbUIsRUFBRWdCLHVCQUF1QixFQUFFQyw0QkFBNEIsRUFBRXhkLGdCQUFnQixXQUFXLEVBQUU0USxtQkFBbUIsT0FBTyxFQUFFQyxrQkFBa0IsS0FBSyxFQUFFdkosZ0JBQWdCeG1CLGNBQWN5bUIsSUFBSSxFQUFFdUosdUJBQXVCLE9BQU8sRUFBRTdRLHdCQUF3Qi9oQixZQUFZLFNBQVMsU0FBUyxFQUFFdWtCLHdCQUF3QnZrQixZQUFZLFNBQVMsU0FBUyxFQUFFcUssYUFBYSxLQUFLLEVBQUVxTixXQUFXOHBCLFlBQVksRUFBRXZOLDRCQUE0QixLQUFLLEVBQUVuRyxvQkFBb0IsSUFBSSxFQUFFOVcsY0FBYyxFQUFFQyxnQkFBZ0IsRUFBRUMsY0FBYyxFQUFFdk0sYUFBYTQyQixjQUFjLEVBQUVwcUIsY0FBYyxFQUFFQyxjQUFjLEVBQUVLLGtCQUFrQixFQUFFNk0sa0JBQWtCbWQsbUJBQW1CLEVBQUVuMUIsVUFBVSxHQUFHLEVBQUVDLFVBQVUsQ0FBQyxFQUFFb0wsa0JBQWtCK25CLGNBQWMsRUFBRWxiLG1CQUFtQixJQUFJLEVBQUVsTixVQUFVLEVBQUVnbEIscUJBQXFCLFNBQVMsRUFBRXZZLGVBQWUsSUFBSSxFQUFFQyxjQUFjLElBQUksRUFBRUMsY0FBYyxLQUFLLEVBQUVDLG1CQUFtQixHQUFHLEVBQUVDLGtCQUFrQnhoQixnQkFBZ0J5aEIsSUFBSSxFQUFFQyxvQkFBb0IsSUFBSSxFQUFFbkIsWUFBWSxJQUFJLEVBQUVzRyxXQUFXLEVBQUVFLGdCQUFnQixFQUFFQyxlQUFlLEVBQUVDLGdCQUFnQixFQUFFSCxZQUFZLEVBQUUzRixpQkFBaUIsRUFBRW5yQixRQUFRLEVBQUU2OUIsWUFBWSxFQUFFWSxpQkFBaUIsRUFBRWpCLGlCQUFpQixFQUFFa0IsZ0JBQWdCLEVBQUVDLGVBQWUsRUFBRUMsZ0JBQWdCLEVBQUVkLGlCQUFpQixFQUFFN2xCLGVBQWUsRUFBRTJsQixvQkFBb0IsRUFBRSxFQUFFaGYsYUFBYSxFQUFFQyxhQUFhLEVBQUVtVyxrQkFBa0IsUUFBUSxFQUFFbEosbUJBQW1CLFNBQVMsRUFBRTFSLGlCQUFpQixPQUFPLEVBQUU2RSxVQUFVLEtBQUssRUFBRUMsY0FBYyxFQUFFL0UsaUJBQWlCLElBQUksRUFBRTh1QixtQkFBbUIsRUFBRXhvQyxVQUFVLEVBQUUyYSxrQkFBa0IsRUFBRXNELHVCQUF1QixJQUFJLEVBQUV5aUIsdUJBQXVCLEtBQUssRUFBRXZnQixzQkFBc0IsS0FBSyxFQUFFekksbUJBQW1CLElBQUksRUFBRXdILG9CQUFvQixJQUFJLEVBQUU3SyxtQkFBbUIsRUFBRSxFQUFFOEIsaUJBQWlCLEVBQUVxRSxPQUFPLEVBQUUvYSxLQUFLLEVBQUU3QixFQUFFLEVBQUV1aEIsaUJBQWlCLEVBQUUsR0FBR3pmLE1BQU0sRUFBRWtDO0lBQ2x4RSxNQUFNNk4sT0FBTzdSLE1BQU07SUFDbkIscUJBQVFoQyxnREFBbUIsQ0FBQyxPQUFPO1FBQUUsR0FBRzhELElBQUk7UUFBRUQsT0FBTztZQUFFLEdBQUdBLEtBQUs7WUFBRSxHQUFHNm9DLFlBQVk7UUFBQztRQUFHMW1DLEtBQUtBO1FBQUtwQyxXQUFXbEQsb0RBQUVBLENBQUM7WUFBQztZQUFja0Q7U0FBVTtRQUFHLGVBQWU7UUFBZTVCLElBQUlBO0lBQUcsaUJBQ3pLaEMsZ0RBQW1CLENBQUNtc0MsU0FBUyxvQkFDekJuc0MsZ0RBQW1CLENBQUN5cUMsYUFBYTtRQUFFeEMsUUFBUUE7UUFBUXRaLFFBQVFBO1FBQVFDLGFBQWFBO1FBQWFDLFdBQVdBO1FBQVdnUixhQUFhQTtRQUFhb0MsYUFBYUE7UUFBYW5DLGtCQUFrQkE7UUFBa0JDLGlCQUFpQkE7UUFBaUJDLGtCQUFrQkE7UUFBa0JDLG1CQUFtQkE7UUFBbUJDLG1CQUFtQkE7UUFBbUI3QixXQUFXQTtRQUFXOEUsV0FBV0E7UUFBV2lHLG9CQUFvQkE7UUFBb0JDLHFCQUFxQkE7UUFBcUJnQix5QkFBeUJBO1FBQXlCQyw4QkFBOEJBO1FBQThCNU0sa0JBQWtCQTtRQUFrQkMsaUJBQWlCQTtRQUFpQnZKLGVBQWVBO1FBQWV0SCxlQUFlQTtRQUFlQyx1QkFBdUJBO1FBQXVCNlEsc0JBQXNCQTtRQUFzQnJPLHVCQUF1QkE7UUFBdUIwUCwyQkFBMkJBO1FBQTJCbkcsbUJBQW1CQTtRQUFtQnhKLGlCQUFpQkE7UUFBaUIzTSxpQkFBaUJBO1FBQWlCckwsU0FBU0E7UUFBU0MsU0FBU0E7UUFBU2lZLGtCQUFrQkE7UUFBa0JULGNBQWNBO1FBQWNDLGFBQWFBO1FBQWFLLG1CQUFtQkE7UUFBbUJKLGFBQWFBO1FBQWFDLGtCQUFrQkE7UUFBa0JDLGlCQUFpQkE7UUFBaUJqQixXQUFXQTtRQUFXc0csYUFBYUE7UUFBYUUsa0JBQWtCQTtRQUFrQkMsaUJBQWlCQTtRQUFpQkMsa0JBQWtCQTtRQUFrQkgsY0FBY0E7UUFBYzNGLG1CQUFtQkE7UUFBbUJzTyx3QkFBd0JBO1FBQXdCOUksa0JBQWtCQTtRQUFrQkMsZ0JBQWdCQTtRQUFnQmlOLGNBQWNBO1FBQWNZLG1CQUFtQkE7UUFBbUJqQixtQkFBbUJBO1FBQW1Ca0Isa0JBQWtCQTtRQUFrQkMsaUJBQWlCQTtRQUFpQkMsa0JBQWtCQTtRQUFrQmQsbUJBQW1CQTtRQUFtQjdsQixpQkFBaUJBO1FBQWlCMmxCLG1CQUFtQkE7UUFBbUIrRixvQkFBb0JBO1FBQW9CM08saUJBQWlCQTtRQUFpQmxKLGtCQUFrQkE7UUFBa0IxUixnQkFBZ0JBO1FBQWdCK21CLHNCQUFzQkE7UUFBc0JqeEIsTUFBTUE7UUFBTTBRLHFCQUFxQkE7UUFBcUI1TyxZQUFZQTtRQUFZMk0sWUFBWUE7SUFBVyxrQkFDdHFFdGlCLGdEQUFtQixDQUFDNmhCLGNBQWM7UUFBRXpPLE9BQU9BO1FBQU83RyxPQUFPQTtRQUFPdVYsY0FBY0E7UUFBY0MsY0FBY0E7UUFBY3BHLFdBQVdBO1FBQVdJLGdCQUFnQkE7UUFBZ0J5QixjQUFjQTtRQUFjOEIscUJBQXFCQTtRQUFxQkMsbUJBQW1CQTtRQUFtQnlDLGdCQUFnQkE7UUFBZ0JDLGtCQUFrQkE7UUFBa0JDLGdCQUFnQkE7UUFBZ0JDLGdCQUFnQkE7UUFBZ0JDLGdCQUFnQkE7UUFBZ0JLLG9CQUFvQkE7UUFBb0JKLHNCQUFzQkE7UUFBc0IvSyxTQUFTQTtRQUFTQyxTQUFTQTtRQUFTK0ssWUFBWUE7UUFBWUMsZUFBZUE7UUFBZUMsZUFBZUE7UUFBZW5OLFlBQVlBO1FBQVlxTixVQUFVQTtRQUFVdkksZ0JBQWdCQTtRQUFnQndJLGlCQUFpQkE7UUFBaUI3RSxnQkFBZ0JBO1FBQWdCaUIsb0JBQW9CQTtRQUFvQjZELFNBQVNBO1FBQVNDLGdCQUFnQkE7UUFBZ0JDLGVBQWVBO1FBQWVDLGVBQWVBO1FBQWVFLGlCQUFpQkE7UUFBaUJELFlBQVlBO1FBQVlFLGdCQUFnQkE7UUFBZ0JDLGlCQUFpQkE7UUFBaUJDLHNCQUFzQkE7UUFBc0JDLHFCQUFxQkE7UUFBcUJ0RixnQkFBZ0JBO1FBQWdCcEksWUFBWUE7UUFBWTlCLE1BQU1BO1FBQU1pSSxrQkFBa0JBO1FBQWtCd0gsbUJBQW1CQTtRQUFtQjFFLFNBQVNBO1FBQVNuRyxrQkFBa0JBO1FBQWtCOEIsbUJBQW1CQTtRQUFtQmdKLG1CQUFtQkE7SUFBa0Isa0JBQy80Q3ZqQixnREFBbUIsQ0FBQ2doQixXQUFXO1FBQUVILG1CQUFtQkE7SUFBa0IsSUFDdEVsZCx3QkFDQTNELGdEQUFtQixDQUFDbUUsYUFBYTtRQUFFQyxZQUFZQTtRQUFZVixVQUFVa3BDO0lBQW9CLGtCQUN6RjVzQyxnREFBbUIsQ0FBQ3NrQixrQkFBa0I7UUFBRXpRLE1BQU1BO1FBQU0wUSxxQkFBcUJBO0lBQW9CO0FBQ3pHO0FBQ0Fvb0IsVUFBVTNnQyxXQUFXLEdBQUc7QUFFeEIsTUFBTTZnQyxhQUFhLENBQUN0cEMsSUFBTUEsRUFBRXNZLE9BQU8sRUFBRW5CLGNBQWM7QUFDbkQsU0FBU295QixrQkFBa0IsRUFBRW5wQyxRQUFRLEVBQUU7SUFDbkMsTUFBTW9wQyxvQkFBb0JucUMsU0FBU2lxQztJQUNuQyxJQUFJLENBQUNFLG1CQUFtQjtRQUNwQixPQUFPO0lBQ1g7SUFDQSxxQkFBTzVyQyx1REFBWUEsQ0FBQ3dDLFVBQVVvcEM7QUFDbEM7QUFFQSxTQUFTQztJQUNMLE1BQU1qcUMsUUFBUUU7SUFDZCxPQUFPeEMsa0RBQVdBLENBQUMsQ0FBQ3VCO1FBQ2hCLE1BQU0sRUFBRTZaLE9BQU8sRUFBRWdoQixvQkFBb0IsRUFBRSxHQUFHOTVCLE1BQU1HLFFBQVE7UUFDeEQsTUFBTStwQyxZQUFZOW5CLE1BQU1DLE9BQU8sQ0FBQ3BqQixNQUFNQSxLQUFLO1lBQUNBO1NBQUc7UUFDL0MsTUFBTXE5QixVQUFVNE4sVUFBVXI3QixNQUFNLENBQUMsQ0FBQ0MsS0FBS3E3QjtZQUNuQyxNQUFNNVYsY0FBY3piLFNBQVNuQixjQUFjLENBQUMsMkJBQTJCLEVBQUV3eUIsU0FBUyxFQUFFLENBQUM7WUFDckYsSUFBSTVWLGFBQWE7Z0JBQ2J6bEIsSUFBSXFGLElBQUksQ0FBQztvQkFBRWxWLElBQUlrckM7b0JBQVU1VjtvQkFBYXdGLGFBQWE7Z0JBQUs7WUFDNUQ7WUFDQSxPQUFPanJCO1FBQ1gsR0FBRyxFQUFFO1FBQ0xpTCxzQkFBc0IsSUFBTStmLHFCQUFxQndDO0lBQ3JELEdBQUcsRUFBRTtBQUNUO0FBRUEsTUFBTThOLGdCQUFnQixDQUFDbHZCLFFBQVVBLE1BQU1oQyxRQUFRO0FBQy9DLFNBQVNteEI7SUFDTCxNQUFNaDZCLFFBQVF4USxTQUFTdXFDLGVBQWV0c0Msb0RBQU9BO0lBQzdDLE9BQU91UztBQUNYO0FBRUEsTUFBTWk2QixnQkFBZ0IsQ0FBQ3B2QixRQUFVQSxNQUFNMVIsS0FBSztBQUM1QyxTQUFTK2dDO0lBQ0wsTUFBTS9nQyxRQUFRM0osU0FBU3lxQyxlQUFleHNDLG9EQUFPQTtJQUM3QyxPQUFPMEw7QUFDWDtBQUVBLE1BQU1naEMsbUJBQW1CLENBQUN0dkIsUUFBVztRQUNqQ3ZaLEdBQUd1WixNQUFNdFksU0FBUyxDQUFDLEVBQUU7UUFDckJoQixHQUFHc1osTUFBTXRZLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCNUUsTUFBTWtkLE1BQU10WSxTQUFTLENBQUMsRUFBRTtJQUM1QjtBQUNBLFNBQVM2bkM7SUFDTCxNQUFNL2hCLFdBQVc3b0IsU0FBUzJxQyxrQkFBa0Ixc0Msb0RBQU9BO0lBQ25ELE9BQU80cUI7QUFDWDtBQUVBLHFEQUFxRCxHQUNyRCxTQUFTZ2lCLG9CQUFvQjFhLFlBQVk7SUFDckMsT0FBTyxDQUFDMmE7UUFDSixNQUFNLENBQUM5WixPQUFPK1osU0FBUyxHQUFHcnRDLCtDQUFRQSxDQUFDb3RDO1FBQ25DLE1BQU1FLGdCQUFnQm50QyxrREFBV0EsQ0FBQyxDQUFDMHFCLFVBQVl3aUIsU0FBUyxDQUFDL1osUUFBVWIsYUFBYTVILFNBQVN5SSxTQUFTLEVBQUU7UUFDcEcsT0FBTztZQUFDQTtZQUFPK1o7WUFBVUM7U0FBYztJQUMzQztBQUNKO0FBQ0EsTUFBTUMsZ0JBQWdCSixvQkFBb0JqYTtBQUMxQyxNQUFNc2EsZ0JBQWdCTCxvQkFBb0JoYTtBQUUxQyxTQUFTc2Esb0JBQW9CLEVBQUVsVSxPQUFPLEVBQUVtVSxRQUFRLEVBQUVDLEtBQUssRUFBRTtJQUNyRCxNQUFNbHJDLFFBQVFFO0lBQ2QxQyxnREFBU0EsQ0FBQztRQUNOd0MsTUFBTUksUUFBUSxDQUFDO1lBQUVxdUIsdUJBQXVCcUk7UUFBUTtJQUNwRCxHQUFHO1FBQUNBO0tBQVE7SUFDWnQ1QixnREFBU0EsQ0FBQztRQUNOd0MsTUFBTUksUUFBUSxDQUFDO1lBQUVzdUIsa0JBQWtCdWM7UUFBUztJQUNoRCxHQUFHO1FBQUNBO0tBQVM7SUFDYnp0QyxnREFBU0EsQ0FBQztRQUNOd0MsTUFBTUksUUFBUSxDQUFDO1lBQUV1dUIscUJBQXFCdWM7UUFBTTtJQUNoRCxHQUFHO1FBQUNBO0tBQU07QUFDZDtBQUVBLFNBQVNDLHFCQUFxQixFQUFFRixRQUFRLEVBQUU7SUFDdEMsTUFBTWpyQyxRQUFRRTtJQUNkMUMsZ0RBQVNBLENBQUM7UUFDTixNQUFNNHRDLDhCQUE4QjtlQUFJcHJDLE1BQU1HLFFBQVEsR0FBRzJkLGlCQUFpQjtZQUFFbXRCO1NBQVM7UUFDckZqckMsTUFBTUksUUFBUSxDQUFDO1lBQUUwZCxtQkFBbUJzdEI7UUFBNEI7UUFDaEUsT0FBTztZQUNILE1BQU1DLGVBQWVyckMsTUFBTUcsUUFBUSxHQUFHMmQsaUJBQWlCLENBQUN2TixNQUFNLENBQUMsQ0FBQ3dOLEtBQU9BLE9BQU9rdEI7WUFDOUVqckMsTUFBTUksUUFBUSxDQUFDO2dCQUFFMGQsbUJBQW1CdXRCO1lBQWE7UUFDckQ7SUFDSixHQUFHO1FBQUNKO0tBQVM7QUFDakI7QUFFQSxNQUFNbnJDLFdBQVcsQ0FBQ2dTLFVBQVksQ0FBQ3RSO1FBQzNCLElBQUlBLEVBQUUyUyxhQUFhLENBQUM1RSxJQUFJLEtBQUssR0FBRztZQUM1QixPQUFPO1FBQ1g7UUFDQSxPQUFPL04sRUFDRjBZLFFBQVEsR0FDUjNJLE1BQU0sQ0FBQyxDQUFDdkssSUFBTzhMLFFBQVF1VCxrQkFBa0IsR0FBRyxPQUFPLENBQUNyZixFQUFFMk4sTUFBTSxFQUM1RDZQLEtBQUssQ0FBQyxDQUFDeGQsSUFBTUEsQ0FBQyxDQUFDRyxnQkFBZ0IsRUFBRWtQLGlCQUFpQjlMO0lBQzNEO0FBQ0EsTUFBTStoQyxpQkFBaUI7SUFDbkJqbUIsb0JBQW9CO0FBQ3hCO0FBQ0EsU0FBU2ttQixvQkFBb0J6NUIsVUFBVXc1QixjQUFjO0lBQ2pELE1BQU03UyxjQUFjNTRCLFNBQVNDLFNBQVNnUztJQUN0QyxPQUFPMm1CO0FBQ1g7QUFFMjRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWluZC1tYXAvLi9ub2RlX21vZHVsZXMvQHJlYWN0Zmxvdy9jb3JlL2Rpc3QvZXNtL2luZGV4Lm1qcz8xNDEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCBtZW1vLCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIGZvcndhcmRSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNjIGZyb20gJ2NsYXNzY2F0JztcbmltcG9ydCB7IHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4sIGNyZWF0ZVdpdGhFcXVhbGl0eUZuIH0gZnJvbSAnenVzdGFuZC90cmFkaXRpb25hbCc7XG5pbXBvcnQgeyBzaGFsbG93IH0gZnJvbSAnenVzdGFuZC9zaGFsbG93JztcbmltcG9ydCB7IHpvb21JZGVudGl0eSwgem9vbSB9IGZyb20gJ2QzLXpvb20nO1xuaW1wb3J0IHsgc2VsZWN0LCBwb2ludGVyIH0gZnJvbSAnZDMtc2VsZWN0aW9uJztcbmltcG9ydCB7IGRyYWcgfSBmcm9tICdkMy1kcmFnJztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbmNvbnN0IFN0b3JlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBQcm92aWRlciQxID0gU3RvcmVDb250ZXh0LlByb3ZpZGVyO1xuXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xuICAgIGVycm9yMDAxOiAoKSA9PiAnW1JlYWN0IEZsb3ddOiBTZWVtcyBsaWtlIHlvdSBoYXZlIG5vdCB1c2VkIHp1c3RhbmQgcHJvdmlkZXIgYXMgYW4gYW5jZXN0b3IuIEhlbHA6IGh0dHBzOi8vcmVhY3RmbG93LmRldi9lcnJvciMwMDEnLFxuICAgIGVycm9yMDAyOiAoKSA9PiBcIkl0IGxvb2tzIGxpa2UgeW91J3ZlIGNyZWF0ZWQgYSBuZXcgbm9kZVR5cGVzIG9yIGVkZ2VUeXBlcyBvYmplY3QuIElmIHRoaXMgd2Fzbid0IG9uIHB1cnBvc2UgcGxlYXNlIGRlZmluZSB0aGUgbm9kZVR5cGVzL2VkZ2VUeXBlcyBvdXRzaWRlIG9mIHRoZSBjb21wb25lbnQgb3IgbWVtb2l6ZSB0aGVtLlwiLFxuICAgIGVycm9yMDAzOiAobm9kZVR5cGUpID0+IGBOb2RlIHR5cGUgXCIke25vZGVUeXBlfVwiIG5vdCBmb3VuZC4gVXNpbmcgZmFsbGJhY2sgdHlwZSBcImRlZmF1bHRcIi5gLFxuICAgIGVycm9yMDA0OiAoKSA9PiAnVGhlIFJlYWN0IEZsb3cgcGFyZW50IGNvbnRhaW5lciBuZWVkcyBhIHdpZHRoIGFuZCBhIGhlaWdodCB0byByZW5kZXIgdGhlIGdyYXBoLicsXG4gICAgZXJyb3IwMDU6ICgpID0+ICdPbmx5IGNoaWxkIG5vZGVzIGNhbiB1c2UgYSBwYXJlbnQgZXh0ZW50LicsXG4gICAgZXJyb3IwMDY6ICgpID0+IFwiQ2FuJ3QgY3JlYXRlIGVkZ2UuIEFuIGVkZ2UgbmVlZHMgYSBzb3VyY2UgYW5kIGEgdGFyZ2V0LlwiLFxuICAgIGVycm9yMDA3OiAoaWQpID0+IGBUaGUgb2xkIGVkZ2Ugd2l0aCBpZD0ke2lkfSBkb2VzIG5vdCBleGlzdC5gLFxuICAgIGVycm9yMDA5OiAodHlwZSkgPT4gYE1hcmtlciB0eXBlIFwiJHt0eXBlfVwiIGRvZXNuJ3QgZXhpc3QuYCxcbiAgICBlcnJvcjAwODogKHNvdXJjZUhhbmRsZSwgZWRnZSkgPT4gYENvdWxkbid0IGNyZWF0ZSBlZGdlIGZvciAkeyFzb3VyY2VIYW5kbGUgPyAnc291cmNlJyA6ICd0YXJnZXQnfSBoYW5kbGUgaWQ6IFwiJHshc291cmNlSGFuZGxlID8gZWRnZS5zb3VyY2VIYW5kbGUgOiBlZGdlLnRhcmdldEhhbmRsZX1cIiwgZWRnZSBpZDogJHtlZGdlLmlkfS5gLFxuICAgIGVycm9yMDEwOiAoKSA9PiAnSGFuZGxlOiBObyBub2RlIGlkIGZvdW5kLiBNYWtlIHN1cmUgdG8gb25seSB1c2UgYSBIYW5kbGUgaW5zaWRlIGEgY3VzdG9tIE5vZGUuJyxcbiAgICBlcnJvcjAxMTogKGVkZ2VUeXBlKSA9PiBgRWRnZSB0eXBlIFwiJHtlZGdlVHlwZX1cIiBub3QgZm91bmQuIFVzaW5nIGZhbGxiYWNrIHR5cGUgXCJkZWZhdWx0XCIuYCxcbiAgICBlcnJvcjAxMjogKGlkKSA9PiBgTm9kZSB3aXRoIGlkIFwiJHtpZH1cIiBkb2VzIG5vdCBleGlzdCwgaXQgbWF5IGhhdmUgYmVlbiByZW1vdmVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIG5vZGUgaXMgZGVsZXRlZCBiZWZvcmUgdGhlIFwib25Ob2RlQ2xpY2tcIiBoYW5kbGVyIGlzIGNhbGxlZC5gLFxufTtcblxuY29uc3QgenVzdGFuZEVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAxJ10oKTtcbmZ1bmN0aW9uIHVzZVN0b3JlKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKHN0b3JlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih6dXN0YW5kRXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4oc3RvcmUsIHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbn1cbmNvbnN0IHVzZVN0b3JlQXBpID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICAgIGlmIChzdG9yZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoenVzdGFuZEVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgc2V0U3RhdGU6IHN0b3JlLnNldFN0YXRlLFxuICAgICAgICBzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZSxcbiAgICAgICAgZGVzdHJveTogc3RvcmUuZGVzdHJveSxcbiAgICB9KSwgW3N0b3JlXSk7XG59O1xuXG5jb25zdCBzZWxlY3RvciRnID0gKHMpID0+IChzLnVzZXJTZWxlY3Rpb25BY3RpdmUgPyAnbm9uZScgOiAnYWxsJyk7XG5mdW5jdGlvbiBQYW5lbCh7IHBvc2l0aW9uLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgcG9pbnRlckV2ZW50cyA9IHVzZVN0b3JlKHNlbGVjdG9yJGcpO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2xhc3NlcyA9IGAke3Bvc2l0aW9ufWAuc3BsaXQoJy0nKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcGFuZWwnLCBjbGFzc05hbWUsIC4uLnBvc2l0aW9uQ2xhc3Nlc10pLCBzdHlsZTogeyAuLi5zdHlsZSwgcG9pbnRlckV2ZW50cyB9LCAuLi5yZXN0IH0sIGNoaWxkcmVuKSk7XG59XG5cbmZ1bmN0aW9uIEF0dHJpYnV0aW9uKHsgcHJvT3B0aW9ucywgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0JyB9KSB7XG4gICAgaWYgKHByb09wdGlvbnM/LmhpZGVBdHRyaWJ1dGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFBhbmVsLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2F0dHJpYnV0aW9uXCIsIFwiZGF0YS1tZXNzYWdlXCI6IFwiUGxlYXNlIG9ubHkgaGlkZSB0aGlzIGF0dHJpYnV0aW9uIHdoZW4geW91IGFyZSBzdWJzY3JpYmVkIHRvIFJlYWN0IEZsb3cgUHJvOiBodHRwczovL3JlYWN0Zmxvdy5kZXYvcHJvXCIgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgeyBocmVmOiBcImh0dHBzOi8vcmVhY3RmbG93LmRldlwiLCB0YXJnZXQ6IFwiX2JsYW5rXCIsIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsIFwiYXJpYS1sYWJlbFwiOiBcIlJlYWN0IEZsb3cgYXR0cmlidXRpb25cIiB9LCBcIlJlYWN0IEZsb3dcIikpKTtcbn1cblxuY29uc3QgRWRnZVRleHQgPSAoeyB4LCB5LCBsYWJlbCwgbGFiZWxTdHlsZSA9IHt9LCBsYWJlbFNob3dCZyA9IHRydWUsIGxhYmVsQmdTdHlsZSA9IHt9LCBsYWJlbEJnUGFkZGluZyA9IFsyLCA0XSwgbGFiZWxCZ0JvcmRlclJhZGl1cyA9IDIsIGNoaWxkcmVuLCBjbGFzc05hbWUsIC4uLnJlc3QgfSkgPT4ge1xuICAgIGNvbnN0IGVkZ2VSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgW2VkZ2VUZXh0QmJveCwgc2V0RWRnZVRleHRCYm94XSA9IHVzZVN0YXRlKHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgICBjb25zdCBlZGdlVGV4dENsYXNzZXMgPSBjYyhbJ3JlYWN0LWZsb3dfX2VkZ2UtdGV4dHdyYXBwZXInLCBjbGFzc05hbWVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWRnZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QmJveCA9IGVkZ2VSZWYuY3VycmVudC5nZXRCQm94KCk7XG4gICAgICAgICAgICBzZXRFZGdlVGV4dEJib3goe1xuICAgICAgICAgICAgICAgIHg6IHRleHRCYm94LngsXG4gICAgICAgICAgICAgICAgeTogdGV4dEJib3gueSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGV4dEJib3gud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0ZXh0QmJveC5oZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtsYWJlbF0pO1xuICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICd1bmRlZmluZWQnIHx8ICFsYWJlbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3ggLSBlZGdlVGV4dEJib3gud2lkdGggLyAyfSAke3kgLSBlZGdlVGV4dEJib3guaGVpZ2h0IC8gMn0pYCwgY2xhc3NOYW1lOiBlZGdlVGV4dENsYXNzZXMsIHZpc2liaWxpdHk6IGVkZ2VUZXh0QmJveC53aWR0aCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLCAuLi5yZXN0IH0sXG4gICAgICAgIGxhYmVsU2hvd0JnICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7IHdpZHRoOiBlZGdlVGV4dEJib3gud2lkdGggKyAyICogbGFiZWxCZ1BhZGRpbmdbMF0sIHg6IC1sYWJlbEJnUGFkZGluZ1swXSwgeTogLWxhYmVsQmdQYWRkaW5nWzFdLCBoZWlnaHQ6IGVkZ2VUZXh0QmJveC5oZWlnaHQgKyAyICogbGFiZWxCZ1BhZGRpbmdbMV0sIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXRleHRiZ1wiLCBzdHlsZTogbGFiZWxCZ1N0eWxlLCByeDogbGFiZWxCZ0JvcmRlclJhZGl1cywgcnk6IGxhYmVsQmdCb3JkZXJSYWRpdXMgfSkpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGV4dFwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXRleHRcIiwgeTogZWRnZVRleHRCYm94LmhlaWdodCAvIDIsIGR5OiBcIjAuM2VtXCIsIHJlZjogZWRnZVJlZiwgc3R5bGU6IGxhYmVsU3R5bGUgfSwgbGFiZWwpLFxuICAgICAgICBjaGlsZHJlbikpO1xufTtcbnZhciBFZGdlVGV4dCQxID0gbWVtbyhFZGdlVGV4dCk7XG5cbmNvbnN0IGdldERpbWVuc2lvbnMgPSAobm9kZSkgPT4gKHtcbiAgICB3aWR0aDogbm9kZS5vZmZzZXRXaWR0aCxcbiAgICBoZWlnaHQ6IG5vZGUub2Zmc2V0SGVpZ2h0LFxufSk7XG5jb25zdCBjbGFtcCA9ICh2YWwsIG1pbiA9IDAsIG1heCA9IDEpID0+IE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbmNvbnN0IGNsYW1wUG9zaXRpb24gPSAocG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfSwgZXh0ZW50KSA9PiAoe1xuICAgIHg6IGNsYW1wKHBvc2l0aW9uLngsIGV4dGVudFswXVswXSwgZXh0ZW50WzFdWzBdKSxcbiAgICB5OiBjbGFtcChwb3NpdGlvbi55LCBleHRlbnRbMF1bMV0sIGV4dGVudFsxXVsxXSksXG59KTtcbi8vIHJldHVybnMgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIHRoYXQgcmVwcmVzZW50cyB0aGUgdmVsb2NpdHkgb2YgdGhlIG1vdmVtZW50XG4vLyB3aGVuIHRoZSBtb3VzZSBpcyBjbG9zZSB0byB0aGUgZWRnZSBvZiB0aGUgY2FudmFzXG5jb25zdCBjYWxjQXV0b1BhblZlbG9jaXR5ID0gKHZhbHVlLCBtaW4sIG1heCkgPT4ge1xuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICByZXR1cm4gY2xhbXAoTWF0aC5hYnModmFsdWUgLSBtaW4pLCAxLCA1MCkgLyA1MDtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIC1jbGFtcChNYXRoLmFicyh2YWx1ZSAtIG1heCksIDEsIDUwKSAvIDUwO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5jb25zdCBjYWxjQXV0b1BhbiA9IChwb3MsIGJvdW5kcykgPT4ge1xuICAgIGNvbnN0IHhNb3ZlbWVudCA9IGNhbGNBdXRvUGFuVmVsb2NpdHkocG9zLngsIDM1LCBib3VuZHMud2lkdGggLSAzNSkgKiAyMDtcbiAgICBjb25zdCB5TW92ZW1lbnQgPSBjYWxjQXV0b1BhblZlbG9jaXR5KHBvcy55LCAzNSwgYm91bmRzLmhlaWdodCAtIDM1KSAqIDIwO1xuICAgIHJldHVybiBbeE1vdmVtZW50LCB5TW92ZW1lbnRdO1xufTtcbmNvbnN0IGdldEhvc3RGb3JFbGVtZW50ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0Um9vdE5vZGU/LigpIHx8IHdpbmRvdz8uZG9jdW1lbnQ7XG5jb25zdCBnZXRCb3VuZHNPZkJveGVzID0gKGJveDEsIGJveDIpID0+ICh7XG4gICAgeDogTWF0aC5taW4oYm94MS54LCBib3gyLngpLFxuICAgIHk6IE1hdGgubWluKGJveDEueSwgYm94Mi55KSxcbiAgICB4MjogTWF0aC5tYXgoYm94MS54MiwgYm94Mi54MiksXG4gICAgeTI6IE1hdGgubWF4KGJveDEueTIsIGJveDIueTIpLFxufSk7XG5jb25zdCByZWN0VG9Cb3ggPSAoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0pID0+ICh7XG4gICAgeCxcbiAgICB5LFxuICAgIHgyOiB4ICsgd2lkdGgsXG4gICAgeTI6IHkgKyBoZWlnaHQsXG59KTtcbmNvbnN0IGJveFRvUmVjdCA9ICh7IHgsIHksIHgyLCB5MiB9KSA9PiAoe1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aDogeDIgLSB4LFxuICAgIGhlaWdodDogeTIgLSB5LFxufSk7XG5jb25zdCBub2RlVG9SZWN0ID0gKG5vZGUpID0+ICh7XG4gICAgLi4uKG5vZGUucG9zaXRpb25BYnNvbHV0ZSB8fCB7IHg6IDAsIHk6IDAgfSksXG4gICAgd2lkdGg6IG5vZGUud2lkdGggfHwgMCxcbiAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0IHx8IDAsXG59KTtcbmNvbnN0IGdldEJvdW5kc09mUmVjdHMgPSAocmVjdDEsIHJlY3QyKSA9PiBib3hUb1JlY3QoZ2V0Qm91bmRzT2ZCb3hlcyhyZWN0VG9Cb3gocmVjdDEpLCByZWN0VG9Cb3gocmVjdDIpKSk7XG5jb25zdCBnZXRPdmVybGFwcGluZ0FyZWEgPSAocmVjdEEsIHJlY3RCKSA9PiB7XG4gICAgY29uc3QgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0QS54ICsgcmVjdEEud2lkdGgsIHJlY3RCLnggKyByZWN0Qi53aWR0aCkgLSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KSk7XG4gICAgY29uc3QgeU92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0QS55ICsgcmVjdEEuaGVpZ2h0LCByZWN0Qi55ICsgcmVjdEIuaGVpZ2h0KSAtIE1hdGgubWF4KHJlY3RBLnksIHJlY3RCLnkpKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHhPdmVybGFwICogeU92ZXJsYXApO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBpc1JlY3RPYmplY3QgPSAob2JqKSA9PiBpc051bWVyaWMob2JqLndpZHRoKSAmJiBpc051bWVyaWMob2JqLmhlaWdodCkgJiYgaXNOdW1lcmljKG9iai54KSAmJiBpc051bWVyaWMob2JqLnkpO1xuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IGlzTnVtZXJpYyA9IChuKSA9PiAhaXNOYU4obikgJiYgaXNGaW5pdGUobik7XG5jb25zdCBpbnRlcm5hbHNTeW1ib2wgPSBTeW1ib2wuZm9yKCdpbnRlcm5hbHMnKTtcbi8vIHVzZWQgZm9yIGExMXkga2V5IGJvYXJkIGNvbnRyb2xzIGZvciBub2RlcyBhbmQgZWRnZXNcbmNvbnN0IGVsZW1lbnRTZWxlY3Rpb25LZXlzID0gWydFbnRlcicsICcgJywgJ0VzY2FwZSddO1xuY29uc3QgZGV2V2FybiA9IChpZCwgbWVzc2FnZSkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtSZWFjdCBGbG93XTogJHttZXNzYWdlfSBIZWxwOiBodHRwczovL3JlYWN0Zmxvdy5kZXYvZXJyb3IjJHtpZH1gKTtcbiAgICB9XG59O1xuY29uc3QgaXNSZWFjdEtleWJvYXJkRXZlbnQgPSAoZXZlbnQpID0+ICduYXRpdmVFdmVudCcgaW4gZXZlbnQ7XG5mdW5jdGlvbiBpc0lucHV0RE9NTm9kZShldmVudCkge1xuICAgIGNvbnN0IGtiRXZlbnQgPSBpc1JlYWN0S2V5Ym9hcmRFdmVudChldmVudCkgPyBldmVudC5uYXRpdmVFdmVudCA6IGV2ZW50O1xuICAgIC8vIHVzaW5nIGNvbXBvc2VkIHBhdGggZm9yIGhhbmRsaW5nIHNoYWRvdyBkb21cbiAgICBjb25zdCB0YXJnZXQgPSAoa2JFdmVudC5jb21wb3NlZFBhdGg/LigpPy5bMF0gfHwgZXZlbnQudGFyZ2V0KTtcbiAgICBjb25zdCBpc0lucHV0ID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXS5pbmNsdWRlcyh0YXJnZXQ/Lm5vZGVOYW1lKSB8fCB0YXJnZXQ/Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgLy8gd2hlbiBhbiBpbnB1dCBmaWVsZCBpcyBmb2N1c2VkIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBkZWxldGlvbiBvciBtb3ZlbWVudCBvZiBub2Rlc1xuICAgIHJldHVybiBpc0lucHV0IHx8ICEhdGFyZ2V0Py5jbG9zZXN0KCcubm9rZXknKTtcbn1cbmNvbnN0IGlzTW91c2VFdmVudCA9IChldmVudCkgPT4gJ2NsaWVudFgnIGluIGV2ZW50O1xuY29uc3QgZ2V0RXZlbnRQb3NpdGlvbiA9IChldmVudCwgYm91bmRzKSA9PiB7XG4gICAgY29uc3QgaXNNb3VzZVRyaWdnZXJlZCA9IGlzTW91c2VFdmVudChldmVudCk7XG4gICAgY29uc3QgZXZ0WCA9IGlzTW91c2VUcmlnZ2VyZWQgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFg7XG4gICAgY29uc3QgZXZ0WSA9IGlzTW91c2VUcmlnZ2VyZWQgPyBldmVudC5jbGllbnRZIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZ0WCAtIChib3VuZHM/LmxlZnQgPz8gMCksXG4gICAgICAgIHk6IGV2dFkgLSAoYm91bmRzPy50b3AgPz8gMCksXG4gICAgfTtcbn07XG5jb25zdCBpc01hY09zID0gKCkgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yPy51c2VyQWdlbnQ/LmluZGV4T2YoJ01hYycpID49IDA7XG5cbmNvbnN0IEJhc2VFZGdlID0gKHsgaWQsIHBhdGgsIGxhYmVsWCwgbGFiZWxZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoID0gMjAsIH0pID0+IHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgaWQ6IGlkLCBzdHlsZTogc3R5bGUsIGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZS1wYXRoXCIsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQgfSksXG4gICAgICAgIGludGVyYWN0aW9uV2lkdGggJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIHN0cm9rZU9wYWNpdHk6IDAsIHN0cm9rZVdpZHRoOiBpbnRlcmFjdGlvbldpZHRoLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZS1pbnRlcmFjdGlvblwiIH0pKSxcbiAgICAgICAgbGFiZWwgJiYgaXNOdW1lcmljKGxhYmVsWCkgJiYgaXNOdW1lcmljKGxhYmVsWSkgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChFZGdlVGV4dCQxLCB7IHg6IGxhYmVsWCwgeTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cyB9KSkgOiBudWxsKSk7XG59O1xuQmFzZUVkZ2UuZGlzcGxheU5hbWUgPSAnQmFzZUVkZ2UnO1xuXG5jb25zdCBnZXRNYXJrZXJFbmQgPSAobWFya2VyVHlwZSwgbWFya2VyRW5kSWQpID0+IHtcbiAgICBpZiAodHlwZW9mIG1hcmtlckVuZElkICE9PSAndW5kZWZpbmVkJyAmJiBtYXJrZXJFbmRJZCkge1xuICAgICAgICByZXR1cm4gYHVybCgjJHttYXJrZXJFbmRJZH0pYDtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBtYXJrZXJUeXBlICE9PSAndW5kZWZpbmVkJyA/IGB1cmwoI3JlYWN0LWZsb3dfXyR7bWFya2VyVHlwZX0pYCA6ICdub25lJztcbn07XG5mdW5jdGlvbiBnZXRNb3VzZUhhbmRsZXIkMShpZCwgZ2V0U3RhdGUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gaGFuZGxlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gaGFuZGxlclxuICAgICAgICA6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWRnZSA9IGdldFN0YXRlKCkuZWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gaWQpO1xuICAgICAgICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG59XG4vLyB0aGlzIGlzIHVzZWQgZm9yIHN0cmFpZ2h0IGVkZ2VzIGFuZCBzaW1wbGUgc21vb3Roc3RlcCBlZGdlcyAoTFRSLCBSVEwsIEJUVCwgVFRCKVxuZnVuY3Rpb24gZ2V0RWRnZUNlbnRlcih7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIH0pIHtcbiAgICBjb25zdCB4T2Zmc2V0ID0gTWF0aC5hYnModGFyZ2V0WCAtIHNvdXJjZVgpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJYID0gdGFyZ2V0WCA8IHNvdXJjZVggPyB0YXJnZXRYICsgeE9mZnNldCA6IHRhcmdldFggLSB4T2Zmc2V0O1xuICAgIGNvbnN0IHlPZmZzZXQgPSBNYXRoLmFicyh0YXJnZXRZIC0gc291cmNlWSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSB0YXJnZXRZIDwgc291cmNlWSA/IHRhcmdldFkgKyB5T2Zmc2V0IDogdGFyZ2V0WSAtIHlPZmZzZXQ7XG4gICAgcmV0dXJuIFtjZW50ZXJYLCBjZW50ZXJZLCB4T2Zmc2V0LCB5T2Zmc2V0XTtcbn1cbmZ1bmN0aW9uIGdldEJlemllckVkZ2VDZW50ZXIoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFksIHRhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWSwgfSkge1xuICAgIC8vIGN1YmljIGJlemllciB0PTAuNSBtaWQgcG9pbnQsIG5vdCB0aGUgYWN0dWFsIG1pZCBwb2ludCwgYnV0IGVhc3kgdG8gY2FsY3VsYXRlXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc1MTYxMDEvaG93LXRvLWZpbmQtZGlzdGFuY2UtbWlkLXBvaW50LW9mLWJlemllci1jdXJ2ZVxuICAgIGNvbnN0IGNlbnRlclggPSBzb3VyY2VYICogMC4xMjUgKyBzb3VyY2VDb250cm9sWCAqIDAuMzc1ICsgdGFyZ2V0Q29udHJvbFggKiAwLjM3NSArIHRhcmdldFggKiAwLjEyNTtcbiAgICBjb25zdCBjZW50ZXJZID0gc291cmNlWSAqIDAuMTI1ICsgc291cmNlQ29udHJvbFkgKiAwLjM3NSArIHRhcmdldENvbnRyb2xZICogMC4zNzUgKyB0YXJnZXRZICogMC4xMjU7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguYWJzKGNlbnRlclggLSBzb3VyY2VYKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5hYnMoY2VudGVyWSAtIHNvdXJjZVkpO1xuICAgIHJldHVybiBbY2VudGVyWCwgY2VudGVyWSwgb2Zmc2V0WCwgb2Zmc2V0WV07XG59XG5cbnZhciBDb25uZWN0aW9uTW9kZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvbk1vZGUpIHtcbiAgICBDb25uZWN0aW9uTW9kZVtcIlN0cmljdFwiXSA9IFwic3RyaWN0XCI7XG4gICAgQ29ubmVjdGlvbk1vZGVbXCJMb29zZVwiXSA9IFwibG9vc2VcIjtcbn0pKENvbm5lY3Rpb25Nb2RlIHx8IChDb25uZWN0aW9uTW9kZSA9IHt9KSk7XG52YXIgUGFuT25TY3JvbGxNb2RlO1xuKGZ1bmN0aW9uIChQYW5PblNjcm9sbE1vZGUpIHtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJGcmVlXCJdID0gXCJmcmVlXCI7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiVmVydGljYWxcIl0gPSBcInZlcnRpY2FsXCI7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiSG9yaXpvbnRhbFwiXSA9IFwiaG9yaXpvbnRhbFwiO1xufSkoUGFuT25TY3JvbGxNb2RlIHx8IChQYW5PblNjcm9sbE1vZGUgPSB7fSkpO1xudmFyIFNlbGVjdGlvbk1vZGU7XG4oZnVuY3Rpb24gKFNlbGVjdGlvbk1vZGUpIHtcbiAgICBTZWxlY3Rpb25Nb2RlW1wiUGFydGlhbFwiXSA9IFwicGFydGlhbFwiO1xuICAgIFNlbGVjdGlvbk1vZGVbXCJGdWxsXCJdID0gXCJmdWxsXCI7XG59KShTZWxlY3Rpb25Nb2RlIHx8IChTZWxlY3Rpb25Nb2RlID0ge30pKTtcblxudmFyIENvbm5lY3Rpb25MaW5lVHlwZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvbkxpbmVUeXBlKSB7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiQmV6aWVyXCJdID0gXCJkZWZhdWx0XCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU3RyYWlnaHRcIl0gPSBcInN0cmFpZ2h0XCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU3RlcFwiXSA9IFwic3RlcFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlNtb290aFN0ZXBcIl0gPSBcInNtb290aHN0ZXBcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTaW1wbGVCZXppZXJcIl0gPSBcInNpbXBsZWJlemllclwiO1xufSkoQ29ubmVjdGlvbkxpbmVUeXBlIHx8IChDb25uZWN0aW9uTGluZVR5cGUgPSB7fSkpO1xudmFyIE1hcmtlclR5cGU7XG4oZnVuY3Rpb24gKE1hcmtlclR5cGUpIHtcbiAgICBNYXJrZXJUeXBlW1wiQXJyb3dcIl0gPSBcImFycm93XCI7XG4gICAgTWFya2VyVHlwZVtcIkFycm93Q2xvc2VkXCJdID0gXCJhcnJvd2Nsb3NlZFwiO1xufSkoTWFya2VyVHlwZSB8fCAoTWFya2VyVHlwZSA9IHt9KSk7XG5cbnZhciBQb3NpdGlvbjtcbihmdW5jdGlvbiAoUG9zaXRpb24pIHtcbiAgICBQb3NpdGlvbltcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBQb3NpdGlvbltcIlRvcFwiXSA9IFwidG9wXCI7XG4gICAgUG9zaXRpb25bXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcbiAgICBQb3NpdGlvbltcIkJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG59KShQb3NpdGlvbiB8fCAoUG9zaXRpb24gPSB7fSkpO1xuXG5mdW5jdGlvbiBnZXRDb250cm9sKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiB9KSB7XG4gICAgaWYgKHBvcyA9PT0gUG9zaXRpb24uTGVmdCB8fCBwb3MgPT09IFBvc2l0aW9uLlJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBbMC41ICogKHgxICsgeDIpLCB5MV07XG4gICAgfVxuICAgIHJldHVybiBbeDEsIDAuNSAqICh5MSArIHkyKV07XG59XG5mdW5jdGlvbiBnZXRTaW1wbGVCZXppZXJQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCB9KSB7XG4gICAgY29uc3QgW3NvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgfSk7XG4gICAgY29uc3QgW3RhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgfSk7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllckVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgICAgICBzb3VyY2VDb250cm9sWCxcbiAgICAgICAgc291cmNlQ29udHJvbFksXG4gICAgICAgIHRhcmdldENvbnRyb2xYLFxuICAgICAgICB0YXJnZXRDb250cm9sWSxcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBgTSR7c291cmNlWH0sJHtzb3VyY2VZfSBDJHtzb3VyY2VDb250cm9sWH0sJHtzb3VyY2VDb250cm9sWX0gJHt0YXJnZXRDb250cm9sWH0sJHt0YXJnZXRDb250cm9sWX0gJHt0YXJnZXRYfSwke3RhcmdldFl9YCxcbiAgICAgICAgbGFiZWxYLFxuICAgICAgICBsYWJlbFksXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgXTtcbn1cbmNvbnN0IFNpbXBsZUJlemllckVkZ2UgPSBtZW1vKCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTaW1wbGVCZXppZXJQYXRoKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgIH0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChCYXNlRWRnZSwgeyBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xufSk7XG5TaW1wbGVCZXppZXJFZGdlLmRpc3BsYXlOYW1lID0gJ1NpbXBsZUJlemllckVkZ2UnO1xuXG5jb25zdCBoYW5kbGVEaXJlY3Rpb25zID0ge1xuICAgIFtQb3NpdGlvbi5MZWZ0XTogeyB4OiAtMSwgeTogMCB9LFxuICAgIFtQb3NpdGlvbi5SaWdodF06IHsgeDogMSwgeTogMCB9LFxuICAgIFtQb3NpdGlvbi5Ub3BdOiB7IHg6IDAsIHk6IC0xIH0sXG4gICAgW1Bvc2l0aW9uLkJvdHRvbV06IHsgeDogMCwgeTogMSB9LFxufTtcbmNvbnN0IGdldERpcmVjdGlvbiA9ICh7IHNvdXJjZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldCwgfSkgPT4ge1xuICAgIGlmIChzb3VyY2VQb3NpdGlvbiA9PT0gUG9zaXRpb24uTGVmdCB8fCBzb3VyY2VQb3NpdGlvbiA9PT0gUG9zaXRpb24uUmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS54IDwgdGFyZ2V0LnggPyB7IHg6IDEsIHk6IDAgfSA6IHsgeDogLTEsIHk6IDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZS55IDwgdGFyZ2V0LnkgPyB7IHg6IDAsIHk6IDEgfSA6IHsgeDogMCwgeTogLTEgfTtcbn07XG5jb25zdCBkaXN0YW5jZSA9IChhLCBiKSA9PiBNYXRoLnNxcnQoTWF0aC5wb3coYi54IC0gYS54LCAyKSArIE1hdGgucG93KGIueSAtIGEueSwgMikpO1xuLy8gaXRoIHRoaXMgZnVuY3Rpb24gd2UgdHJ5IHRvIG1pbWljIGEgb3J0aG9nb25hbCBlZGdlIHJvdXRpbmcgYmVoYXZpb3VyXG4vLyBJdCdzIG5vdCBhcyBnb29kIGFzIGEgcmVhbCBvcnRob2dvbmFsIGVkZ2Ugcm91dGluZyBidXQgaXQncyBmYXN0ZXIgYW5kIGdvb2QgZW5vdWdoIGFzIGEgZGVmYXVsdCBmb3Igc3RlcCBhbmQgc21vb3RoIHN0ZXAgZWRnZXNcbmZ1bmN0aW9uIGdldFBvaW50cyh7IHNvdXJjZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldCwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGNlbnRlciwgb2Zmc2V0LCB9KSB7XG4gICAgY29uc3Qgc291cmNlRGlyID0gaGFuZGxlRGlyZWN0aW9uc1tzb3VyY2VQb3NpdGlvbl07XG4gICAgY29uc3QgdGFyZ2V0RGlyID0gaGFuZGxlRGlyZWN0aW9uc1t0YXJnZXRQb3NpdGlvbl07XG4gICAgY29uc3Qgc291cmNlR2FwcGVkID0geyB4OiBzb3VyY2UueCArIHNvdXJjZURpci54ICogb2Zmc2V0LCB5OiBzb3VyY2UueSArIHNvdXJjZURpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgdGFyZ2V0R2FwcGVkID0geyB4OiB0YXJnZXQueCArIHRhcmdldERpci54ICogb2Zmc2V0LCB5OiB0YXJnZXQueSArIHRhcmdldERpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgZGlyID0gZ2V0RGlyZWN0aW9uKHtcbiAgICAgICAgc291cmNlOiBzb3VyY2VHYXBwZWQsXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldEdhcHBlZCxcbiAgICB9KTtcbiAgICBjb25zdCBkaXJBY2Nlc3NvciA9IGRpci54ICE9PSAwID8gJ3gnIDogJ3knO1xuICAgIGNvbnN0IGN1cnJEaXIgPSBkaXJbZGlyQWNjZXNzb3JdO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBsZXQgY2VudGVyWCwgY2VudGVyWTtcbiAgICBjb25zdCBzb3VyY2VHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCB0YXJnZXRHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBbZGVmYXVsdENlbnRlclgsIGRlZmF1bHRDZW50ZXJZLCBkZWZhdWx0T2Zmc2V0WCwgZGVmYXVsdE9mZnNldFldID0gZ2V0RWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICAgICAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAgICAgICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gICAgICAgIHRhcmdldFk6IHRhcmdldC55LFxuICAgIH0pO1xuICAgIC8vIG9wcG9zaXRlIGhhbmRsZSBwb3NpdGlvbnMsIGRlZmF1bHQgY2FzZVxuICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdICogdGFyZ2V0RGlyW2RpckFjY2Vzc29yXSA9PT0gLTEpIHtcbiAgICAgICAgY2VudGVyWCA9IGNlbnRlci54IHx8IGRlZmF1bHRDZW50ZXJYO1xuICAgICAgICBjZW50ZXJZID0gY2VudGVyLnkgfHwgZGVmYXVsdENlbnRlclk7XG4gICAgICAgIC8vICAgIC0tLT5cbiAgICAgICAgLy8gICAgfFxuICAgICAgICAvLyA+LS0tXG4gICAgICAgIGNvbnN0IHZlcnRpY2FsU3BsaXQgPSBbXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHNvdXJjZUdhcHBlZC55IH0sXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHRhcmdldEdhcHBlZC55IH0sXG4gICAgICAgIF07XG4gICAgICAgIC8vICAgIHxcbiAgICAgICAgLy8gIC0tLVxuICAgICAgICAvLyAgfFxuICAgICAgICBjb25zdCBob3Jpem9udGFsU3BsaXQgPSBbXG4gICAgICAgICAgICB7IHg6IHNvdXJjZUdhcHBlZC54LCB5OiBjZW50ZXJZIH0sXG4gICAgICAgICAgICB7IHg6IHRhcmdldEdhcHBlZC54LCB5OiBjZW50ZXJZIH0sXG4gICAgICAgIF07XG4gICAgICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSBjdXJyRGlyKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gdmVydGljYWxTcGxpdCA6IGhvcml6b250YWxTcGxpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyBob3Jpem9udGFsU3BsaXQgOiB2ZXJ0aWNhbFNwbGl0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzb3VyY2VUYXJnZXQgbWVhbnMgd2UgdGFrZSB4IGZyb20gc291cmNlIGFuZCB5IGZyb20gdGFyZ2V0LCB0YXJnZXRTb3VyY2UgaXMgdGhlIG9wcG9zaXRlXG4gICAgICAgIGNvbnN0IHNvdXJjZVRhcmdldCA9IFt7IHg6IHNvdXJjZUdhcHBlZC54LCB5OiB0YXJnZXRHYXBwZWQueSB9XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0U291cmNlID0gW3sgeDogdGFyZ2V0R2FwcGVkLngsIHk6IHNvdXJjZUdhcHBlZC55IH1dO1xuICAgICAgICAvLyB0aGlzIGhhbmRsZXMgZWRnZXMgd2l0aCBzYW1lIGhhbmRsZSBwb3NpdGlvbnNcbiAgICAgICAgaWYgKGRpckFjY2Vzc29yID09PSAneCcpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHNvdXJjZURpci54ID09PSBjdXJyRGlyID8gdGFyZ2V0U291cmNlIDogc291cmNlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gc291cmNlRGlyLnkgPT09IGN1cnJEaXIgPyBzb3VyY2VUYXJnZXQgOiB0YXJnZXRTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVBvc2l0aW9uID09PSB0YXJnZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKHNvdXJjZVtkaXJBY2Nlc3Nvcl0gLSB0YXJnZXRbZGlyQWNjZXNzb3JdKTtcbiAgICAgICAgICAgIC8vIGlmIGFuIGVkZ2UgZ29lcyBmcm9tIHJpZ2h0IHRvIHJpZ2h0IGZvciBleGFtcGxlIChzb3VyY2VQb3NpdGlvbiA9PT0gdGFyZ2V0UG9zaXRpb24pIGFuZCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBzb3VyY2UueCBhbmQgdGFyZ2V0LnggaXMgbGVzcyB0aGFuIHRoZSBvZmZzZXQsIHRoZSBhZGRlZCBwb2ludCBhbmQgdGhlIGdhcHBlZCBzb3VyY2UvdGFyZ2V0IHdpbGwgb3ZlcmxhcC4gVGhpcyBsZWFkcyB0byBhIHdlaXJkIGVkZ2UgcGF0aC4gVG8gYXZvaWQgdGhpcyB3ZSBhZGQgYSBnYXBPZmZzZXQgdG8gdGhlIHNvdXJjZS90YXJnZXRcbiAgICAgICAgICAgIGlmIChkaWZmIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhcE9mZnNldCA9IE1hdGgubWluKG9mZnNldCAtIDEsIG9mZnNldCAtIGRpZmYpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSBjdXJyRGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUdhcE9mZnNldFtkaXJBY2Nlc3Nvcl0gPSAoc291cmNlR2FwcGVkW2RpckFjY2Vzc29yXSA+IHNvdXJjZVtkaXJBY2Nlc3Nvcl0gPyAtMSA6IDEpICogZ2FwT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0R2FwT2Zmc2V0W2RpckFjY2Vzc29yXSA9ICh0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JdID4gdGFyZ2V0W2RpckFjY2Vzc29yXSA/IC0xIDogMSkgKiBnYXBPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZXNlIGFyZSBjb25kaXRpb25zIGZvciBoYW5kbGluZyBtaXhlZCBoYW5kbGUgcG9zaXRpb25zIGxpa2UgUmlnaHQgLT4gQm90dG9tIGZvciBleGFtcGxlXG4gICAgICAgIGlmIChzb3VyY2VQb3NpdGlvbiAhPT0gdGFyZ2V0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpckFjY2Vzc29yT3Bwb3NpdGUgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICAgICAgICAgICAgY29uc3QgaXNTYW1lRGlyID0gc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gdGFyZ2V0RGlyW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlR3RUYXJnZXRPcHBvID0gc291cmNlR2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdID4gdGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlTHRUYXJnZXRPcHBvID0gc291cmNlR2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdIDwgdGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3QgZmxpcFNvdXJjZVRhcmdldCA9IChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSAxICYmICgoIWlzU2FtZURpciAmJiBzb3VyY2VHdFRhcmdldE9wcG8pIHx8IChpc1NhbWVEaXIgJiYgc291cmNlTHRUYXJnZXRPcHBvKSkpIHx8XG4gICAgICAgICAgICAgICAgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gIT09IDEgJiYgKCghaXNTYW1lRGlyICYmIHNvdXJjZUx0VGFyZ2V0T3BwbykgfHwgKGlzU2FtZURpciAmJiBzb3VyY2VHdFRhcmdldE9wcG8pKSk7XG4gICAgICAgICAgICBpZiAoZmxpcFNvdXJjZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyBzb3VyY2VUYXJnZXQgOiB0YXJnZXRTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlR2FwUG9pbnQgPSB7IHg6IHNvdXJjZUdhcHBlZC54ICsgc291cmNlR2FwT2Zmc2V0LngsIHk6IHNvdXJjZUdhcHBlZC55ICsgc291cmNlR2FwT2Zmc2V0LnkgfTtcbiAgICAgICAgY29uc3QgdGFyZ2V0R2FwUG9pbnQgPSB7IHg6IHRhcmdldEdhcHBlZC54ICsgdGFyZ2V0R2FwT2Zmc2V0LngsIHk6IHRhcmdldEdhcHBlZC55ICsgdGFyZ2V0R2FwT2Zmc2V0LnkgfTtcbiAgICAgICAgY29uc3QgbWF4WERpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5hYnMoc291cmNlR2FwUG9pbnQueCAtIHBvaW50c1swXS54KSwgTWF0aC5hYnModGFyZ2V0R2FwUG9pbnQueCAtIHBvaW50c1swXS54KSk7XG4gICAgICAgIGNvbnN0IG1heFlEaXN0YW5jZSA9IE1hdGgubWF4KE1hdGguYWJzKHNvdXJjZUdhcFBvaW50LnkgLSBwb2ludHNbMF0ueSksIE1hdGguYWJzKHRhcmdldEdhcFBvaW50LnkgLSBwb2ludHNbMF0ueSkpO1xuICAgICAgICAvLyB3ZSB3YW50IHRvIHBsYWNlIHRoZSBsYWJlbCBvbiB0aGUgbG9uZ2VzdCBzZWdtZW50IG9mIHRoZSBlZGdlXG4gICAgICAgIGlmIChtYXhYRGlzdGFuY2UgPj0gbWF4WURpc3RhbmNlKSB7XG4gICAgICAgICAgICBjZW50ZXJYID0gKHNvdXJjZUdhcFBvaW50LnggKyB0YXJnZXRHYXBQb2ludC54KSAvIDI7XG4gICAgICAgICAgICBjZW50ZXJZID0gcG9pbnRzWzBdLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjZW50ZXJYID0gcG9pbnRzWzBdLng7XG4gICAgICAgICAgICBjZW50ZXJZID0gKHNvdXJjZUdhcFBvaW50LnkgKyB0YXJnZXRHYXBQb2ludC55KSAvIDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGF0aFBvaW50cyA9IFtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB7IHg6IHNvdXJjZUdhcHBlZC54ICsgc291cmNlR2FwT2Zmc2V0LngsIHk6IHNvdXJjZUdhcHBlZC55ICsgc291cmNlR2FwT2Zmc2V0LnkgfSxcbiAgICAgICAgLi4ucG9pbnRzLFxuICAgICAgICB7IHg6IHRhcmdldEdhcHBlZC54ICsgdGFyZ2V0R2FwT2Zmc2V0LngsIHk6IHRhcmdldEdhcHBlZC55ICsgdGFyZ2V0R2FwT2Zmc2V0LnkgfSxcbiAgICAgICAgdGFyZ2V0LFxuICAgIF07XG4gICAgcmV0dXJuIFtwYXRoUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCBkZWZhdWx0T2Zmc2V0WCwgZGVmYXVsdE9mZnNldFldO1xufVxuZnVuY3Rpb24gZ2V0QmVuZChhLCBiLCBjLCBzaXplKSB7XG4gICAgY29uc3QgYmVuZFNpemUgPSBNYXRoLm1pbihkaXN0YW5jZShhLCBiKSAvIDIsIGRpc3RhbmNlKGIsIGMpIC8gMiwgc2l6ZSk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBiO1xuICAgIC8vIG5vIGJlbmRcbiAgICBpZiAoKGEueCA9PT0geCAmJiB4ID09PSBjLngpIHx8IChhLnkgPT09IHkgJiYgeSA9PT0gYy55KSkge1xuICAgICAgICByZXR1cm4gYEwke3h9ICR7eX1gO1xuICAgIH1cbiAgICAvLyBmaXJzdCBzZWdtZW50IGlzIGhvcml6b250YWxcbiAgICBpZiAoYS55ID09PSB5KSB7XG4gICAgICAgIGNvbnN0IHhEaXIgPSBhLnggPCBjLnggPyAtMSA6IDE7XG4gICAgICAgIGNvbnN0IHlEaXIgPSBhLnkgPCBjLnkgPyAxIDogLTE7XG4gICAgICAgIHJldHVybiBgTCAke3ggKyBiZW5kU2l6ZSAqIHhEaXJ9LCR7eX1RICR7eH0sJHt5fSAke3h9LCR7eSArIGJlbmRTaXplICogeURpcn1gO1xuICAgIH1cbiAgICBjb25zdCB4RGlyID0gYS54IDwgYy54ID8gMSA6IC0xO1xuICAgIGNvbnN0IHlEaXIgPSBhLnkgPCBjLnkgPyAtMSA6IDE7XG4gICAgcmV0dXJuIGBMICR7eH0sJHt5ICsgYmVuZFNpemUgKiB5RGlyfVEgJHt4fSwke3l9ICR7eCArIGJlbmRTaXplICogeERpcn0sJHt5fWA7XG59XG5mdW5jdGlvbiBnZXRTbW9vdGhTdGVwUGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRYLCB0YXJnZXRZLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgYm9yZGVyUmFkaXVzID0gNSwgY2VudGVyWCwgY2VudGVyWSwgb2Zmc2V0ID0gMjAsIH0pIHtcbiAgICBjb25zdCBbcG9pbnRzLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRQb2ludHMoe1xuICAgICAgICBzb3VyY2U6IHsgeDogc291cmNlWCwgeTogc291cmNlWSB9LFxuICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0OiB7IHg6IHRhcmdldFgsIHk6IHRhcmdldFkgfSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIGNlbnRlcjogeyB4OiBjZW50ZXJYLCB5OiBjZW50ZXJZIH0sXG4gICAgICAgIG9mZnNldCxcbiAgICB9KTtcbiAgICBjb25zdCBwYXRoID0gcG9pbnRzLnJlZHVjZSgocmVzLCBwLCBpKSA9PiB7XG4gICAgICAgIGxldCBzZWdtZW50ID0gJyc7XG4gICAgICAgIGlmIChpID4gMCAmJiBpIDwgcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBnZXRCZW5kKHBvaW50c1tpIC0gMV0sIHAsIHBvaW50c1tpICsgMV0sIGJvcmRlclJhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gYCR7aSA9PT0gMCA/ICdNJyA6ICdMJ30ke3AueH0gJHtwLnl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXMgKz0gc2VnbWVudDtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCAnJyk7XG4gICAgcmV0dXJuIFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV07XG59XG5jb25zdCBTbW9vdGhTdGVwRWRnZSA9IG1lbW8oKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBwYXRoT3B0aW9ucz8uYm9yZGVyUmFkaXVzLFxuICAgICAgICBvZmZzZXQ6IHBhdGhPcHRpb25zPy5vZmZzZXQsXG4gICAgfSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VFZGdlLCB7IHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG59KTtcblNtb290aFN0ZXBFZGdlLmRpc3BsYXlOYW1lID0gJ1Ntb290aFN0ZXBFZGdlJztcblxuY29uc3QgU3RlcEVkZ2UgPSBtZW1vKChwcm9wcykgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU21vb3RoU3RlcEVkZ2UsIHsgLi4ucHJvcHMsIHBhdGhPcHRpb25zOiB1c2VNZW1vKCgpID0+ICh7IGJvcmRlclJhZGl1czogMCwgb2Zmc2V0OiBwcm9wcy5wYXRoT3B0aW9ucz8ub2Zmc2V0IH0pLCBbcHJvcHMucGF0aE9wdGlvbnM/Lm9mZnNldF0pIH0pKSk7XG5TdGVwRWRnZS5kaXNwbGF5TmFtZSA9ICdTdGVwRWRnZSc7XG5cbmZ1bmN0aW9uIGdldFN0cmFpZ2h0UGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIH0pIHtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0RWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtgTSAke3NvdXJjZVh9LCR7c291cmNlWX1MICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cbmNvbnN0IFN0cmFpZ2h0RWRnZSA9IG1lbW8oKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTdHJhaWdodFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZIH0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChCYXNlRWRnZSwgeyBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xufSk7XG5TdHJhaWdodEVkZ2UuZGlzcGxheU5hbWUgPSAnU3RyYWlnaHRFZGdlJztcblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udHJvbE9mZnNldChkaXN0YW5jZSwgY3VydmF0dXJlKSB7XG4gICAgaWYgKGRpc3RhbmNlID49IDApIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIGRpc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmF0dXJlICogMjUgKiBNYXRoLnNxcnQoLWRpc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiwgYyB9KSB7XG4gICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcmV0dXJuIFt4MSAtIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeDEgLSB4MiwgYyksIHkxXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5SaWdodDpcbiAgICAgICAgICAgIHJldHVybiBbeDEgKyBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHgyIC0geDEsIGMpLCB5MV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uVG9wOlxuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEgLSBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHkxIC0geTIsIGMpXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICByZXR1cm4gW3gxLCB5MSArIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeTIgLSB5MSwgYyldO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEJlemllclBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGN1cnZhdHVyZSA9IDAuMjUsIH0pIHtcbiAgICBjb25zdCBbc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZXSA9IGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgICAgIGM6IGN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCBbdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZXSA9IGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgICAgIGM6IGN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyRWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHNvdXJjZUNvbnRyb2xYLFxuICAgICAgICBzb3VyY2VDb250cm9sWSxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFgsXG4gICAgICAgIHRhcmdldENvbnRyb2xZLFxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGBNJHtzb3VyY2VYfSwke3NvdXJjZVl9IEMke3NvdXJjZUNvbnRyb2xYfSwke3NvdXJjZUNvbnRyb2xZfSAke3RhcmdldENvbnRyb2xYfSwke3RhcmdldENvbnRyb2xZfSAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLFxuICAgICAgICBsYWJlbFgsXG4gICAgICAgIGxhYmVsWSxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICBdO1xufVxuY29uc3QgQmV6aWVyRWRnZSA9IG1lbW8oKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRCZXppZXJQYXRoKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICBjdXJ2YXR1cmU6IHBhdGhPcHRpb25zPy5jdXJ2YXR1cmUsXG4gICAgfSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VFZGdlLCB7IHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG59KTtcbkJlemllckVkZ2UuZGlzcGxheU5hbWUgPSAnQmV6aWVyRWRnZSc7XG5cbmNvbnN0IE5vZGVJZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgUHJvdmlkZXIgPSBOb2RlSWRDb250ZXh0LlByb3ZpZGVyO1xuTm9kZUlkQ29udGV4dC5Db25zdW1lcjtcbmNvbnN0IHVzZU5vZGVJZCA9ICgpID0+IHtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VDb250ZXh0KE5vZGVJZENvbnRleHQpO1xuICAgIHJldHVybiBub2RlSWQ7XG59O1xuXG5jb25zdCBpc0VkZ2UgPSAoZWxlbWVudCkgPT4gJ2lkJyBpbiBlbGVtZW50ICYmICdzb3VyY2UnIGluIGVsZW1lbnQgJiYgJ3RhcmdldCcgaW4gZWxlbWVudDtcbmNvbnN0IGlzTm9kZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgISgnc291cmNlJyBpbiBlbGVtZW50KSAmJiAhKCd0YXJnZXQnIGluIGVsZW1lbnQpO1xuY29uc3QgZ2V0T3V0Z29lcnMgPSAobm9kZSwgbm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFpc05vZGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBvdXRnb2VySWRzID0gZWRnZXMuZmlsdGVyKChlKSA9PiBlLnNvdXJjZSA9PT0gbm9kZS5pZCkubWFwKChlKSA9PiBlLnRhcmdldCk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobikgPT4gb3V0Z29lcklkcy5pbmNsdWRlcyhuLmlkKSk7XG59O1xuY29uc3QgZ2V0SW5jb21lcnMgPSAobm9kZSwgbm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFpc05vZGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBpbmNvbWVyc0lkcyA9IGVkZ2VzLmZpbHRlcigoZSkgPT4gZS50YXJnZXQgPT09IG5vZGUuaWQpLm1hcCgoZSkgPT4gZS5zb3VyY2UpO1xuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKG4pID0+IGluY29tZXJzSWRzLmluY2x1ZGVzKG4uaWQpKTtcbn07XG5jb25zdCBnZXRFZGdlSWQgPSAoeyBzb3VyY2UsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0LCB0YXJnZXRIYW5kbGUgfSkgPT4gYHJlYWN0Zmxvd19fZWRnZS0ke3NvdXJjZX0ke3NvdXJjZUhhbmRsZSB8fCAnJ30tJHt0YXJnZXR9JHt0YXJnZXRIYW5kbGUgfHwgJyd9YDtcbmNvbnN0IGdldE1hcmtlcklkID0gKG1hcmtlciwgcmZJZCkgPT4ge1xuICAgIGlmICh0eXBlb2YgbWFya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWFya2VyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgIH1cbiAgICBjb25zdCBpZFByZWZpeCA9IHJmSWQgPyBgJHtyZklkfV9fYCA6ICcnO1xuICAgIHJldHVybiBgJHtpZFByZWZpeH0ke09iamVjdC5rZXlzKG1hcmtlcilcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAubWFwKChrZXkpID0+IGAke2tleX09JHttYXJrZXJba2V5XX1gKVxuICAgICAgICAuam9pbignJicpfWA7XG59O1xuY29uc3QgY29ubmVjdGlvbkV4aXN0cyA9IChlZGdlLCBlZGdlcykgPT4ge1xuICAgIHJldHVybiBlZGdlcy5zb21lKChlbCkgPT4gZWwuc291cmNlID09PSBlZGdlLnNvdXJjZSAmJlxuICAgICAgICBlbC50YXJnZXQgPT09IGVkZ2UudGFyZ2V0ICYmXG4gICAgICAgIChlbC5zb3VyY2VIYW5kbGUgPT09IGVkZ2Uuc291cmNlSGFuZGxlIHx8ICghZWwuc291cmNlSGFuZGxlICYmICFlZGdlLnNvdXJjZUhhbmRsZSkpICYmXG4gICAgICAgIChlbC50YXJnZXRIYW5kbGUgPT09IGVkZ2UudGFyZ2V0SGFuZGxlIHx8ICghZWwudGFyZ2V0SGFuZGxlICYmICFlZGdlLnRhcmdldEhhbmRsZSkpKTtcbn07XG5jb25zdCBhZGRFZGdlID0gKGVkZ2VQYXJhbXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFlZGdlUGFyYW1zLnNvdXJjZSB8fCAhZWRnZVBhcmFtcy50YXJnZXQpIHtcbiAgICAgICAgZGV2V2FybignMDA2JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDYnXSgpKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICBsZXQgZWRnZTtcbiAgICBpZiAoaXNFZGdlKGVkZ2VQYXJhbXMpKSB7XG4gICAgICAgIGVkZ2UgPSB7IC4uLmVkZ2VQYXJhbXMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVkZ2UgPSB7XG4gICAgICAgICAgICAuLi5lZGdlUGFyYW1zLFxuICAgICAgICAgICAgaWQ6IGdldEVkZ2VJZChlZGdlUGFyYW1zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25FeGlzdHMoZWRnZSwgZWRnZXMpKSB7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2VzLmNvbmNhdChlZGdlKTtcbn07XG5jb25zdCB1cGRhdGVFZGdlID0gKG9sZEVkZ2UsIG5ld0Nvbm5lY3Rpb24sIGVkZ2VzLCBvcHRpb25zID0geyBzaG91bGRSZXBsYWNlSWQ6IHRydWUgfSkgPT4ge1xuICAgIGNvbnN0IHsgaWQ6IG9sZEVkZ2VJZCwgLi4ucmVzdCB9ID0gb2xkRWRnZTtcbiAgICBpZiAoIW5ld0Nvbm5lY3Rpb24uc291cmNlIHx8ICFuZXdDb25uZWN0aW9uLnRhcmdldCkge1xuICAgICAgICBkZXZXYXJuKCcwMDYnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNiddKCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGNvbnN0IGZvdW5kRWRnZSA9IGVkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IG9sZEVkZ2VJZCk7XG4gICAgaWYgKCFmb3VuZEVkZ2UpIHtcbiAgICAgICAgZGV2V2FybignMDA3JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDcnXShvbGRFZGdlSWQpKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgb2xkIGVkZ2UgYW5kIGNyZWF0ZSB0aGUgbmV3IGVkZ2Ugd2l0aCBwYXJhbWV0ZXJzIG9mIG9sZCBlZGdlLlxuICAgIGNvbnN0IGVkZ2UgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGlkOiBvcHRpb25zLnNob3VsZFJlcGxhY2VJZCA/IGdldEVkZ2VJZChuZXdDb25uZWN0aW9uKSA6IG9sZEVkZ2VJZCxcbiAgICAgICAgc291cmNlOiBuZXdDb25uZWN0aW9uLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiBuZXdDb25uZWN0aW9uLnRhcmdldCxcbiAgICAgICAgc291cmNlSGFuZGxlOiBuZXdDb25uZWN0aW9uLnNvdXJjZUhhbmRsZSxcbiAgICAgICAgdGFyZ2V0SGFuZGxlOiBuZXdDb25uZWN0aW9uLnRhcmdldEhhbmRsZSxcbiAgICB9O1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGUpID0+IGUuaWQgIT09IG9sZEVkZ2VJZCkuY29uY2F0KGVkZ2UpO1xufTtcbmNvbnN0IHBvaW50VG9SZW5kZXJlclBvaW50ID0gKHsgeCwgeSB9LCBbdHgsIHR5LCB0U2NhbGVdLCBzbmFwVG9HcmlkLCBbc25hcFgsIHNuYXBZXSkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICB4OiAoeCAtIHR4KSAvIHRTY2FsZSxcbiAgICAgICAgeTogKHkgLSB0eSkgLyB0U2NhbGUsXG4gICAgfTtcbiAgICBpZiAoc25hcFRvR3JpZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogc25hcFggKiBNYXRoLnJvdW5kKHBvc2l0aW9uLnggLyBzbmFwWCksXG4gICAgICAgICAgICB5OiBzbmFwWSAqIE1hdGgucm91bmQocG9zaXRpb24ueSAvIHNuYXBZKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xufTtcbmNvbnN0IHJlbmRlcmVyUG9pbnRUb1BvaW50ID0gKHsgeCwgeSB9LCBbdHgsIHR5LCB0U2NhbGVdKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAqIHRTY2FsZSArIHR4LFxuICAgICAgICB5OiB5ICogdFNjYWxlICsgdHksXG4gICAgfTtcbn07XG5jb25zdCBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZToge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldFggPSAobm9kZS53aWR0aCA/PyAwKSAqIG5vZGVPcmlnaW5bMF07XG4gICAgY29uc3Qgb2Zmc2V0WSA9IChub2RlLmhlaWdodCA/PyAwKSAqIG5vZGVPcmlnaW5bMV07XG4gICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgIHg6IG5vZGUucG9zaXRpb24ueCAtIG9mZnNldFgsXG4gICAgICAgIHk6IG5vZGUucG9zaXRpb24ueSAtIG9mZnNldFksXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5wb3NpdGlvbixcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogbm9kZS5wb3NpdGlvbkFic29sdXRlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB4OiBub2RlLnBvc2l0aW9uQWJzb2x1dGUueCAtIG9mZnNldFgsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5wb3NpdGlvbkFic29sdXRlLnkgLSBvZmZzZXRZLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBwb3NpdGlvbixcbiAgICB9O1xufTtcbmNvbnN0IGdldE5vZGVzQm91bmRzID0gKG5vZGVzLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgfVxuICAgIGNvbnN0IGJveCA9IG5vZGVzLnJlZHVjZSgoY3VyckJveCwgbm9kZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgbm9kZU9yaWdpbikucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgcmV0dXJuIGdldEJvdW5kc09mQm94ZXMoY3VyckJveCwgcmVjdFRvQm94KHtcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgd2lkdGg6IG5vZGUud2lkdGggfHwgMCxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgfHwgMCxcbiAgICAgICAgfSkpO1xuICAgIH0sIHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MjogLUluZmluaXR5IH0pO1xuICAgIHJldHVybiBib3hUb1JlY3QoYm94KTtcbn07XG4vLyBAZGVwcmVjYXRlZCBVc2UgYGdldE5vZGVzQm91bmRzYC5cbmNvbnN0IGdldFJlY3RPZk5vZGVzID0gKG5vZGVzLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc29sZS53YXJuKCdbREVQUkVDQVRFRF0gYGdldFJlY3RPZk5vZGVzYCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBgZ2V0Tm9kZXNCb3VuZHNgIGh0dHBzOi8vcmVhY3RmbG93LmRldi9hcGktcmVmZXJlbmNlL3V0aWxzL2dldC1ub2Rlcy1ib3VuZHMuJyk7XG4gICAgcmV0dXJuIGdldE5vZGVzQm91bmRzKG5vZGVzLCBub2RlT3JpZ2luKTtcbn07XG5jb25zdCBnZXROb2Rlc0luc2lkZSA9IChub2RlSW50ZXJuYWxzLCByZWN0LCBbdHgsIHR5LCB0U2NhbGVdID0gWzAsIDAsIDFdLCBwYXJ0aWFsbHkgPSBmYWxzZSwgXG4vLyBzZXQgZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyBpZiB5b3Ugd2FudCB0byBwYXkgYXR0ZW50aW9uIHRvIHRoZSBub2RlcyBcInNlbGVjdGFibGVcIiBhdHRyaWJ1dGVcbmV4Y2x1ZGVOb25TZWxlY3RhYmxlTm9kZXMgPSBmYWxzZSwgbm9kZU9yaWdpbiA9IFswLCAwXSkgPT4ge1xuICAgIGNvbnN0IHBhbmVSZWN0ID0ge1xuICAgICAgICB4OiAocmVjdC54IC0gdHgpIC8gdFNjYWxlLFxuICAgICAgICB5OiAocmVjdC55IC0gdHkpIC8gdFNjYWxlLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAvIHRTY2FsZSxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHRTY2FsZSxcbiAgICB9O1xuICAgIGNvbnN0IHZpc2libGVOb2RlcyA9IFtdO1xuICAgIG5vZGVJbnRlcm5hbHMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHNlbGVjdGFibGUgPSB0cnVlLCBoaWRkZW4gPSBmYWxzZSB9ID0gbm9kZTtcbiAgICAgICAgaWYgKChleGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzICYmICFzZWxlY3RhYmxlKSB8fCBoaWRkZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgbm9kZU9yaWdpbik7XG4gICAgICAgIGNvbnN0IG5vZGVSZWN0ID0ge1xuICAgICAgICAgICAgeDogcG9zaXRpb25BYnNvbHV0ZS54LFxuICAgICAgICAgICAgeTogcG9zaXRpb25BYnNvbHV0ZS55LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCB8fCAwLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEocGFuZVJlY3QsIG5vZGVSZWN0KTtcbiAgICAgICAgY29uc3Qgbm90SW5pdGlhbGl6ZWQgPSB0eXBlb2Ygd2lkdGggPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBoZWlnaHQgPT09ICd1bmRlZmluZWQnIHx8IHdpZHRoID09PSBudWxsIHx8IGhlaWdodCA9PT0gbnVsbDtcbiAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICBjb25zdCBhcmVhID0gKHdpZHRoIHx8IDApICogKGhlaWdodCB8fCAwKTtcbiAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gbm90SW5pdGlhbGl6ZWQgfHwgcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gYXJlYTtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSB8fCBub2RlLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB2aXNpYmxlTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2aXNpYmxlTm9kZXM7XG59O1xuY29uc3QgZ2V0Q29ubmVjdGVkRWRnZXMgPSAobm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IG5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCk7XG4gICAgcmV0dXJuIGVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gbm9kZUlkcy5pbmNsdWRlcyhlZGdlLnNvdXJjZSkgfHwgbm9kZUlkcy5pbmNsdWRlcyhlZGdlLnRhcmdldCkpO1xufTtcbi8vIEBkZXByZWNhdGVkIFVzZSBgZ2V0Vmlld3BvcnRGb3JCb3VuZHNgLlxuY29uc3QgZ2V0VHJhbnNmb3JtRm9yQm91bmRzID0gKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgcGFkZGluZyA9IDAuMSkgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBwYWRkaW5nKTtcbiAgICBjb25zb2xlLndhcm4oJ1tERVBSRUNBVEVEXSBgZ2V0VHJhbnNmb3JtRm9yQm91bmRzYCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBgZ2V0Vmlld3BvcnRGb3JCb3VuZHNgLiBCZXdhcmUgdGhhdCB0aGUgcmV0dXJuIHZhbHVlIGlzIHR5cGUgVmlld3BvcnQgKGB7IHg6IG51bWJlciwgeTogbnVtYmVyLCB6b29tOiBudW1iZXIgfWApIGluc3RlYWQgb2YgVHJhbnNmb3JtIChgW251bWJlciwgbnVtYmVyLCBudW1iZXJdYCkuIGh0dHBzOi8vcmVhY3RmbG93LmRldi9hcGktcmVmZXJlbmNlL3V0aWxzL2dldC12aWV3cG9ydC1mb3ItYm91bmRzJyk7XG4gICAgcmV0dXJuIFt4LCB5LCB6b29tXTtcbn07XG5jb25zdCBnZXRWaWV3cG9ydEZvckJvdW5kcyA9IChib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIHBhZGRpbmcgPSAwLjEpID0+IHtcbiAgICBjb25zdCB4Wm9vbSA9IHdpZHRoIC8gKGJvdW5kcy53aWR0aCAqICgxICsgcGFkZGluZykpO1xuICAgIGNvbnN0IHlab29tID0gaGVpZ2h0IC8gKGJvdW5kcy5oZWlnaHQgKiAoMSArIHBhZGRpbmcpKTtcbiAgICBjb25zdCB6b29tID0gTWF0aC5taW4oeFpvb20sIHlab29tKTtcbiAgICBjb25zdCBjbGFtcGVkWm9vbSA9IGNsYW1wKHpvb20sIG1pblpvb20sIG1heFpvb20pO1xuICAgIGNvbnN0IGJvdW5kc0NlbnRlclggPSBib3VuZHMueCArIGJvdW5kcy53aWR0aCAvIDI7XG4gICAgY29uc3QgYm91bmRzQ2VudGVyWSA9IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCAvIDI7XG4gICAgY29uc3QgeCA9IHdpZHRoIC8gMiAtIGJvdW5kc0NlbnRlclggKiBjbGFtcGVkWm9vbTtcbiAgICBjb25zdCB5ID0gaGVpZ2h0IC8gMiAtIGJvdW5kc0NlbnRlclkgKiBjbGFtcGVkWm9vbTtcbiAgICByZXR1cm4geyB4LCB5LCB6b29tOiBjbGFtcGVkWm9vbSB9O1xufTtcbmNvbnN0IGdldEQzVHJhbnNpdGlvbiA9IChzZWxlY3Rpb24sIGR1cmF0aW9uID0gMCkgPT4ge1xuICAgIHJldHVybiBzZWxlY3Rpb24udHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKTtcbn07XG5cbi8vIHRoaXMgZnVuY3Rpb25zIGNvbGxlY3RzIGFsbCBoYW5kbGVzIGFuZCBhZGRzIGFuIGFic29sdXRlIHBvc2l0aW9uXG4vLyBzbyB0aGF0IHdlIGNhbiBsYXRlciBmaW5kIHRoZSBjbG9zZXN0IGhhbmRsZSB0byB0aGUgbW91c2UgcG9zaXRpb25cbmZ1bmN0aW9uIGdldEhhbmRsZXMobm9kZSwgaGFuZGxlQm91bmRzLCB0eXBlLCBjdXJyZW50SGFuZGxlKSB7XG4gICAgcmV0dXJuIChoYW5kbGVCb3VuZHNbdHlwZV0gfHwgW10pLnJlZHVjZSgocmVzLCBoKSA9PiB7XG4gICAgICAgIGlmIChgJHtub2RlLmlkfS0ke2guaWR9LSR7dHlwZX1gICE9PSBjdXJyZW50SGFuZGxlKSB7XG4gICAgICAgICAgICByZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IGguaWQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIG5vZGVJZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICB4OiAobm9kZS5wb3NpdGlvbkFic29sdXRlPy54ID8/IDApICsgaC54ICsgaC53aWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgeTogKG5vZGUucG9zaXRpb25BYnNvbHV0ZT8ueSA/PyAwKSArIGgueSArIGguaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgW10pO1xufVxuZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZShldmVudCwgZG9jLCBwb3MsIGNvbm5lY3Rpb25SYWRpdXMsIGhhbmRsZXMsIHZhbGlkYXRvcikge1xuICAgIC8vIHdlIGFsd2F5cyB3YW50IHRvIHByaW9yaXRpemUgdGhlIGhhbmRsZSBiZWxvdyB0aGUgbW91c2UgY3Vyc29yIG92ZXIgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgaGFuZGxlLFxuICAgIC8vIGJlY2F1c2UgaXQgY291bGQgYmUgdGhhdCB0aGUgY2VudGVyIG9mIGFub3RoZXIgaGFuZGxlIGlzIGNsb3NlciB0byB0aGUgbW91c2UgcG9pbnRlciB0aGFuIHRoZSBoYW5kbGUgYmVsb3cgdGhlIGN1cnNvclxuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgZG9tTm9kZXMgPSBkb2MuZWxlbWVudHNGcm9tUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgaGFuZGxlQmVsb3cgPSBkb21Ob2Rlcy5maW5kKChlbCkgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdyZWFjdC1mbG93X19oYW5kbGUnKSk7XG4gICAgaWYgKGhhbmRsZUJlbG93KSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZU5vZGVJZCA9IGhhbmRsZUJlbG93LmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKTtcbiAgICAgICAgaWYgKGhhbmRsZU5vZGVJZCkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUodW5kZWZpbmVkLCBoYW5kbGVCZWxvdyk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVJZCA9IGhhbmRsZUJlbG93LmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVpZCcpO1xuICAgICAgICAgICAgY29uc3QgdmFsaWRIYW5kbGVSZXN1bHQgPSB2YWxpZGF0b3IoeyBub2RlSWQ6IGhhbmRsZU5vZGVJZCwgaWQ6IGhhbmRsZUlkLCB0eXBlOiBoYW5kbGVUeXBlIH0pO1xuICAgICAgICAgICAgaWYgKHZhbGlkSGFuZGxlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gaGFuZGxlcy5maW5kKChoKSA9PiBoLm5vZGVJZCA9PT0gaGFuZGxlTm9kZUlkICYmIGgudHlwZSA9PT0gaGFuZGxlVHlwZSAmJiBoLmlkID09PSBoYW5kbGVJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBoYW5kbGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkOiBoYW5kbGVOb2RlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBoYW5kbGU/LnggfHwgcG9zLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBoYW5kbGU/LnkgfHwgcG9zLnksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkSGFuZGxlUmVzdWx0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgd2UgY291bGRuJ3QgZmluZCBhIGhhbmRsZSBiZWxvdyB0aGUgbW91c2UgY3Vyc29yIHdlIGxvb2sgZm9yIHRoZSBjbG9zZXN0IGRpc3RhbmNlIGJhc2VkIG9uIHRoZSBjb25uZWN0aW9uUmFkaXVzXG4gICAgbGV0IGNsb3Nlc3RIYW5kbGVzID0gW107XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgaGFuZGxlcy5mb3JFYWNoKChoYW5kbGUpID0+IHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoKGhhbmRsZS54IC0gcG9zLngpICoqIDIgKyAoaGFuZGxlLnkgLSBwb3MueSkgKiogMik7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8PSBjb25uZWN0aW9uUmFkaXVzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZEhhbmRsZVJlc3VsdCA9IHZhbGlkYXRvcihoYW5kbGUpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDw9IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEhhbmRsZXMgPSBbeyBoYW5kbGUsIHZhbGlkSGFuZGxlUmVzdWx0IH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBtdWx0aXBsZSBoYW5kbGVzIGFyZSBvbiB0aGUgc2FtZSBkaXN0YW5jZSB3ZSBjb2xsZWN0IGFsbCBvZiB0aGVtXG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RIYW5kbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRIYW5kbGVSZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFjbG9zZXN0SGFuZGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHsgaGFuZGxlOiBudWxsLCB2YWxpZEhhbmRsZVJlc3VsdDogZGVmYXVsdFJlc3VsdCgpIH07XG4gICAgfVxuICAgIGlmIChjbG9zZXN0SGFuZGxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RIYW5kbGVzWzBdO1xuICAgIH1cbiAgICBjb25zdCBoYXNWYWxpZEhhbmRsZSA9IGNsb3Nlc3RIYW5kbGVzLnNvbWUoKHsgdmFsaWRIYW5kbGVSZXN1bHQgfSkgPT4gdmFsaWRIYW5kbGVSZXN1bHQuaXNWYWxpZCk7XG4gICAgY29uc3QgaGFzVGFyZ2V0SGFuZGxlID0gY2xvc2VzdEhhbmRsZXMuc29tZSgoeyBoYW5kbGUgfSkgPT4gaGFuZGxlLnR5cGUgPT09ICd0YXJnZXQnKTtcbiAgICAvLyBpZiBtdWx0aXBsZSBoYW5kbGVzIGFyZSBsYXlvdXRlZCBvbiB0b3Agb2YgZWFjaCBvdGhlciB3ZSBwcmVmZXIgdGhlIG9uZSB3aXRoIHR5cGUgPSB0YXJnZXQgYW5kIHRoZSBvbmUgdGhhdCBpcyB2YWxpZFxuICAgIHJldHVybiAoY2xvc2VzdEhhbmRsZXMuZmluZCgoeyBoYW5kbGUsIHZhbGlkSGFuZGxlUmVzdWx0IH0pID0+IGhhc1RhcmdldEhhbmRsZSA/IGhhbmRsZS50eXBlID09PSAndGFyZ2V0JyA6IChoYXNWYWxpZEhhbmRsZSA/IHZhbGlkSGFuZGxlUmVzdWx0LmlzVmFsaWQgOiB0cnVlKSkgfHwgY2xvc2VzdEhhbmRsZXNbMF0pO1xufVxuY29uc3QgbnVsbENvbm5lY3Rpb24gPSB7IHNvdXJjZTogbnVsbCwgdGFyZ2V0OiBudWxsLCBzb3VyY2VIYW5kbGU6IG51bGwsIHRhcmdldEhhbmRsZTogbnVsbCB9O1xuY29uc3QgZGVmYXVsdFJlc3VsdCA9ICgpID0+ICh7XG4gICAgaGFuZGxlRG9tTm9kZTogbnVsbCxcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICBjb25uZWN0aW9uOiBudWxsQ29ubmVjdGlvbixcbiAgICBlbmRIYW5kbGU6IG51bGwsXG59KTtcbi8vIGNoZWNrcyBpZiAgYW5kIHJldHVybnMgY29ubmVjdGlvbiBpbiBmb20gb2YgYW4gb2JqZWN0IHsgc291cmNlOiAxMjMsIHRhcmdldDogMzEyIH1cbmZ1bmN0aW9uIGlzVmFsaWRIYW5kbGUoaGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgZnJvbU5vZGVJZCwgZnJvbUhhbmRsZUlkLCBmcm9tVHlwZSwgaXNWYWxpZENvbm5lY3Rpb24sIGRvYykge1xuICAgIGNvbnN0IGlzVGFyZ2V0ID0gZnJvbVR5cGUgPT09ICd0YXJnZXQnO1xuICAgIGNvbnN0IGhhbmRsZVRvQ2hlY2sgPSBkb2MucXVlcnlTZWxlY3RvcihgLnJlYWN0LWZsb3dfX2hhbmRsZVtkYXRhLWlkPVwiJHtoYW5kbGU/Lm5vZGVJZH0tJHtoYW5kbGU/LmlkfS0ke2hhbmRsZT8udHlwZX1cIl1gKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRSZXN1bHQoKSxcbiAgICAgICAgaGFuZGxlRG9tTm9kZTogaGFuZGxlVG9DaGVjayxcbiAgICB9O1xuICAgIGlmIChoYW5kbGVUb0NoZWNrKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZVR5cGUgPSBnZXRIYW5kbGVUeXBlKHVuZGVmaW5lZCwgaGFuZGxlVG9DaGVjayk7XG4gICAgICAgIGNvbnN0IGhhbmRsZU5vZGVJZCA9IGhhbmRsZVRvQ2hlY2suZ2V0QXR0cmlidXRlKCdkYXRhLW5vZGVpZCcpO1xuICAgICAgICBjb25zdCBoYW5kbGVJZCA9IGhhbmRsZVRvQ2hlY2suZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZWlkJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RhYmxlID0gaGFuZGxlVG9DaGVjay5jbGFzc0xpc3QuY29udGFpbnMoJ2Nvbm5lY3RhYmxlJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RhYmxlRW5kID0gaGFuZGxlVG9DaGVjay5jbGFzc0xpc3QuY29udGFpbnMoJ2Nvbm5lY3RhYmxlZW5kJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICBzb3VyY2U6IGlzVGFyZ2V0ID8gaGFuZGxlTm9kZUlkIDogZnJvbU5vZGVJZCxcbiAgICAgICAgICAgIHNvdXJjZUhhbmRsZTogaXNUYXJnZXQgPyBoYW5kbGVJZCA6IGZyb21IYW5kbGVJZCxcbiAgICAgICAgICAgIHRhcmdldDogaXNUYXJnZXQgPyBmcm9tTm9kZUlkIDogaGFuZGxlTm9kZUlkLFxuICAgICAgICAgICAgdGFyZ2V0SGFuZGxlOiBpc1RhcmdldCA/IGZyb21IYW5kbGVJZCA6IGhhbmRsZUlkLFxuICAgICAgICB9O1xuICAgICAgICByZXN1bHQuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGFibGUgPSBjb25uZWN0YWJsZSAmJiBjb25uZWN0YWJsZUVuZDtcbiAgICAgICAgLy8gaW4gc3RyaWN0IG1vZGUgd2UgZG9uJ3QgYWxsb3cgdGFyZ2V0IHRvIHRhcmdldCBvciBzb3VyY2UgdG8gc291cmNlIGNvbm5lY3Rpb25zXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBpc0Nvbm5lY3RhYmxlICYmXG4gICAgICAgICAgICAoY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICAgICAgICAgID8gKGlzVGFyZ2V0ICYmIGhhbmRsZVR5cGUgPT09ICdzb3VyY2UnKSB8fCAoIWlzVGFyZ2V0ICYmIGhhbmRsZVR5cGUgPT09ICd0YXJnZXQnKVxuICAgICAgICAgICAgICAgIDogaGFuZGxlTm9kZUlkICE9PSBmcm9tTm9kZUlkIHx8IGhhbmRsZUlkICE9PSBmcm9tSGFuZGxlSWQpO1xuICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZEhhbmRsZSA9IHtcbiAgICAgICAgICAgICAgICBub2RlSWQ6IGhhbmRsZU5vZGVJZCxcbiAgICAgICAgICAgICAgICBoYW5kbGVJZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBoYW5kbGVUeXBlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdC5pc1ZhbGlkID0gaXNWYWxpZENvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZUxvb2t1cCh7IG5vZGVzLCBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlIH0pIHtcbiAgICByZXR1cm4gbm9kZXMucmVkdWNlKChyZXMsIG5vZGUpID0+IHtcbiAgICAgICAgaWYgKG5vZGVbaW50ZXJuYWxzU3ltYm9sXSkge1xuICAgICAgICAgICAgY29uc3QgeyBoYW5kbGVCb3VuZHMgfSA9IG5vZGVbaW50ZXJuYWxzU3ltYm9sXTtcbiAgICAgICAgICAgIGxldCBzb3VyY2VIYW5kbGVzID0gW107XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SGFuZGxlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGhhbmRsZUJvdW5kcykge1xuICAgICAgICAgICAgICAgIHNvdXJjZUhhbmRsZXMgPSBnZXRIYW5kbGVzKG5vZGUsIGhhbmRsZUJvdW5kcywgJ3NvdXJjZScsIGAke25vZGVJZH0tJHtoYW5kbGVJZH0tJHtoYW5kbGVUeXBlfWApO1xuICAgICAgICAgICAgICAgIHRhcmdldEhhbmRsZXMgPSBnZXRIYW5kbGVzKG5vZGUsIGhhbmRsZUJvdW5kcywgJ3RhcmdldCcsIGAke25vZGVJZH0tJHtoYW5kbGVJZH0tJHtoYW5kbGVUeXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnB1c2goLi4uc291cmNlSGFuZGxlcywgLi4udGFyZ2V0SGFuZGxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCBbXSk7XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVUeXBlKGVkZ2VVcGRhdGVyVHlwZSwgaGFuZGxlRG9tTm9kZSkge1xuICAgIGlmIChlZGdlVXBkYXRlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VVcGRhdGVyVHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlRG9tTm9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXJnZXQnKSkge1xuICAgICAgICByZXR1cm4gJ3RhcmdldCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbmRsZURvbU5vZGU/LmNsYXNzTGlzdC5jb250YWlucygnc291cmNlJykpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2UnO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc2V0UmVjZW50SGFuZGxlKGhhbmRsZURvbU5vZGUpIHtcbiAgICBoYW5kbGVEb21Ob2RlPy5jbGFzc0xpc3QucmVtb3ZlKCd2YWxpZCcsICdjb25uZWN0aW5nJywgJ3JlYWN0LWZsb3dfX2hhbmRsZS12YWxpZCcsICdyZWFjdC1mbG93X19oYW5kbGUtY29ubmVjdGluZycpO1xufVxuZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblN0YXR1cyhpc0luc2lkZUNvbm5lY3Rpb25SYWRpdXMsIGlzSGFuZGxlVmFsaWQpIHtcbiAgICBsZXQgY29ubmVjdGlvblN0YXR1cyA9IG51bGw7XG4gICAgaWYgKGlzSGFuZGxlVmFsaWQpIHtcbiAgICAgICAgY29ubmVjdGlvblN0YXR1cyA9ICd2YWxpZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSW5zaWRlQ29ubmVjdGlvblJhZGl1cyAmJiAhaXNIYW5kbGVWYWxpZCkge1xuICAgICAgICBjb25uZWN0aW9uU3RhdHVzID0gJ2ludmFsaWQnO1xuICAgIH1cbiAgICByZXR1cm4gY29ubmVjdGlvblN0YXR1cztcbn1cblxuZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oeyBldmVudCwgaGFuZGxlSWQsIG5vZGVJZCwgb25Db25uZWN0LCBpc1RhcmdldCwgZ2V0U3RhdGUsIHNldFN0YXRlLCBpc1ZhbGlkQ29ubmVjdGlvbiwgZWRnZVVwZGF0ZXJUeXBlLCBvbkVkZ2VVcGRhdGVFbmQsIH0pIHtcbiAgICAvLyB3aGVuIHJlYWN0LWZsb3cgaXMgdXNlZCBpbnNpZGUgYSBzaGFkb3cgcm9vdCB3ZSBjYW4ndCB1c2UgZG9jdW1lbnRcbiAgICBjb25zdCBkb2MgPSBnZXRIb3N0Rm9yRWxlbWVudChldmVudC50YXJnZXQpO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbk1vZGUsIGRvbU5vZGUsIGF1dG9QYW5PbkNvbm5lY3QsIGNvbm5lY3Rpb25SYWRpdXMsIG9uQ29ubmVjdFN0YXJ0LCBwYW5CeSwgZ2V0Tm9kZXMsIGNhbmNlbENvbm5lY3Rpb24sIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGxldCBhdXRvUGFuSWQgPSAwO1xuICAgIGxldCBjbG9zZXN0SGFuZGxlO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgY2xpY2tlZEhhbmRsZSA9IGRvYz8uZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICBjb25zdCBoYW5kbGVUeXBlID0gZ2V0SGFuZGxlVHlwZShlZGdlVXBkYXRlclR5cGUsIGNsaWNrZWRIYW5kbGUpO1xuICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICghY29udGFpbmVyQm91bmRzIHx8ICFoYW5kbGVUeXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHByZXZBY3RpdmVIYW5kbGU7XG4gICAgbGV0IGNvbm5lY3Rpb25Qb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgbGV0IGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IGNvbm5lY3Rpb24gPSBudWxsO1xuICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG4gICAgbGV0IGhhbmRsZURvbU5vZGUgPSBudWxsO1xuICAgIGNvbnN0IGhhbmRsZUxvb2t1cCA9IGdldEhhbmRsZUxvb2t1cCh7XG4gICAgICAgIG5vZGVzOiBnZXROb2RlcygpLFxuICAgICAgICBub2RlSWQsXG4gICAgICAgIGhhbmRsZUlkLFxuICAgICAgICBoYW5kbGVUeXBlLFxuICAgIH0pO1xuICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgbW92aW5nIHRoZSBtb3VzZSBjbG9zZSB0byB0aGUgZWRnZSBvZiB0aGUgY2FudmFzIHdoaWxlIGNvbm5lY3Rpbmcgd2UgbW92ZSB0aGUgY2FudmFzXG4gICAgY29uc3QgYXV0b1BhbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFhdXRvUGFuT25Db25uZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3hNb3ZlbWVudCwgeU1vdmVtZW50XSA9IGNhbGNBdXRvUGFuKGNvbm5lY3Rpb25Qb3NpdGlvbiwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgcGFuQnkoeyB4OiB4TW92ZW1lbnQsIHk6IHlNb3ZlbWVudCB9KTtcbiAgICAgICAgYXV0b1BhbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9QYW4pO1xuICAgIH07XG4gICAgc2V0U3RhdGUoe1xuICAgICAgICBjb25uZWN0aW9uUG9zaXRpb24sXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6IG51bGwsXG4gICAgICAgIC8vIGNvbm5lY3Rpb25Ob2RlSWQgZXRjIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciBpbiBmYXZvciBvZiBjb25uZWN0aW9uU3RhcnRIYW5kbGVcbiAgICAgICAgY29ubmVjdGlvbk5vZGVJZDogbm9kZUlkLFxuICAgICAgICBjb25uZWN0aW9uSGFuZGxlSWQ6IGhhbmRsZUlkLFxuICAgICAgICBjb25uZWN0aW9uSGFuZGxlVHlwZTogaGFuZGxlVHlwZSxcbiAgICAgICAgY29ubmVjdGlvblN0YXJ0SGFuZGxlOiB7XG4gICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICBoYW5kbGVJZCxcbiAgICAgICAgICAgIHR5cGU6IGhhbmRsZVR5cGUsXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3Rpb25FbmRIYW5kbGU6IG51bGwsXG4gICAgfSk7XG4gICAgb25Db25uZWN0U3RhcnQ/LihldmVudCwgeyBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlIH0pO1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0gfSA9IGdldFN0YXRlKCk7XG4gICAgICAgIGNvbm5lY3Rpb25Qb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgIGNvbnN0IHsgaGFuZGxlLCB2YWxpZEhhbmRsZVJlc3VsdCB9ID0gZ2V0Q2xvc2VzdEhhbmRsZShldmVudCwgZG9jLCBwb2ludFRvUmVuZGVyZXJQb2ludChjb25uZWN0aW9uUG9zaXRpb24sIHRyYW5zZm9ybSwgZmFsc2UsIFsxLCAxXSksIGNvbm5lY3Rpb25SYWRpdXMsIGhhbmRsZUxvb2t1cCwgKGhhbmRsZSkgPT4gaXNWYWxpZEhhbmRsZShoYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBub2RlSWQsIGhhbmRsZUlkLCBpc1RhcmdldCA/ICd0YXJnZXQnIDogJ3NvdXJjZScsIGlzVmFsaWRDb25uZWN0aW9uLCBkb2MpKTtcbiAgICAgICAgY2xvc2VzdEhhbmRsZSA9IGhhbmRsZTtcbiAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZCkge1xuICAgICAgICAgICAgYXV0b1BhbigpO1xuICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZURvbU5vZGUgPSB2YWxpZEhhbmRsZVJlc3VsdC5oYW5kbGVEb21Ob2RlO1xuICAgICAgICBjb25uZWN0aW9uID0gdmFsaWRIYW5kbGVSZXN1bHQuY29ubmVjdGlvbjtcbiAgICAgICAgaXNWYWxpZCA9IHZhbGlkSGFuZGxlUmVzdWx0LmlzVmFsaWQ7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qb3NpdGlvbjogY2xvc2VzdEhhbmRsZSAmJiBpc1ZhbGlkXG4gICAgICAgICAgICAgICAgPyByZW5kZXJlclBvaW50VG9Qb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNsb3Nlc3RIYW5kbGUueCxcbiAgICAgICAgICAgICAgICAgICAgeTogY2xvc2VzdEhhbmRsZS55LFxuICAgICAgICAgICAgICAgIH0sIHRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICA6IGNvbm5lY3Rpb25Qb3NpdGlvbixcbiAgICAgICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6IGdldENvbm5lY3Rpb25TdGF0dXMoISFjbG9zZXN0SGFuZGxlLCBpc1ZhbGlkKSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25FbmRIYW5kbGU6IHZhbGlkSGFuZGxlUmVzdWx0LmVuZEhhbmRsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2xvc2VzdEhhbmRsZSAmJiAhaXNWYWxpZCAmJiAhaGFuZGxlRG9tTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0UmVjZW50SGFuZGxlKHByZXZBY3RpdmVIYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnNvdXJjZSAhPT0gY29ubmVjdGlvbi50YXJnZXQgJiYgaGFuZGxlRG9tTm9kZSkge1xuICAgICAgICAgICAgcmVzZXRSZWNlbnRIYW5kbGUocHJldkFjdGl2ZUhhbmRsZSk7XG4gICAgICAgICAgICBwcmV2QWN0aXZlSGFuZGxlID0gaGFuZGxlRG9tTm9kZTtcbiAgICAgICAgICAgIC8vIEB0b2RvOiByZW1vdmUgdGhlIG9sZCBjbGFzcyBuYW1lcyBcInJlYWN0LWZsb3dfX2hhbmRsZS1cIiBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgICAgICAgICBoYW5kbGVEb21Ob2RlLmNsYXNzTGlzdC5hZGQoJ2Nvbm5lY3RpbmcnLCAncmVhY3QtZmxvd19faGFuZGxlLWNvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgIGhhbmRsZURvbU5vZGUuY2xhc3NMaXN0LnRvZ2dsZSgndmFsaWQnLCBpc1ZhbGlkKTtcbiAgICAgICAgICAgIGhhbmRsZURvbU5vZGUuY2xhc3NMaXN0LnRvZ2dsZSgncmVhY3QtZmxvd19faGFuZGxlLXZhbGlkJywgaXNWYWxpZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyVXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKChjbG9zZXN0SGFuZGxlIHx8IGhhbmRsZURvbU5vZGUpICYmIGNvbm5lY3Rpb24gJiYgaXNWYWxpZCkge1xuICAgICAgICAgICAgb25Db25uZWN0Py4oY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQncyBpbXBvcnRhbnQgdG8gZ2V0IGEgZnJlc2ggcmVmZXJlbmNlIGZyb20gdGhlIHN0b3JlIGhlcmVcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gZ2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2Ygb25Db25uZWN0RW5kXG4gICAgICAgIGdldFN0YXRlKCkub25Db25uZWN0RW5kPy4oZXZlbnQpO1xuICAgICAgICBpZiAoZWRnZVVwZGF0ZXJUeXBlKSB7XG4gICAgICAgICAgICBvbkVkZ2VVcGRhdGVFbmQ/LihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXRSZWNlbnRIYW5kbGUocHJldkFjdGl2ZUhhbmRsZSk7XG4gICAgICAgIGNhbmNlbENvbm5lY3Rpb24oKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkKTtcbiAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBjb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgaGFuZGxlRG9tTm9kZSA9IG51bGw7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblBvaW50ZXJVcCk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Qb2ludGVyVXApO1xuICAgIH1cbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblBvaW50ZXJVcCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uUG9pbnRlclVwKTtcbn1cblxuY29uc3QgYWx3YXlzVmFsaWQgPSAoKSA9PiB0cnVlO1xuY29uc3Qgc2VsZWN0b3IkZiA9IChzKSA9PiAoe1xuICAgIGNvbm5lY3Rpb25TdGFydEhhbmRsZTogcy5jb25uZWN0aW9uU3RhcnRIYW5kbGUsXG4gICAgY29ubmVjdE9uQ2xpY2s6IHMuY29ubmVjdE9uQ2xpY2ssXG4gICAgbm9QYW5DbGFzc05hbWU6IHMubm9QYW5DbGFzc05hbWUsXG59KTtcbmNvbnN0IGNvbm5lY3RpbmdTZWxlY3RvciA9IChub2RlSWQsIGhhbmRsZUlkLCB0eXBlKSA9PiAoc3RhdGUpID0+IHtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25TdGFydEhhbmRsZTogc3RhcnRIYW5kbGUsIGNvbm5lY3Rpb25FbmRIYW5kbGU6IGVuZEhhbmRsZSwgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IGNsaWNrSGFuZGxlLCB9ID0gc3RhdGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29ubmVjdGluZzogKHN0YXJ0SGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBzdGFydEhhbmRsZT8uaGFuZGxlSWQgPT09IGhhbmRsZUlkICYmIHN0YXJ0SGFuZGxlPy50eXBlID09PSB0eXBlKSB8fFxuICAgICAgICAgICAgKGVuZEhhbmRsZT8ubm9kZUlkID09PSBub2RlSWQgJiYgZW5kSGFuZGxlPy5oYW5kbGVJZCA9PT0gaGFuZGxlSWQgJiYgZW5kSGFuZGxlPy50eXBlID09PSB0eXBlKSxcbiAgICAgICAgY2xpY2tDb25uZWN0aW5nOiBjbGlja0hhbmRsZT8ubm9kZUlkID09PSBub2RlSWQgJiYgY2xpY2tIYW5kbGU/LmhhbmRsZUlkID09PSBoYW5kbGVJZCAmJiBjbGlja0hhbmRsZT8udHlwZSA9PT0gdHlwZSxcbiAgICB9O1xufTtcbmNvbnN0IEhhbmRsZSA9IGZvcndhcmRSZWYoKHsgdHlwZSA9ICdzb3VyY2UnLCBwb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgaXNWYWxpZENvbm5lY3Rpb24sIGlzQ29ubmVjdGFibGUgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlU3RhcnQgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlRW5kID0gdHJ1ZSwgaWQsIG9uQ29ubmVjdCwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgb25Nb3VzZURvd24sIG9uVG91Y2hTdGFydCwgLi4ucmVzdCB9LCByZWYpID0+IHtcbiAgICBjb25zdCBoYW5kbGVJZCA9IGlkIHx8IG51bGw7XG4gICAgY29uc3QgaXNUYXJnZXQgPSB0eXBlID09PSAndGFyZ2V0JztcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgeyBjb25uZWN0T25DbGljaywgbm9QYW5DbGFzc05hbWUgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGYsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHsgY29ubmVjdGluZywgY2xpY2tDb25uZWN0aW5nIH0gPSB1c2VTdG9yZShjb25uZWN0aW5nU2VsZWN0b3Iobm9kZUlkLCBoYW5kbGVJZCwgdHlwZSksIHNoYWxsb3cpO1xuICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMTAnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMCddKCkpO1xuICAgIH1cbiAgICBjb25zdCBvbkNvbm5lY3RFeHRlbmRlZCA9IChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0RWRnZU9wdGlvbnMsIG9uQ29ubmVjdDogb25Db25uZWN0QWN0aW9uLCBoYXNEZWZhdWx0RWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGVkZ2VQYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi5kZWZhdWx0RWRnZU9wdGlvbnMsXG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIHNldEVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgc2V0RWRnZXMoYWRkRWRnZShlZGdlUGFyYW1zLCBlZGdlcykpO1xuICAgICAgICB9XG4gICAgICAgIG9uQ29ubmVjdEFjdGlvbj8uKGVkZ2VQYXJhbXMpO1xuICAgICAgICBvbkNvbm5lY3Q/LihlZGdlUGFyYW1zKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc01vdXNlVHJpZ2dlcmVkID0gaXNNb3VzZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgaWYgKGlzQ29ubmVjdGFibGVTdGFydCAmJiAoKGlzTW91c2VUcmlnZ2VyZWQgJiYgZXZlbnQuYnV0dG9uID09PSAwKSB8fCAhaXNNb3VzZVRyaWdnZXJlZCkpIHtcbiAgICAgICAgICAgIGhhbmRsZVBvaW50ZXJEb3duKHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBoYW5kbGVJZCxcbiAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgb25Db25uZWN0OiBvbkNvbm5lY3RFeHRlbmRlZCxcbiAgICAgICAgICAgICAgICBpc1RhcmdldCxcbiAgICAgICAgICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgICAgICAgICAgc2V0U3RhdGU6IHN0b3JlLnNldFN0YXRlLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBzdG9yZS5nZXRTdGF0ZSgpLmlzVmFsaWRDb25uZWN0aW9uIHx8IGFsd2F5c1ZhbGlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTW91c2VUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIG9uTW91c2VEb3duPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0Py4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25DbGlja0Nvbm5lY3RTdGFydCwgb25DbGlja0Nvbm5lY3RFbmQsIGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uU3RvcmUsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIW5vZGVJZCB8fCAoIWNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlICYmICFpc0Nvbm5lY3RhYmxlU3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSkge1xuICAgICAgICAgICAgb25DbGlja0Nvbm5lY3RTdGFydD8uKGV2ZW50LCB7IG5vZGVJZCwgaGFuZGxlSWQsIGhhbmRsZVR5cGU6IHR5cGUgfSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiB7IG5vZGVJZCwgdHlwZSwgaGFuZGxlSWQgfSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2MgPSBnZXRIb3N0Rm9yRWxlbWVudChldmVudC50YXJnZXQpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkQ29ubmVjdGlvbkhhbmRsZXIgPSBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBpc1ZhbGlkQ29ubmVjdGlvblN0b3JlIHx8IGFsd2F5c1ZhbGlkO1xuICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb24sIGlzVmFsaWQgfSA9IGlzVmFsaWRIYW5kbGUoe1xuICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgaWQ6IGhhbmRsZUlkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgfSwgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLm5vZGVJZCwgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUuaGFuZGxlSWQgfHwgbnVsbCwgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUudHlwZSwgaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyLCBkb2MpO1xuICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgb25Db25uZWN0RXh0ZW5kZWQoY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgb25DbGlja0Nvbm5lY3RFbmQ/LihldmVudCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtaGFuZGxlaWRcIjogaGFuZGxlSWQsIFwiZGF0YS1ub2RlaWRcIjogbm9kZUlkLCBcImRhdGEtaGFuZGxlcG9zXCI6IHBvc2l0aW9uLCBcImRhdGEtaWRcIjogYCR7bm9kZUlkfS0ke2hhbmRsZUlkfS0ke3R5cGV9YCwgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAncmVhY3QtZmxvd19faGFuZGxlJyxcbiAgICAgICAgICAgIGByZWFjdC1mbG93X19oYW5kbGUtJHtwb3NpdGlvbn1gLFxuICAgICAgICAgICAgJ25vZHJhZycsXG4gICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICFpc1RhcmdldCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlc3RhcnQ6IGlzQ29ubmVjdGFibGVTdGFydCxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZWVuZDogaXNDb25uZWN0YWJsZUVuZCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW5nOiBjbGlja0Nvbm5lY3RpbmcsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjbGFzcyBpcyB1c2VkIHRvIHN0eWxlIHRoZSBoYW5kbGUgd2hlbiB0aGUgdXNlciBpcyBjb25uZWN0aW5nXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbmluZGljYXRvcjogaXNDb25uZWN0YWJsZSAmJiAoKGlzQ29ubmVjdGFibGVTdGFydCAmJiAhY29ubmVjdGluZykgfHwgKGlzQ29ubmVjdGFibGVFbmQgJiYgY29ubmVjdGluZykpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSksIG9uTW91c2VEb3duOiBvblBvaW50ZXJEb3duLCBvblRvdWNoU3RhcnQ6IG9uUG9pbnRlckRvd24sIG9uQ2xpY2s6IGNvbm5lY3RPbkNsaWNrID8gb25DbGljayA6IHVuZGVmaW5lZCwgcmVmOiByZWYsIC4uLnJlc3QgfSwgY2hpbGRyZW4pKTtcbn0pO1xuSGFuZGxlLmRpc3BsYXlOYW1lID0gJ0hhbmRsZSc7XG52YXIgSGFuZGxlJDEgPSBtZW1vKEhhbmRsZSk7XG5cbmNvbnN0IERlZmF1bHROb2RlID0gKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB9KSA9PiB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEhhbmRsZSQxLCB7IHR5cGU6IFwidGFyZ2V0XCIsIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSxcbiAgICAgICAgZGF0YT8ubGFiZWwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGFuZGxlJDEsIHsgdHlwZTogXCJzb3VyY2VcIiwgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pKSk7XG59O1xuRGVmYXVsdE5vZGUuZGlzcGxheU5hbWUgPSAnRGVmYXVsdE5vZGUnO1xudmFyIERlZmF1bHROb2RlJDEgPSBtZW1vKERlZmF1bHROb2RlKTtcblxuY29uc3QgSW5wdXROb2RlID0gKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20gfSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgZGF0YT8ubGFiZWwsXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChIYW5kbGUkMSwgeyB0eXBlOiBcInNvdXJjZVwiLCBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSkpKTtcbklucHV0Tm9kZS5kaXNwbGF5TmFtZSA9ICdJbnB1dE5vZGUnO1xudmFyIElucHV0Tm9kZSQxID0gbWVtbyhJbnB1dE5vZGUpO1xuXG5jb25zdCBPdXRwdXROb2RlID0gKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AgfSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChIYW5kbGUkMSwgeyB0eXBlOiBcInRhcmdldFwiLCBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSksXG4gICAgZGF0YT8ubGFiZWwpKTtcbk91dHB1dE5vZGUuZGlzcGxheU5hbWUgPSAnT3V0cHV0Tm9kZSc7XG52YXIgT3V0cHV0Tm9kZSQxID0gbWVtbyhPdXRwdXROb2RlKTtcblxuY29uc3QgR3JvdXBOb2RlID0gKCkgPT4gbnVsbDtcbkdyb3VwTm9kZS5kaXNwbGF5TmFtZSA9ICdHcm91cE5vZGUnO1xuXG5jb25zdCBzZWxlY3RvciRlID0gKHMpID0+ICh7XG4gICAgc2VsZWN0ZWROb2Rlczogcy5nZXROb2RlcygpLmZpbHRlcigobikgPT4gbi5zZWxlY3RlZCksXG4gICAgc2VsZWN0ZWRFZGdlczogcy5lZGdlcy5maWx0ZXIoKGUpID0+IGUuc2VsZWN0ZWQpLFxufSk7XG5jb25zdCBzZWxlY3RJZCA9IChvYmopID0+IG9iai5pZDtcbmZ1bmN0aW9uIGFyZUVxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gKHNoYWxsb3coYS5zZWxlY3RlZE5vZGVzLm1hcChzZWxlY3RJZCksIGIuc2VsZWN0ZWROb2Rlcy5tYXAoc2VsZWN0SWQpKSAmJlxuICAgICAgICBzaGFsbG93KGEuc2VsZWN0ZWRFZGdlcy5tYXAoc2VsZWN0SWQpLCBiLnNlbGVjdGVkRWRnZXMubWFwKHNlbGVjdElkKSkpO1xufVxuLy8gVGhpcyBpcyBqdXN0IGEgaGVscGVyIGNvbXBvbmVudCBmb3IgY2FsbGluZyB0aGUgb25TZWxlY3Rpb25DaGFuZ2UgbGlzdGVuZXIuXG4vLyBAVE9ETzogTm93IHRoYXQgd2UgaGF2ZSB0aGUgb25Ob2Rlc0NoYW5nZSBhbmQgb24gRWRnZXNDaGFuZ2UgbGlzdGVuZXJzLCBkbyB3ZSBzdGlsbCBuZWVkIHRoaXMgY29tcG9uZW50P1xuY29uc3QgU2VsZWN0aW9uTGlzdGVuZXIgPSBtZW1vKCh7IG9uU2VsZWN0aW9uQ2hhbmdlIH0pID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyBzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzIH0gPSB1c2VTdG9yZShzZWxlY3RvciRlLCBhcmVFcXVhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0geyBub2Rlczogc2VsZWN0ZWROb2RlcywgZWRnZXM6IHNlbGVjdGVkRWRnZXMgfTtcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U/LihwYXJhbXMpO1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlLmZvckVhY2goKGZuKSA9PiBmbihwYXJhbXMpKTtcbiAgICB9LCBbc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcywgb25TZWxlY3Rpb25DaGFuZ2VdKTtcbiAgICByZXR1cm4gbnVsbDtcbn0pO1xuU2VsZWN0aW9uTGlzdGVuZXIuZGlzcGxheU5hbWUgPSAnU2VsZWN0aW9uTGlzdGVuZXInO1xuY29uc3QgY2hhbmdlU2VsZWN0b3IgPSAocykgPT4gISFzLm9uU2VsZWN0aW9uQ2hhbmdlO1xuZnVuY3Rpb24gV3JhcHBlciQxKHsgb25TZWxlY3Rpb25DaGFuZ2UgfSkge1xuICAgIGNvbnN0IHN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlID0gdXNlU3RvcmUoY2hhbmdlU2VsZWN0b3IpO1xuICAgIGlmIChvblNlbGVjdGlvbkNoYW5nZSB8fCBzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZSkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTZWxlY3Rpb25MaXN0ZW5lciwgeyBvblNlbGVjdGlvbkNoYW5nZTogb25TZWxlY3Rpb25DaGFuZ2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBzZWxlY3RvciRkID0gKHMpID0+ICh7XG4gICAgc2V0Tm9kZXM6IHMuc2V0Tm9kZXMsXG4gICAgc2V0RWRnZXM6IHMuc2V0RWRnZXMsXG4gICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXM6IHMuc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsXG4gICAgc2V0TWluWm9vbTogcy5zZXRNaW5ab29tLFxuICAgIHNldE1heFpvb206IHMuc2V0TWF4Wm9vbSxcbiAgICBzZXRUcmFuc2xhdGVFeHRlbnQ6IHMuc2V0VHJhbnNsYXRlRXh0ZW50LFxuICAgIHNldE5vZGVFeHRlbnQ6IHMuc2V0Tm9kZUV4dGVudCxcbiAgICByZXNldDogcy5yZXNldCxcbn0pO1xuZnVuY3Rpb24gdXNlU3RvcmVVcGRhdGVyKHZhbHVlLCBzZXRTdG9yZVN0YXRlKSB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNldFN0b3JlU3RhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW3ZhbHVlXSk7XG59XG4vLyB1cGRhdGVzIHdpdGggdmFsdWVzIGluIHN0b3JlIHRoYXQgZG9uJ3QgaGF2ZSBhIGRlZGljYXRlZCBzZXR0ZXIgZnVuY3Rpb25cbmZ1bmN0aW9uIHVzZURpcmVjdFN0b3JlVXBkYXRlcihrZXksIHZhbHVlLCBzZXRTdGF0ZSkge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFt2YWx1ZV0pO1xufVxuY29uc3QgU3RvcmVVcGRhdGVyID0gKHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgb25Db25uZWN0LCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kLCBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNVcGRhdGFibGUsIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBtaW5ab29tLCBtYXhab29tLCBub2RlRXh0ZW50LCBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlLCBlbGVtZW50c1NlbGVjdGFibGUsIGNvbm5lY3Rpb25Nb2RlLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgdHJhbnNsYXRlRXh0ZW50LCBjb25uZWN0T25DbGljaywgZGVmYXVsdEVkZ2VPcHRpb25zLCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZSwgb25Ob2RlRHJhZywgb25Ob2RlRHJhZ1N0YXJ0LCBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RvcCwgbm9QYW5DbGFzc05hbWUsIG5vZGVPcmlnaW4sIHJmSWQsIGF1dG9QYW5PbkNvbm5lY3QsIGF1dG9QYW5Pbk5vZGVEcmFnLCBvbkVycm9yLCBjb25uZWN0aW9uUmFkaXVzLCBpc1ZhbGlkQ29ubmVjdGlvbiwgbm9kZURyYWdUaHJlc2hvbGQsIH0pID0+IHtcbiAgICBjb25zdCB7IHNldE5vZGVzLCBzZXRFZGdlcywgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsIHNldE1pblpvb20sIHNldE1heFpvb20sIHNldFRyYW5zbGF0ZUV4dGVudCwgc2V0Tm9kZUV4dGVudCwgcmVzZXQsIH0gPSB1c2VTdG9yZShzZWxlY3RvciRkLCBzaGFsbG93KTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZWRnZXNXaXRoRGVmYXVsdHMgPSBkZWZhdWx0RWRnZXM/Lm1hcCgoZSkgPT4gKHsgLi4uZSwgLi4uZGVmYXVsdEVkZ2VPcHRpb25zIH0pKTtcbiAgICAgICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMoZGVmYXVsdE5vZGVzLCBlZGdlc1dpdGhEZWZhdWx0cyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ2RlZmF1bHRFZGdlT3B0aW9ucycsIGRlZmF1bHRFZGdlT3B0aW9ucywgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignY29ubmVjdGlvbk1vZGUnLCBjb25uZWN0aW9uTW9kZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25Db25uZWN0Jywgb25Db25uZWN0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbkNvbm5lY3RTdGFydCcsIG9uQ29ubmVjdFN0YXJ0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbkNvbm5lY3RFbmQnLCBvbkNvbm5lY3RFbmQsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uQ2xpY2tDb25uZWN0U3RhcnQnLCBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbkNsaWNrQ29ubmVjdEVuZCcsIG9uQ2xpY2tDb25uZWN0RW5kLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdub2Rlc0RyYWdnYWJsZScsIG5vZGVzRHJhZ2dhYmxlLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdub2Rlc0Nvbm5lY3RhYmxlJywgbm9kZXNDb25uZWN0YWJsZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignbm9kZXNGb2N1c2FibGUnLCBub2Rlc0ZvY3VzYWJsZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignZWRnZXNGb2N1c2FibGUnLCBlZGdlc0ZvY3VzYWJsZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignZWRnZXNVcGRhdGFibGUnLCBlZGdlc1VwZGF0YWJsZSwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignZWxlbWVudHNTZWxlY3RhYmxlJywgZWxlbWVudHNTZWxlY3RhYmxlLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdlbGV2YXRlTm9kZXNPblNlbGVjdCcsIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdzbmFwVG9HcmlkJywgc25hcFRvR3JpZCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignc25hcEdyaWQnLCBzbmFwR3JpZCwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25Ob2Rlc0NoYW5nZScsIG9uTm9kZXNDaGFuZ2UsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uRWRnZXNDaGFuZ2UnLCBvbkVkZ2VzQ2hhbmdlLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdjb25uZWN0T25DbGljaycsIGNvbm5lY3RPbkNsaWNrLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdmaXRWaWV3T25Jbml0JywgZml0Vmlldywgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignZml0Vmlld09uSW5pdE9wdGlvbnMnLCBmaXRWaWV3T3B0aW9ucywgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25Ob2Rlc0RlbGV0ZScsIG9uTm9kZXNEZWxldGUsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uRWRnZXNEZWxldGUnLCBvbkVkZ2VzRGVsZXRlLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbk5vZGVEcmFnJywgb25Ob2RlRHJhZywgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignb25Ob2RlRHJhZ1N0YXJ0Jywgb25Ob2RlRHJhZ1N0YXJ0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbk5vZGVEcmFnU3RvcCcsIG9uTm9kZURyYWdTdG9wLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvblNlbGVjdGlvbkRyYWcnLCBvblNlbGVjdGlvbkRyYWcsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uU2VsZWN0aW9uRHJhZ1N0YXJ0Jywgb25TZWxlY3Rpb25EcmFnU3RhcnQsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ29uU2VsZWN0aW9uRHJhZ1N0b3AnLCBvblNlbGVjdGlvbkRyYWdTdG9wLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdub1BhbkNsYXNzTmFtZScsIG5vUGFuQ2xhc3NOYW1lLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdub2RlT3JpZ2luJywgbm9kZU9yaWdpbiwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcigncmZJZCcsIHJmSWQsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ2F1dG9QYW5PbkNvbm5lY3QnLCBhdXRvUGFuT25Db25uZWN0LCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdhdXRvUGFuT25Ob2RlRHJhZycsIGF1dG9QYW5Pbk5vZGVEcmFnLCBzdG9yZS5zZXRTdGF0ZSk7XG4gICAgdXNlRGlyZWN0U3RvcmVVcGRhdGVyKCdvbkVycm9yJywgb25FcnJvciwgc3RvcmUuc2V0U3RhdGUpO1xuICAgIHVzZURpcmVjdFN0b3JlVXBkYXRlcignY29ubmVjdGlvblJhZGl1cycsIGNvbm5lY3Rpb25SYWRpdXMsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ2lzVmFsaWRDb25uZWN0aW9uJywgaXNWYWxpZENvbm5lY3Rpb24sIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VEaXJlY3RTdG9yZVVwZGF0ZXIoJ25vZGVEcmFnVGhyZXNob2xkJywgbm9kZURyYWdUaHJlc2hvbGQsIHN0b3JlLnNldFN0YXRlKTtcbiAgICB1c2VTdG9yZVVwZGF0ZXIobm9kZXMsIHNldE5vZGVzKTtcbiAgICB1c2VTdG9yZVVwZGF0ZXIoZWRnZXMsIHNldEVkZ2VzKTtcbiAgICB1c2VTdG9yZVVwZGF0ZXIobWluWm9vbSwgc2V0TWluWm9vbSk7XG4gICAgdXNlU3RvcmVVcGRhdGVyKG1heFpvb20sIHNldE1heFpvb20pO1xuICAgIHVzZVN0b3JlVXBkYXRlcih0cmFuc2xhdGVFeHRlbnQsIHNldFRyYW5zbGF0ZUV4dGVudCk7XG4gICAgdXNlU3RvcmVVcGRhdGVyKG5vZGVFeHRlbnQsIHNldE5vZGVFeHRlbnQpO1xuICAgIHJldHVybiBudWxsO1xufTtcblxuY29uc3Qgc3R5bGUgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xuY29uc3QgYXJpYUxpdmVTdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgbWFyZ2luOiAtMSxcbiAgICBib3JkZXI6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgY2xpcDogJ3JlY3QoMHB4LCAwcHgsIDBweCwgMHB4KScsXG4gICAgY2xpcFBhdGg6ICdpbnNldCgxMDAlKScsXG59O1xuY29uc3QgQVJJQV9OT0RFX0RFU0NfS0VZID0gJ3JlYWN0LWZsb3dfX25vZGUtZGVzYyc7XG5jb25zdCBBUklBX0VER0VfREVTQ19LRVkgPSAncmVhY3QtZmxvd19fZWRnZS1kZXNjJztcbmNvbnN0IEFSSUFfTElWRV9NRVNTQUdFID0gJ3JlYWN0LWZsb3dfX2FyaWEtbGl2ZSc7XG5jb25zdCBzZWxlY3RvciRjID0gKHMpID0+IHMuYXJpYUxpdmVNZXNzYWdlO1xuZnVuY3Rpb24gQXJpYUxpdmVNZXNzYWdlKHsgcmZJZCB9KSB7XG4gICAgY29uc3QgYXJpYUxpdmVNZXNzYWdlID0gdXNlU3RvcmUoc2VsZWN0b3IkYyk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfTElWRV9NRVNTQUdFfS0ke3JmSWR9YCwgXCJhcmlhLWxpdmVcIjogXCJhc3NlcnRpdmVcIiwgXCJhcmlhLWF0b21pY1wiOiBcInRydWVcIiwgc3R5bGU6IGFyaWFMaXZlU3R5bGUgfSwgYXJpYUxpdmVNZXNzYWdlKSk7XG59XG5mdW5jdGlvbiBBMTF5RGVzY3JpcHRpb25zKHsgcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeSB9KSB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfTk9ERV9ERVNDX0tFWX0tJHtyZklkfWAsIHN0eWxlOiBzdHlsZSB9LFxuICAgICAgICAgICAgXCJQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYSBub2RlLlwiLFxuICAgICAgICAgICAgIWRpc2FibGVLZXlib2FyZEExMXkgJiYgJ1lvdSBjYW4gdGhlbiB1c2UgdGhlIGFycm93IGtleXMgdG8gbW92ZSB0aGUgbm9kZSBhcm91bmQuJyxcbiAgICAgICAgICAgIFwiIFByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgYW5kIGVzY2FwZSB0byBjYW5jZWwuXCIsXG4gICAgICAgICAgICAnICcpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfRURHRV9ERVNDX0tFWX0tJHtyZklkfWAsIHN0eWxlOiBzdHlsZSB9LCBcIlByZXNzIGVudGVyIG9yIHNwYWNlIHRvIHNlbGVjdCBhbiBlZGdlLiBZb3UgY2FuIHRoZW4gcHJlc3MgZGVsZXRlIHRvIHJlbW92ZSBpdCBvciBlc2NhcGUgdG8gY2FuY2VsLlwiKSxcbiAgICAgICAgIWRpc2FibGVLZXlib2FyZEExMXkgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChBcmlhTGl2ZU1lc3NhZ2UsIHsgcmZJZDogcmZJZCB9KSkpO1xufVxuXG4vLyB0aGUga2V5Y29kZSBjYW4gYmUgYSBzdHJpbmcgJ2EnIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgWydhJywgJ2ErZCddXG4vLyBhIHN0cmluZyBtZWFucyBhIHNpbmdsZSBrZXkgJ2EnIG9yIGEgY29tYmluYXRpb24gd2hlbiAnKycgaXMgdXNlZCAnYStkJ1xuLy8gYW4gYXJyYXkgbWVhbnMgZGlmZmVyZW50IHBvc3NpYmlsaXRpZXMuIEV4cGxhaW5lcjogWydhJywgJ2QrcyddIGhlcmUgdGhlXG4vLyB1c2VyIGNhbiB1c2UgdGhlIHNpbmdsZSBrZXkgJ2EnIG9yIHRoZSBjb21iaW5hdGlvbiAnZCcgKyAncydcbnZhciB1c2VLZXlQcmVzcyA9IChrZXlDb2RlID0gbnVsbCwgb3B0aW9ucyA9IHsgYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXI6IHRydWUgfSkgPT4ge1xuICAgIGNvbnN0IFtrZXlQcmVzc2VkLCBzZXRLZXlQcmVzc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIGlmIGEgbW9kaWZpZXIga2V5IGlzIHByZXNzZWQgaW4gb3JkZXIgdG8gdHJhY2sgaXRcbiAgICBjb25zdCBtb2RpZmllclByZXNzZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHByZXNzZWQga2V5cyBpbiBvcmRlciB0byBzdXBwb3J0IGNvbWJpbmF0aW9uc1xuICAgIGNvbnN0IHByZXNzZWRLZXlzID0gdXNlUmVmKG5ldyBTZXQoW10pKTtcbiAgICAvLyBrZXlDb2RlcyA9IGFycmF5IHdpdGggc2luZ2xlIGtleXMgW1snYSddXSBvciBrZXkgY29tYmluYXRpb25zIFtbJ2EnLCAncyddXVxuICAgIC8vIGtleXNUb1dhdGNoID0gYXJyYXkgd2l0aCBhbGwga2V5cyBmbGF0dGVuZWQgWydhJywgJ2QnLCAnU2hpZnRMZWZ0J11cbiAgICAvLyB1c2VkIHRvIGNoZWNrIGlmIHdlIHN0b3JlIGV2ZW50LmNvZGUgb3IgZXZlbnQua2V5LiBXaGVuIHRoZSBjb2RlIGlzIGluIHRoZSBsaXN0IG9mIGtleXNUb1dhdGNoXG4gICAgLy8gd2UgdXNlIHRoZSBjb2RlIG90aGVyd2lzZSB0aGUga2V5LiBFeHBsYWluZXI6IFdoZW4geW91IHByZXNzIHRoZSBsZWZ0IFwiY29tbWFuZFwiIGtleSwgdGhlIGNvZGUgaXMgXCJNZXRhTGVmdFwiXG4gICAgLy8gYW5kIHRoZSBrZXkgaXMgXCJNZXRhXCIuIFdlIHdhbnQgdXNlcnMgdG8gYmUgYWJsZSB0byBwYXNzIGtleXMgYW5kIGNvZGVzIHNvIHdlIGFzc3VtZSB0aGF0IHRoZSBrZXkgaXMgbWVhbnQgd2hlblxuICAgIC8vIHdlIGNhbid0IGZpbmQgaXQgaW4gdGhlIGxpc3Qgb2Yga2V5c1RvV2F0Y2guXG4gICAgY29uc3QgW2tleUNvZGVzLCBrZXlzVG9XYXRjaF0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGtleUNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleUNvZGVBcnIgPSBBcnJheS5pc0FycmF5KGtleUNvZGUpID8ga2V5Q29kZSA6IFtrZXlDb2RlXTtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBrZXlDb2RlQXJyLmZpbHRlcigoa2MpID0+IHR5cGVvZiBrYyA9PT0gJ3N0cmluZycpLm1hcCgoa2MpID0+IGtjLnNwbGl0KCcrJykpO1xuICAgICAgICAgICAgY29uc3Qga2V5c0ZsYXQgPSBrZXlzLnJlZHVjZSgocmVzLCBpdGVtKSA9PiByZXMuY29uY2F0KC4uLml0ZW0pLCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gW2tleXMsIGtleXNGbGF0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1tdLCBbXV07XG4gICAgfSwgW2tleUNvZGVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zPy50YXJnZXQgfHwgZG9jO1xuICAgICAgICBpZiAoa2V5Q29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZG93bkhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ZW50QWN0aW9uID0gKCFtb2RpZmllclByZXNzZWQuY3VycmVudCB8fCAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgJiYgIW9wdGlvbnMuYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIpKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0lucHV0RE9NTm9kZShldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZlbnRBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBrZXlPckNvZGUgPSB1c2VLZXlPckNvZGUoZXZlbnQuY29kZSwga2V5c1RvV2F0Y2gpO1xuICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuYWRkKGV2ZW50W2tleU9yQ29kZV0pO1xuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cy5jdXJyZW50LCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdXBIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmVudEFjdGlvbiA9ICghbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgfHwgKG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ICYmICFvcHRpb25zLmFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNJbnB1dERPTU5vZGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5T3JDb2RlID0gdXNlS2V5T3JDb2RlKGV2ZW50LmNvZGUsIGtleXNUb1dhdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMuY3VycmVudCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuZGVsZXRlKGV2ZW50W2tleU9yQ29kZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaXggZm9yIE1hYzogd2hlbiBjbWQga2V5IGlzIHByZXNzZWQsIGtleXVwIGlzIG5vdCB0cmlnZ2VyZWQgZm9yIGFueSBvdGhlciBrZXksIHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjczODAwMTgvd2hlbi1jbWQta2V5LWlzLWtlcHQtcHJlc3NlZC1rZXl1cC1pcy1ub3QtdHJpZ2dlcmVkLWZvci1hbnktb3RoZXIta2V5XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ01ldGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNldEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHNldEtleVByZXNzZWQoZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhcmdldD8uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIHRhcmdldD8uYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtrZXlDb2RlLCBzZXRLZXlQcmVzc2VkXSk7XG4gICAgcmV0dXJuIGtleVByZXNzZWQ7XG59O1xuLy8gdXRpbHNcbmZ1bmN0aW9uIGlzTWF0Y2hpbmdLZXkoa2V5Q29kZXMsIHByZXNzZWRLZXlzLCBpc1VwKSB7XG4gICAgcmV0dXJuIChrZXlDb2Rlc1xuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gY29tcGFyZSBzYW1lIHNpemVzIG9mIGtleUNvZGUgZGVmaW5pdGlvbnNcbiAgICAgICAgLy8gYW5kIHByZXNzZWQga2V5cy4gV2hlbiB0aGUgdXNlciBzcGVjaWZpZWQgJ01ldGEnIGFzIGEga2V5IHNvbWV3aGVyZVxuICAgICAgICAvLyB0aGlzIHdvdWxkIGFsc28gYmUgdHJ1dGh5IHdpdGhvdXQgdGhpcyBmaWx0ZXIgd2hlbiB1c2VyIHByZXNzZXMgJ01ldGEnICsgJ3InXG4gICAgICAgIC5maWx0ZXIoKGtleXMpID0+IGlzVXAgfHwga2V5cy5sZW5ndGggPT09IHByZXNzZWRLZXlzLnNpemUpXG4gICAgICAgIC8vIHNpbmNlIHdlIHdhbnQgdG8gc3VwcG9ydCBtdWx0aXBsZSBwb3NzaWJpbGl0aWVzIG9ubHkgb25lIG9mIHRoZVxuICAgICAgICAvLyBjb21iaW5hdGlvbnMgbmVlZCB0byBiZSBwYXJ0IG9mIHRoZSBwcmVzc2VkIGtleXNcbiAgICAgICAgLnNvbWUoKGtleXMpID0+IGtleXMuZXZlcnkoKGspID0+IHByZXNzZWRLZXlzLmhhcyhrKSkpKTtcbn1cbmZ1bmN0aW9uIHVzZUtleU9yQ29kZShldmVudENvZGUsIGtleXNUb1dhdGNoKSB7XG4gICAgcmV0dXJuIGtleXNUb1dhdGNoLmluY2x1ZGVzKGV2ZW50Q29kZSkgPyAnY29kZScgOiAna2V5Jztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlWFlaUG9zaXRpb24obm9kZSwgbm9kZUludGVybmFscywgcmVzdWx0LCBub2RlT3JpZ2luKSB7XG4gICAgaWYgKCFub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVJbnRlcm5hbHMuZ2V0KG5vZGUucGFyZW50Tm9kZSk7XG4gICAgY29uc3QgcGFyZW50Tm9kZVBvc2l0aW9uID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihwYXJlbnROb2RlLCBub2RlT3JpZ2luKTtcbiAgICByZXR1cm4gY2FsY3VsYXRlWFlaUG9zaXRpb24ocGFyZW50Tm9kZSwgbm9kZUludGVybmFscywge1xuICAgICAgICB4OiAocmVzdWx0LnggPz8gMCkgKyBwYXJlbnROb2RlUG9zaXRpb24ueCxcbiAgICAgICAgeTogKHJlc3VsdC55ID8/IDApICsgcGFyZW50Tm9kZVBvc2l0aW9uLnksXG4gICAgICAgIHo6IChwYXJlbnROb2RlW2ludGVybmFsc1N5bWJvbF0/LnogPz8gMCkgPiAocmVzdWx0LnogPz8gMCkgPyBwYXJlbnROb2RlW2ludGVybmFsc1N5bWJvbF0/LnogPz8gMCA6IHJlc3VsdC56ID8/IDAsXG4gICAgfSwgbm9kZU9yaWdpbik7XG59XG5mdW5jdGlvbiB1cGRhdGVBYnNvbHV0ZU5vZGVQb3NpdGlvbnMobm9kZUludGVybmFscywgbm9kZU9yaWdpbiwgcGFyZW50Tm9kZXMpIHtcbiAgICBub2RlSW50ZXJuYWxzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiAhbm9kZUludGVybmFscy5oYXMobm9kZS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJlbnQgbm9kZSAke25vZGUucGFyZW50Tm9kZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSB8fCBwYXJlbnROb2Rlcz8uW25vZGUuaWRdKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHksIHogfSA9IGNhbGN1bGF0ZVhZWlBvc2l0aW9uKG5vZGUsIG5vZGVJbnRlcm5hbHMsIHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHo6IG5vZGVbaW50ZXJuYWxzU3ltYm9sXT8ueiA/PyAwLFxuICAgICAgICAgICAgfSwgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICBub2RlLnBvc2l0aW9uQWJzb2x1dGUgPSB7XG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGVbaW50ZXJuYWxzU3ltYm9sXS56ID0gejtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2Rlcz8uW25vZGUuaWRdKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtpbnRlcm5hbHNTeW1ib2xdLmlzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTm9kZUludGVybmFscyhub2Rlcywgbm9kZUludGVybmFscywgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QpIHtcbiAgICBjb25zdCBuZXh0Tm9kZUludGVybmFscyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwYXJlbnROb2RlcyA9IHt9O1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZVogPSBlbGV2YXRlTm9kZXNPblNlbGVjdCA/IDEwMDAgOiAwO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgeiA9IChpc051bWVyaWMobm9kZS56SW5kZXgpID8gbm9kZS56SW5kZXggOiAwKSArIChub2RlLnNlbGVjdGVkID8gc2VsZWN0ZWROb2RlWiA6IDApO1xuICAgICAgICBjb25zdCBjdXJySW50ZXJuYWxzID0gbm9kZUludGVybmFscy5nZXQobm9kZS5pZCk7XG4gICAgICAgIGNvbnN0IGludGVybmFscyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBjdXJySW50ZXJuYWxzPy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY3VyckludGVybmFscz8uaGVpZ2h0LFxuICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGU6IHtcbiAgICAgICAgICAgICAgICB4OiBub2RlLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5wb3NpdGlvbi55LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaW50ZXJuYWxzLnBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBwYXJlbnROb2Rlc1tub2RlLnBhcmVudE5vZGVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW50ZXJuYWxzLCBpbnRlcm5hbHNTeW1ib2wsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IGN1cnJJbnRlcm5hbHM/LltpbnRlcm5hbHNTeW1ib2xdPy5oYW5kbGVCb3VuZHMsXG4gICAgICAgICAgICAgICAgeixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBuZXh0Tm9kZUludGVybmFscy5zZXQobm9kZS5pZCwgaW50ZXJuYWxzKTtcbiAgICB9KTtcbiAgICB1cGRhdGVBYnNvbHV0ZU5vZGVQb3NpdGlvbnMobmV4dE5vZGVJbnRlcm5hbHMsIG5vZGVPcmlnaW4sIHBhcmVudE5vZGVzKTtcbiAgICByZXR1cm4gbmV4dE5vZGVJbnRlcm5hbHM7XG59XG5mdW5jdGlvbiBmaXRWaWV3KGdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBnZXROb2Rlcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgZDNab29tLCBkM1NlbGVjdGlvbiwgZml0Vmlld09uSW5pdERvbmUsIGZpdFZpZXdPbkluaXQsIG5vZGVPcmlnaW4sIH0gPSBnZXQoKTtcbiAgICBjb25zdCBpc0luaXRpYWxGaXRWaWV3ID0gb3B0aW9ucy5pbml0aWFsICYmICFmaXRWaWV3T25Jbml0RG9uZSAmJiBmaXRWaWV3T25Jbml0O1xuICAgIGNvbnN0IGQzaW5pdGlhbGl6ZWQgPSBkM1pvb20gJiYgZDNTZWxlY3Rpb247XG4gICAgaWYgKGQzaW5pdGlhbGl6ZWQgJiYgKGlzSW5pdGlhbEZpdFZpZXcgfHwgIW9wdGlvbnMuaW5pdGlhbCkpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBnZXROb2RlcygpLmZpbHRlcigobikgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSGlkZGVuTm9kZXMgPyBuLndpZHRoICYmIG4uaGVpZ2h0IDogIW4uaGlkZGVuO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubm9kZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1Zpc2libGUgJiYgb3B0aW9ucy5ub2Rlcy5zb21lKChvcHRpb25Ob2RlKSA9PiBvcHRpb25Ob2RlLmlkID09PSBuLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1Zpc2libGU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBub2Rlc0luaXRpYWxpemVkID0gbm9kZXMuZXZlcnkoKG4pID0+IG4ud2lkdGggJiYgbi5oZWlnaHQpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCAmJiBub2Rlc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSBnZXROb2Rlc0JvdW5kcyhub2Rlcywgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHksIHpvb20gfSA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucy5taW5ab29tID8/IG1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSA/PyBtYXhab29tLCBvcHRpb25zLnBhZGRpbmcgPz8gMC4xKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB6b29tSWRlbnRpdHkudHJhbnNsYXRlKHgsIHkpLnNjYWxlKHpvb20pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLmR1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIGQzWm9vbS50cmFuc2Zvcm0oZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zLmR1cmF0aW9uKSwgbmV4dFRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkM1pvb20udHJhbnNmb3JtKGQzU2VsZWN0aW9uLCBuZXh0VHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWROb2RlU2VsZWN0aW9uQ2hhbmdlKG5vZGVDaGFuZ2VzLCBub2RlSW50ZXJuYWxzKSB7XG4gICAgbm9kZUNoYW5nZXMuZm9yRWFjaCgoY2hhbmdlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChjaGFuZ2UuaWQpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZUludGVybmFscy5zZXQobm9kZS5pZCwge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgW2ludGVybmFsc1N5bWJvbF06IG5vZGVbaW50ZXJuYWxzU3ltYm9sXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogY2hhbmdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1hcChub2RlSW50ZXJuYWxzKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRFZGdlU2VsZWN0aW9uQ2hhbmdlKGVkZ2VDaGFuZ2VzLCBlZGdlcykge1xuICAgIHJldHVybiBlZGdlcy5tYXAoKGUpID0+IHtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gZWRnZUNoYW5nZXMuZmluZCgoY2hhbmdlKSA9PiBjaGFuZ2UuaWQgPT09IGUuaWQpO1xuICAgICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgICAgICBlLnNlbGVjdGVkID0gY2hhbmdlLnNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlTm9kZXNBbmRFZGdlc1NlbGVjdGlvbnMoeyBjaGFuZ2VkTm9kZXMsIGNoYW5nZWRFZGdlcywgZ2V0LCBzZXQgfSkge1xuICAgIGNvbnN0IHsgbm9kZUludGVybmFscywgZWRnZXMsIG9uTm9kZXNDaGFuZ2UsIG9uRWRnZXNDaGFuZ2UsIGhhc0RlZmF1bHROb2RlcywgaGFzRGVmYXVsdEVkZ2VzIH0gPSBnZXQoKTtcbiAgICBpZiAoY2hhbmdlZE5vZGVzPy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgc2V0KHsgbm9kZUludGVybmFsczogaGFuZGxlQ29udHJvbGxlZE5vZGVTZWxlY3Rpb25DaGFuZ2UoY2hhbmdlZE5vZGVzLCBub2RlSW50ZXJuYWxzKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlZE5vZGVzKTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZWRFZGdlcz8ubGVuZ3RoKSB7XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldCh7IGVkZ2VzOiBoYW5kbGVDb250cm9sbGVkRWRnZVNlbGVjdGlvbkNoYW5nZShjaGFuZ2VkRWRnZXMsIGVkZ2VzKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbkVkZ2VzQ2hhbmdlPy4oY2hhbmdlZEVkZ2VzKTtcbiAgICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5jb25zdCBpbml0aWFsVmlld3BvcnRIZWxwZXIgPSB7XG4gICAgem9vbUluOiBub29wLFxuICAgIHpvb21PdXQ6IG5vb3AsXG4gICAgem9vbVRvOiBub29wLFxuICAgIGdldFpvb206ICgpID0+IDEsXG4gICAgc2V0Vmlld3BvcnQ6IG5vb3AsXG4gICAgZ2V0Vmlld3BvcnQ6ICgpID0+ICh7IHg6IDAsIHk6IDAsIHpvb206IDEgfSksXG4gICAgZml0VmlldzogKCkgPT4gZmFsc2UsXG4gICAgc2V0Q2VudGVyOiBub29wLFxuICAgIGZpdEJvdW5kczogbm9vcCxcbiAgICBwcm9qZWN0OiAocG9zaXRpb24pID0+IHBvc2l0aW9uLFxuICAgIHNjcmVlblRvRmxvd1Bvc2l0aW9uOiAocG9zaXRpb24pID0+IHBvc2l0aW9uLFxuICAgIGZsb3dUb1NjcmVlblBvc2l0aW9uOiAocG9zaXRpb24pID0+IHBvc2l0aW9uLFxuICAgIHZpZXdwb3J0SW5pdGlhbGl6ZWQ6IGZhbHNlLFxufTtcbmNvbnN0IHNlbGVjdG9yJGIgPSAocykgPT4gKHtcbiAgICBkM1pvb206IHMuZDNab29tLFxuICAgIGQzU2VsZWN0aW9uOiBzLmQzU2VsZWN0aW9uLFxufSk7XG5jb25zdCB1c2VWaWV3cG9ydEhlbHBlciA9ICgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyBkM1pvb20sIGQzU2VsZWN0aW9uIH0gPSB1c2VTdG9yZShzZWxlY3RvciRiLCBzaGFsbG93KTtcbiAgICBjb25zdCB2aWV3cG9ydEhlbHBlckZ1bmN0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24gJiYgZDNab29tKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHpvb21JbjogKG9wdGlvbnMpID0+IGQzWm9vbS5zY2FsZUJ5KGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24pLCAxLjIpLFxuICAgICAgICAgICAgICAgIHpvb21PdXQ6IChvcHRpb25zKSA9PiBkM1pvb20uc2NhbGVCeShnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uKSwgMSAvIDEuMiksXG4gICAgICAgICAgICAgICAgem9vbVRvOiAoem9vbUxldmVsLCBvcHRpb25zKSA9PiBkM1pvb20uc2NhbGVUbyhnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uKSwgem9vbUxldmVsKSxcbiAgICAgICAgICAgICAgICBnZXRab29tOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgICAgICAgICBzZXRWaWV3cG9ydDogKHRyYW5zZm9ybSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbeCwgeSwgem9vbV0gPSBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFRyYW5zZm9ybSA9IHpvb21JZGVudGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zbGF0ZSh0cmFuc2Zvcm0ueCA/PyB4LCB0cmFuc2Zvcm0ueSA/PyB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHRyYW5zZm9ybS56b29tID8/IHpvb20pO1xuICAgICAgICAgICAgICAgICAgICBkM1pvb20udHJhbnNmb3JtKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24pLCBuZXh0VHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFZpZXdwb3J0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5LCB6b29tIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaXRWaWV3OiAob3B0aW9ucykgPT4gZml0VmlldyhzdG9yZS5nZXRTdGF0ZSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgc2V0Q2VudGVyOiAoeCwgeSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIG1heFpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRab29tID0gdHlwZW9mIG9wdGlvbnM/Lnpvb20gIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy56b29tIDogbWF4Wm9vbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHdpZHRoIC8gMiAtIHggKiBuZXh0Wm9vbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWSA9IGhlaWdodCAvIDIgLSB5ICogbmV4dFpvb207XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHpvb21JZGVudGl0eS50cmFuc2xhdGUoY2VudGVyWCwgY2VudGVyWSkuc2NhbGUobmV4dFpvb20pO1xuICAgICAgICAgICAgICAgICAgICBkM1pvb20udHJhbnNmb3JtKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24pLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZml0Qm91bmRzOiAoYm91bmRzLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIG9wdGlvbnM/LnBhZGRpbmcgPz8gMC4xKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gem9vbUlkZW50aXR5LnRyYW5zbGF0ZSh4LCB5KS5zY2FsZSh6b29tKTtcbiAgICAgICAgICAgICAgICAgICAgZDNab29tLnRyYW5zZm9ybShnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uKSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEBkZXByZWNhdGVkIFVzZSBgc2NyZWVuVG9GbG93UG9zaXRpb25gLlxuICAgICAgICAgICAgICAgIHByb2plY3Q6IChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgc25hcFRvR3JpZCwgc25hcEdyaWQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0RFUFJFQ0FURURdIGBwcm9qZWN0YCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBgc2NyZWVuVG9GbG93UG9zaXRpb25gLiBUaGVyZSBpcyBubyBuZWVkIHRvIHN1YnRyYWN0IHRoZSByZWFjdCBmbG93IGJvdW5kcyBhbnltb3JlISBodHRwczovL3JlYWN0Zmxvdy5kZXYvYXBpLXJlZmVyZW5jZS90eXBlcy9yZWFjdC1mbG93LWluc3RhbmNlI3NjcmVlbi10by1mbG93LXBvc2l0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludFRvUmVuZGVyZXJQb2ludChwb3NpdGlvbiwgdHJhbnNmb3JtLCBzbmFwVG9HcmlkLCBzbmFwR3JpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzY3JlZW5Ub0Zsb3dQb3NpdGlvbjogKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBzbmFwVG9HcmlkLCBzbmFwR3JpZCwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4OiBkb21YLCB5OiBkb21ZIH0gPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogcG9zaXRpb24ueCAtIGRvbVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbi55IC0gZG9tWSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50VG9SZW5kZXJlclBvaW50KHJlbGF0aXZlUG9zaXRpb24sIHRyYW5zZm9ybSwgc25hcFRvR3JpZCwgc25hcEdyaWQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmxvd1RvU2NyZWVuUG9zaXRpb246IChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4OiBkb21YLCB5OiBkb21ZIH0gPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlclBvc2l0aW9uID0gcmVuZGVyZXJQb2ludFRvUG9pbnQocG9zaXRpb24sIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiByZW5kZXJlclBvc2l0aW9uLnggKyBkb21YLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcmVuZGVyZXJQb3NpdGlvbi55ICsgZG9tWSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbml0aWFsVmlld3BvcnRIZWxwZXI7XG4gICAgfSwgW2QzWm9vbSwgZDNTZWxlY3Rpb25dKTtcbiAgICByZXR1cm4gdmlld3BvcnRIZWxwZXJGdW5jdGlvbnM7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuZnVuY3Rpb24gdXNlUmVhY3RGbG93KCkge1xuICAgIGNvbnN0IHZpZXdwb3J0SGVscGVyID0gdXNlVmlld3BvcnRIZWxwZXIoKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgZ2V0Tm9kZXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiBzdG9yZVxuICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgIC5nZXROb2RlcygpXG4gICAgICAgICAgICAubWFwKChuKSA9PiAoeyAuLi5uIH0pKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZ2V0Tm9kZSA9IHVzZUNhbGxiYWNrKChpZCkgPT4ge1xuICAgICAgICByZXR1cm4gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlSW50ZXJuYWxzLmdldChpZCk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGdldEVkZ2VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIHJldHVybiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBnZXRFZGdlID0gdXNlQ2FsbGJhY2soKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IGlkKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgc2V0Tm9kZXMgPSB1c2VDYWxsYmFjaygocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCB7IGdldE5vZGVzLCBzZXROb2RlcywgaGFzRGVmYXVsdE5vZGVzLCBvbk5vZGVzQ2hhbmdlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBub2RlcyA9IGdldE5vZGVzKCk7XG4gICAgICAgIGNvbnN0IG5leHROb2RlcyA9IHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nID8gcGF5bG9hZChub2RlcykgOiBwYXlsb2FkO1xuICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICBzZXROb2RlcyhuZXh0Tm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uTm9kZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBuZXh0Tm9kZXMubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyBub2Rlcy5tYXAoKG5vZGUpID0+ICh7IHR5cGU6ICdyZW1vdmUnLCBpZDogbm9kZS5pZCB9KSlcbiAgICAgICAgICAgICAgICA6IG5leHROb2Rlcy5tYXAoKG5vZGUpID0+ICh7IGl0ZW06IG5vZGUsIHR5cGU6ICdyZXNldCcgfSkpO1xuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZShjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBzZXRFZGdlcyA9IHVzZUNhbGxiYWNrKChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSwgc2V0RWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgb25FZGdlc0NoYW5nZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgbmV4dEVkZ2VzID0gdHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbicgPyBwYXlsb2FkKGVkZ2VzKSA6IHBheWxvYWQ7XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKG5leHRFZGdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob25FZGdlc0NoYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5leHRFZGdlcy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICA/IGVkZ2VzLm1hcCgoZWRnZSkgPT4gKHsgdHlwZTogJ3JlbW92ZScsIGlkOiBlZGdlLmlkIH0pKVxuICAgICAgICAgICAgICAgIDogbmV4dEVkZ2VzLm1hcCgoZWRnZSkgPT4gKHsgaXRlbTogZWRnZSwgdHlwZTogJ3Jlc2V0JyB9KSk7XG4gICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGFkZE5vZGVzID0gdXNlQ2FsbGJhY2soKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBBcnJheS5pc0FycmF5KHBheWxvYWQpID8gcGF5bG9hZCA6IFtwYXlsb2FkXTtcbiAgICAgICAgY29uc3QgeyBnZXROb2Rlcywgc2V0Tm9kZXMsIGhhc0RlZmF1bHROb2Rlcywgb25Ob2Rlc0NoYW5nZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE5vZGVzID0gZ2V0Tm9kZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHROb2RlcyA9IFsuLi5jdXJyZW50Tm9kZXMsIC4uLm5vZGVzXTtcbiAgICAgICAgICAgIHNldE5vZGVzKG5leHROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob25Ob2Rlc0NoYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5vZGVzLm1hcCgobm9kZSkgPT4gKHsgaXRlbTogbm9kZSwgdHlwZTogJ2FkZCcgfSkpO1xuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZShjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBhZGRFZGdlcyA9IHVzZUNhbGxiYWNrKChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRFZGdlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10sIHNldEVkZ2VzLCBoYXNEZWZhdWx0RWRnZXMsIG9uRWRnZXNDaGFuZ2UgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKFsuLi5lZGdlcywgLi4ubmV4dEVkZ2VzXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob25FZGdlc0NoYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5leHRFZGdlcy5tYXAoKGVkZ2UpID0+ICh7IGl0ZW06IGVkZ2UsIHR5cGU6ICdhZGQnIH0pKTtcbiAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2UoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3QgdG9PYmplY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZ2V0Tm9kZXMsIGVkZ2VzID0gW10sIHRyYW5zZm9ybSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgW3gsIHksIHpvb21dID0gdHJhbnNmb3JtO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZXM6IGdldE5vZGVzKCkubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgIGVkZ2VzOiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpLFxuICAgICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgem9vbSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGRlbGV0ZUVsZW1lbnRzID0gdXNlQ2FsbGJhY2soKHsgbm9kZXM6IG5vZGVzRGVsZXRlZCwgZWRnZXM6IGVkZ2VzRGVsZXRlZCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUludGVybmFscywgZ2V0Tm9kZXMsIGVkZ2VzLCBoYXNEZWZhdWx0Tm9kZXMsIGhhc0RlZmF1bHRFZGdlcywgb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZSwgb25Ob2Rlc0NoYW5nZSwgb25FZGdlc0NoYW5nZSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IG5vZGVJZHMgPSAobm9kZXNEZWxldGVkIHx8IFtdKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xuICAgICAgICBjb25zdCBlZGdlSWRzID0gKGVkZ2VzRGVsZXRlZCB8fCBbXSkubWFwKChlZGdlKSA9PiBlZGdlLmlkKTtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1JlbW92ZSA9IGdldE5vZGVzKCkucmVkdWNlKChyZXMsIG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEhpdCA9ICFub2RlSWRzLmluY2x1ZGVzKG5vZGUuaWQpICYmIG5vZGUucGFyZW50Tm9kZSAmJiByZXMuZmluZCgobikgPT4gbi5pZCA9PT0gbm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0YWJsZSA9IHR5cGVvZiBub2RlLmRlbGV0YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9kZS5kZWxldGFibGUgOiB0cnVlO1xuICAgICAgICAgICAgaWYgKGRlbGV0YWJsZSAmJiAobm9kZUlkcy5pbmNsdWRlcyhub2RlLmlkKSB8fCBwYXJlbnRIaXQpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIGNvbnN0IGRlbGV0YWJsZUVkZ2VzID0gZWRnZXMuZmlsdGVyKChlKSA9PiAodHlwZW9mIGUuZGVsZXRhYmxlID09PSAnYm9vbGVhbicgPyBlLmRlbGV0YWJsZSA6IHRydWUpKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbEhpdEVkZ2VzID0gZGVsZXRhYmxlRWRnZXMuZmlsdGVyKChlKSA9PiBlZGdlSWRzLmluY2x1ZGVzKGUuaWQpKTtcbiAgICAgICAgaWYgKG5vZGVzVG9SZW1vdmUgfHwgaW5pdGlhbEhpdEVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0ZWRFZGdlcyA9IGdldENvbm5lY3RlZEVkZ2VzKG5vZGVzVG9SZW1vdmUsIGRlbGV0YWJsZUVkZ2VzKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VzVG9SZW1vdmUgPSBbLi4uaW5pdGlhbEhpdEVkZ2VzLCAuLi5jb25uZWN0ZWRFZGdlc107XG4gICAgICAgICAgICBjb25zdCBlZGdlSWRzVG9SZW1vdmUgPSBlZGdlc1RvUmVtb3ZlLnJlZHVjZSgocmVzLCBlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXMuaW5jbHVkZXMoZWRnZS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goZWRnZS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzIHx8IGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXM6IGVkZ2VzLmZpbHRlcigoZSkgPT4gIWVkZ2VJZHNUb1JlbW92ZS5pbmNsdWRlcyhlLmlkKSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUludGVybmFscy5kZWxldGUobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSW50ZXJuYWxzOiBuZXcgTWFwKG5vZGVJbnRlcm5hbHMpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWRnZUlkc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvbkVkZ2VzRGVsZXRlPy4oZWRnZXNUb1JlbW92ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9uRWRnZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FZGdlc0NoYW5nZShlZGdlSWRzVG9SZW1vdmUubWFwKChpZCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG9uTm9kZXNEZWxldGU/Lihub2Rlc1RvUmVtb3ZlKTtcbiAgICAgICAgICAgICAgICBpZiAob25Ob2Rlc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG5vZGVzVG9SZW1vdmUubWFwKChuKSA9PiAoeyBpZDogbi5pZCwgdHlwZTogJ3JlbW92ZScgfSkpO1xuICAgICAgICAgICAgICAgICAgICBvbk5vZGVzQ2hhbmdlKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZ2V0Tm9kZVJlY3QgPSB1c2VDYWxsYmFjaygobm9kZU9yUmVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpc1JlY3QgPSBpc1JlY3RPYmplY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBpc1JlY3QgPyBudWxsIDogc3RvcmUuZ2V0U3RhdGUoKS5ub2RlSW50ZXJuYWxzLmdldChub2RlT3JSZWN0LmlkKTtcbiAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSBpc1JlY3QgPyBub2RlT3JSZWN0IDogbm9kZVRvUmVjdChub2RlKTtcbiAgICAgICAgcmV0dXJuIFtub2RlUmVjdCwgbm9kZSwgaXNSZWN0XTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZ2V0SW50ZXJzZWN0aW5nTm9kZXMgPSB1c2VDYWxsYmFjaygobm9kZU9yUmVjdCwgcGFydGlhbGx5ID0gdHJ1ZSwgbm9kZXMpID0+IHtcbiAgICAgICAgY29uc3QgW25vZGVSZWN0LCBub2RlLCBpc1JlY3RdID0gZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgIGlmICghbm9kZVJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5vZGVzIHx8IHN0b3JlLmdldFN0YXRlKCkuZ2V0Tm9kZXMoKSkuZmlsdGVyKChuKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUmVjdCAmJiAobi5pZCA9PT0gbm9kZS5pZCB8fCAhbi5wb3NpdGlvbkFic29sdXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlUmVjdCA9IG5vZGVUb1JlY3Qobik7XG4gICAgICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEoY3Vyck5vZGVSZWN0LCBub2RlUmVjdCk7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICByZXR1cm4gcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gbm9kZVJlY3Qud2lkdGggKiBub2RlUmVjdC5oZWlnaHQ7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBpc05vZGVJbnRlcnNlY3RpbmcgPSB1c2VDYWxsYmFjaygobm9kZU9yUmVjdCwgYXJlYSwgcGFydGlhbGx5ID0gdHJ1ZSkgPT4ge1xuICAgICAgICBjb25zdCBbbm9kZVJlY3RdID0gZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgIGlmICghbm9kZVJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEobm9kZVJlY3QsIGFyZWEpO1xuICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgIHJldHVybiBwYXJ0aWFsbHlWaXNpYmxlIHx8IG92ZXJsYXBwaW5nQXJlYSA+PSBub2RlUmVjdC53aWR0aCAqIG5vZGVSZWN0LmhlaWdodDtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udmlld3BvcnRIZWxwZXIsXG4gICAgICAgICAgICBnZXROb2RlcyxcbiAgICAgICAgICAgIGdldE5vZGUsXG4gICAgICAgICAgICBnZXRFZGdlcyxcbiAgICAgICAgICAgIGdldEVkZ2UsXG4gICAgICAgICAgICBzZXROb2RlcyxcbiAgICAgICAgICAgIHNldEVkZ2VzLFxuICAgICAgICAgICAgYWRkTm9kZXMsXG4gICAgICAgICAgICBhZGRFZGdlcyxcbiAgICAgICAgICAgIHRvT2JqZWN0LFxuICAgICAgICAgICAgZGVsZXRlRWxlbWVudHMsXG4gICAgICAgICAgICBnZXRJbnRlcnNlY3RpbmdOb2RlcyxcbiAgICAgICAgICAgIGlzTm9kZUludGVyc2VjdGluZyxcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHZpZXdwb3J0SGVscGVyLFxuICAgICAgICBnZXROb2RlcyxcbiAgICAgICAgZ2V0Tm9kZSxcbiAgICAgICAgZ2V0RWRnZXMsXG4gICAgICAgIGdldEVkZ2UsXG4gICAgICAgIHNldE5vZGVzLFxuICAgICAgICBzZXRFZGdlcyxcbiAgICAgICAgYWRkTm9kZXMsXG4gICAgICAgIGFkZEVkZ2VzLFxuICAgICAgICB0b09iamVjdCxcbiAgICAgICAgZGVsZXRlRWxlbWVudHMsXG4gICAgICAgIGdldEludGVyc2VjdGluZ05vZGVzLFxuICAgICAgICBpc05vZGVJbnRlcnNlY3RpbmcsXG4gICAgXSk7XG59XG5cbmNvbnN0IGRlbGV0ZUtleU9wdGlvbnMgPSB7IGFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyOiBmYWxzZSB9O1xudmFyIHVzZUdsb2JhbEtleUhhbmRsZXIgPSAoeyBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgfSkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IGRlbGV0ZUVsZW1lbnRzIH0gPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBkZWxldGVLZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MoZGVsZXRlS2V5Q29kZSwgZGVsZXRlS2V5T3B0aW9ucyk7XG4gICAgY29uc3QgbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MobXVsdGlTZWxlY3Rpb25LZXlDb2RlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGVsZXRlS2V5UHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgZ2V0Tm9kZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gZ2V0Tm9kZXMoKS5maWx0ZXIoKG5vZGUpID0+IG5vZGUuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRFZGdlcyA9IGVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gZWRnZS5zZWxlY3RlZCk7XG4gICAgICAgICAgICBkZWxldGVFbGVtZW50cyh7IG5vZGVzOiBzZWxlY3RlZE5vZGVzLCBlZGdlczogc2VsZWN0ZWRFZGdlcyB9KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2RlbGV0ZUtleVByZXNzZWRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG11bHRpU2VsZWN0aW9uQWN0aXZlOiBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgfSk7XG4gICAgfSwgW211bHRpU2VsZWN0aW9uS2V5UHJlc3NlZF0pO1xufTtcblxuZnVuY3Rpb24gdXNlUmVzaXplSGFuZGxlcihyZW5kZXJlck5vZGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IHJlc2l6ZU9ic2VydmVyO1xuICAgICAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZW5kZXJlck5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBnZXREaW1lbnNpb25zKHJlbmRlcmVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIGlmIChzaXplLmhlaWdodCA9PT0gMCB8fCBzaXplLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwNCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA0J10oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHdpZHRoOiBzaXplLndpZHRoIHx8IDUwMCwgaGVpZ2h0OiBzaXplLmhlaWdodCB8fCA1MDAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICBpZiAocmVuZGVyZXJOb2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHVwZGF0ZURpbWVuc2lvbnMoKSk7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlbmRlcmVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICAgICAgaWYgKHJlc2l6ZU9ic2VydmVyICYmIHJlbmRlcmVyTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHJlbmRlcmVyTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG59XG5cbmNvbnN0IGNvbnRhaW5lclN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cbmNvbnN0IHZpZXdDaGFuZ2VkID0gKHByZXZWaWV3cG9ydCwgZXZlbnRUcmFuc2Zvcm0pID0+IHByZXZWaWV3cG9ydC54ICE9PSBldmVudFRyYW5zZm9ybS54IHx8IHByZXZWaWV3cG9ydC55ICE9PSBldmVudFRyYW5zZm9ybS55IHx8IHByZXZWaWV3cG9ydC56b29tICE9PSBldmVudFRyYW5zZm9ybS5rO1xuY29uc3QgZXZlbnRUb0Zsb3dUcmFuc2Zvcm0gPSAoZXZlbnRUcmFuc2Zvcm0pID0+ICh7XG4gICAgeDogZXZlbnRUcmFuc2Zvcm0ueCxcbiAgICB5OiBldmVudFRyYW5zZm9ybS55LFxuICAgIHpvb206IGV2ZW50VHJhbnNmb3JtLmssXG59KTtcbmNvbnN0IGlzV3JhcHBlZFdpdGhDbGFzcyA9IChldmVudCwgY2xhc3NOYW1lKSA9PiBldmVudC50YXJnZXQuY2xvc2VzdChgLiR7Y2xhc3NOYW1lfWApO1xuY29uc3QgaXNSaWdodENsaWNrUGFuID0gKHBhbk9uRHJhZywgdXNlZEJ1dHRvbikgPT4gdXNlZEJ1dHRvbiA9PT0gMiAmJiBBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnLmluY2x1ZGVzKDIpO1xuY29uc3Qgd2hlZWxEZWx0YSA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGZhY3RvciA9IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWNPcygpID8gMTAgOiAxO1xuICAgIHJldHVybiAtZXZlbnQuZGVsdGFZICogKGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDAuMDUgOiBldmVudC5kZWx0YU1vZGUgPyAxIDogMC4wMDIpICogZmFjdG9yO1xufTtcbmNvbnN0IHNlbGVjdG9yJGEgPSAocykgPT4gKHtcbiAgICBkM1pvb206IHMuZDNab29tLFxuICAgIGQzU2VsZWN0aW9uOiBzLmQzU2VsZWN0aW9uLFxuICAgIGQzWm9vbUhhbmRsZXI6IHMuZDNab29tSGFuZGxlcixcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG59KTtcbmNvbnN0IFpvb21QYW5lID0gKHsgb25Nb3ZlLCBvbk1vdmVTdGFydCwgb25Nb3ZlRW5kLCBvblBhbmVDb250ZXh0TWVudSwgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBlbGVtZW50c1NlbGVjdGFibGUsIHBhbk9uRHJhZyA9IHRydWUsIGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tLCBtYXhab29tLCB6b29tQWN0aXZhdGlvbktleUNvZGUsIHByZXZlbnRTY3JvbGxpbmcgPSB0cnVlLCBjaGlsZHJlbiwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIH0pID0+IHtcbiAgICBjb25zdCB0aW1lcklkID0gdXNlUmVmKCk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGlzWm9vbWluZ09yUGFubmluZyA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgem9vbWVkV2l0aFJpZ2h0TW91c2VCdXR0b24gPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IHpvb21QYW5lID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHByZXZUcmFuc2Zvcm0gPSB1c2VSZWYoeyB4OiAwLCB5OiAwLCB6b29tOiAwIH0pO1xuICAgIGNvbnN0IHsgZDNab29tLCBkM1NlbGVjdGlvbiwgZDNab29tSGFuZGxlciwgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkYSwgc2hhbGxvdyk7XG4gICAgY29uc3Qgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3Moem9vbUFjdGl2YXRpb25LZXlDb2RlKTtcbiAgICBjb25zdCBtb3VzZUJ1dHRvbiA9IHVzZVJlZigwKTtcbiAgICBjb25zdCBpc1BhblNjcm9sbGluZyA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgcGFuU2Nyb2xsVGltZW91dCA9IHVzZVJlZigpO1xuICAgIHVzZVJlc2l6ZUhhbmRsZXIoem9vbVBhbmUpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh6b29tUGFuZS5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBiYm94ID0gem9vbVBhbmUuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGQzWm9vbUluc3RhbmNlID0gem9vbSgpLnNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSkudHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3Qoem9vbVBhbmUuY3VycmVudCkuY2FsbChkM1pvb21JbnN0YW5jZSk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkVHJhbnNmb3JtID0gem9vbUlkZW50aXR5XG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShkZWZhdWx0Vmlld3BvcnQueCwgZGVmYXVsdFZpZXdwb3J0LnkpXG4gICAgICAgICAgICAgICAgLnNjYWxlKGNsYW1wKGRlZmF1bHRWaWV3cG9ydC56b29tLCBtaW5ab29tLCBtYXhab29tKSk7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgICAgICAgIFtiYm94LndpZHRoLCBiYm94LmhlaWdodF0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgY29uc3RyYWluZWRUcmFuc2Zvcm0gPSBkM1pvb21JbnN0YW5jZS5jb25zdHJhaW4oKSh1cGRhdGVkVHJhbnNmb3JtLCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBjb25zdHJhaW5lZFRyYW5zZm9ybSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS53aGVlbERlbHRhKHdoZWVsRGVsdGEpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGQzWm9vbTogZDNab29tSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgZDNTZWxlY3Rpb246IHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBkM1pvb21IYW5kbGVyOiBzZWxlY3Rpb24ub24oJ3doZWVsLnpvb20nKSxcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHBhc3MgdHJhbnNmb3JtIGJlY2F1c2Ugem9vbSBoYW5kbGVyIGlzIG5vdCByZWdpc3RlcmVkIHdoZW4gd2Ugc2V0IHRoZSBpbml0aWFsIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogW2NvbnN0cmFpbmVkVHJhbnNmb3JtLngsIGNvbnN0cmFpbmVkVHJhbnNmb3JtLnksIGNvbnN0cmFpbmVkVHJhbnNmb3JtLmtdLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHpvb21QYW5lLmN1cnJlbnQuY2xvc2VzdCgnLnJlYWN0LWZsb3cnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbiAmJiBkM1pvb20pIHtcbiAgICAgICAgICAgIGlmIChwYW5PblNjcm9sbCAmJiAhem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkICYmICF1c2VyU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgZDNTZWxlY3Rpb24ub24oJ3doZWVsLnpvb20nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSBkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJykuayB8fCAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfaXNNYWNPcyA9IGlzTWFjT3MoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFjb3Mgc2V0cyBjdHJsS2V5PXRydWUgZm9yIHBpbmNoIGdlc3R1cmUgb24gYSB0cmFja3BhZFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiB6b29tT25QaW5jaCAmJiBfaXNNYWNPcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludGVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSB3aGVlbERlbHRhKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHpvb20gPSBjdXJyZW50Wm9vbSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgZDNab29tLnNjYWxlVG8oZDNTZWxlY3Rpb24sIHpvb20sIHBvaW50LCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2Ugc2Nyb2xsIHNwZWVkIGluIGZpcmVmb3hcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZWZveDogZGVsdGFNb2RlID09PSAxOyBjaHJvbWU6IGRlbHRhTW9kZSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWx0YU5vcm1hbGl6ZSA9IGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDIwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbHRhWCA9IHBhbk9uU2Nyb2xsTW9kZSA9PT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsID8gMCA6IGV2ZW50LmRlbHRhWCAqIGRlbHRhTm9ybWFsaXplO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGFZID0gcGFuT25TY3JvbGxNb2RlID09PSBQYW5PblNjcm9sbE1vZGUuSG9yaXpvbnRhbCA/IDAgOiBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBlbmFibGVzIHZlcnRpY2FsIHNjcm9sbGluZyB3aXRoIHNoaWZ0ICsgc2Nyb2xsIG9uIHdpbmRvd3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXNNYWNPcyAmJiBldmVudC5zaGlmdEtleSAmJiBwYW5PblNjcm9sbE1vZGUgIT09IFBhbk9uU2Nyb2xsTW9kZS5WZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFYID0gZXZlbnQuZGVsdGFZICogZGVsdGFOb3JtYWxpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGQzWm9vbS50cmFuc2xhdGVCeShkM1NlbGVjdGlvbiwgLShkZWx0YVggLyBjdXJyZW50Wm9vbSkgKiBwYW5PblNjcm9sbFNwZWVkLCAtKGRlbHRhWSAvIGN1cnJlbnRab29tKSAqIHBhbk9uU2Nyb2xsU3BlZWQsIFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWaWV3cG9ydCA9IGV2ZW50VG9GbG93VHJhbnNmb3JtKGQzU2VsZWN0aW9uLnByb3BlcnR5KCdfX3pvb20nKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZVN0YXJ0LCBvblZpZXdwb3J0Q2hhbmdlLCBvblZpZXdwb3J0Q2hhbmdlRW5kIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocGFuU2Nyb2xsVGltZW91dC5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHBhbiBvbiBzY3JvbGwgd2UgbmVlZCB0byBoYW5kbGUgdGhlIGV2ZW50IGNhbGxzIG9uIG91ciBvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgdXNlIHRoZSBzdGFydCwgem9vbSBhbmQgZW5kIGV2ZW50cyBmcm9tIGQzLXpvb21cbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBzdGFydCBhbmQgbW92ZSBnZXRzIGNhbGxlZCBvbiBldmVyeSBzY3JvbGwgZXZlbnQgYW5kIG5vdCBvbmNlIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1BhblNjcm9sbGluZy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1BhblNjcm9sbGluZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTW92ZVN0YXJ0Py4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlU3RhcnQ/LihuZXh0Vmlld3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1BhblNjcm9sbGluZy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk1vdmU/LihldmVudCwgbmV4dFZpZXdwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2U/LihuZXh0Vmlld3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFuU2Nyb2xsVGltZW91dC5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3ZlRW5kPy4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZUVuZD8uKG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQYW5TY3JvbGxpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZDNab29tSGFuZGxlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkM1NlbGVjdGlvbi5vbignd2hlZWwuem9vbScsIGZ1bmN0aW9uIChldmVudCwgZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRTY3JvbGxpbmcgfHwgaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZDNab29tSGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50LCBkKTtcbiAgICAgICAgICAgICAgICB9LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICBkM1NlbGVjdGlvbixcbiAgICAgICAgZDNab29tLFxuICAgICAgICBkM1pvb21IYW5kbGVyLFxuICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICBvbk1vdmVTdGFydCxcbiAgICAgICAgb25Nb3ZlLFxuICAgICAgICBvbk1vdmVFbmQsXG4gICAgXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGQzWm9vbSkge1xuICAgICAgICAgICAgZDNab29tLm9uKCdzdGFydCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuc291cmNlRXZlbnQgfHwgZXZlbnQuc291cmNlRXZlbnQuaW50ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgaXQgaGVyZSwgYmVjYXVzZSBpdCdzIGFsd2F5cyAwIGluIHRoZSBcInpvb21cIiBldmVudFxuICAgICAgICAgICAgICAgIG1vdXNlQnV0dG9uLmN1cnJlbnQgPSBldmVudC5zb3VyY2VFdmVudD8uYnV0dG9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZVN0YXJ0IH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZsb3dUcmFuc2Zvcm0gPSBldmVudFRvRmxvd1RyYW5zZm9ybShldmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIGlzWm9vbWluZ09yUGFubmluZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmV2VHJhbnNmb3JtLmN1cnJlbnQgPSBmbG93VHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8udHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBwYW5lRHJhZ2dpbmc6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2VTdGFydD8uKGZsb3dUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIG9uTW92ZVN0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGZsb3dUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZDNab29tLCBvbk1vdmVTdGFydF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkM1pvb20pIHtcbiAgICAgICAgICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlICYmICFpc1pvb21pbmdPclBhbm5pbmcuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGQzWm9vbS5vbignem9vbScsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXVzZXJTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBkM1pvb20ub24oJ3pvb20nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHRyYW5zZm9ybTogW2V2ZW50LnRyYW5zZm9ybS54LCBldmVudC50cmFuc2Zvcm0ueSwgZXZlbnQudHJhbnNmb3JtLmtdIH0pO1xuICAgICAgICAgICAgICAgICAgICB6b29tZWRXaXRoUmlnaHRNb3VzZUJ1dHRvbi5jdXJyZW50ID0gISEob25QYW5lQ29udGV4dE1lbnUgJiYgaXNSaWdodENsaWNrUGFuKHBhbk9uRHJhZywgbW91c2VCdXR0b24uY3VycmVudCA/PyAwKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgob25Nb3ZlIHx8IG9uVmlld3BvcnRDaGFuZ2UpICYmICFldmVudC5zb3VyY2VFdmVudD8uaW50ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsb3dUcmFuc2Zvcm0gPSBldmVudFRvRmxvd1RyYW5zZm9ybShldmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZT8uKGZsb3dUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3ZlPy4oZXZlbnQuc291cmNlRXZlbnQsIGZsb3dUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbdXNlclNlbGVjdGlvbkFjdGl2ZSwgZDNab29tLCBvbk1vdmUsIHBhbk9uRHJhZywgb25QYW5lQ29udGV4dE1lbnVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZDNab29tKSB7XG4gICAgICAgICAgICBkM1pvb20ub24oJ2VuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuc291cmNlRXZlbnQgfHwgZXZlbnQuc291cmNlRXZlbnQuaW50ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZUVuZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpc1pvb21pbmdPclBhbm5pbmcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgcGFuZURyYWdnaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAob25QYW5lQ29udGV4dE1lbnUgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNSaWdodENsaWNrUGFuKHBhbk9uRHJhZywgbW91c2VCdXR0b24uY3VycmVudCA/PyAwKSAmJlxuICAgICAgICAgICAgICAgICAgICAhem9vbWVkV2l0aFJpZ2h0TW91c2VCdXR0b24uY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudShldmVudC5zb3VyY2VFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHpvb21lZFdpdGhSaWdodE1vdXNlQnV0dG9uLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoKG9uTW92ZUVuZCB8fCBvblZpZXdwb3J0Q2hhbmdlRW5kKSAmJiB2aWV3Q2hhbmdlZChwcmV2VHJhbnNmb3JtLmN1cnJlbnQsIGV2ZW50LnRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxvd1RyYW5zZm9ybSA9IGV2ZW50VG9GbG93VHJhbnNmb3JtKGV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZUcmFuc2Zvcm0uY3VycmVudCA9IGZsb3dUcmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lcklkLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2VFbmQ/LihmbG93VHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTW92ZUVuZD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBmbG93VHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcGFuT25TY3JvbGwgPyAxNTAgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtkM1pvb20sIHBhbk9uU2Nyb2xsLCBwYW5PbkRyYWcsIG9uTW92ZUVuZCwgb25QYW5lQ29udGV4dE1lbnVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZDNab29tKSB7XG4gICAgICAgICAgICBkM1pvb20uZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHpvb21TY3JvbGwgPSB6b29tQWN0aXZhdGlvbktleVByZXNzZWQgfHwgem9vbU9uU2Nyb2xsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpbmNoWm9vbSA9IHpvb21PblBpbmNoICYmIGV2ZW50LmN0cmxLZXk7XG4gICAgICAgICAgICAgICAgaWYgKChwYW5PbkRyYWcgPT09IHRydWUgfHwgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoMSkpKSAmJlxuICAgICAgICAgICAgICAgICAgICBldmVudC5idXR0b24gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgJ3JlYWN0LWZsb3dfX25vZGUnKSB8fCBpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsICdyZWFjdC1mbG93X19lZGdlJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBhbGwgaW50ZXJhY3Rpb25zIGFyZSBkaXNhYmxlZCwgd2UgcHJldmVudCBhbGwgem9vbSBldmVudHNcbiAgICAgICAgICAgICAgICBpZiAoIXBhbk9uRHJhZyAmJiAhem9vbVNjcm9sbCAmJiAhcGFuT25TY3JvbGwgJiYgIXpvb21PbkRvdWJsZUNsaWNrICYmICF6b29tT25QaW5jaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGR1cmluZyBhIHNlbGVjdGlvbiB3ZSBwcmV2ZW50IGFsbCBvdGhlciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHpvb20gb24gZG91YmxlIGNsaWNrIGlzIGRpc2FibGVkLCB3ZSBwcmV2ZW50IHRoZSBkb3VibGUgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgICAgICBpZiAoIXpvb21PbkRvdWJsZUNsaWNrICYmIGV2ZW50LnR5cGUgPT09ICdkYmxjbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgaW5zaWRlIGFuIGVsZW1lbnQgd2l0aCB0aGUgbm93aGVlbCBjbGFzcywgd2UgcHJldmVudCB6b29taW5nXG4gICAgICAgICAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkgJiYgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHRoZSBub3BhbiBjbGFzcywgd2UgcHJldmVudCBwYW5uaW5nXG4gICAgICAgICAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9QYW5DbGFzc05hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgIChldmVudC50eXBlICE9PSAnd2hlZWwnIHx8IChwYW5PblNjcm9sbCAmJiBldmVudC50eXBlID09PSAnd2hlZWwnICYmICF6b29tQWN0aXZhdGlvbktleVByZXNzZWQpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghem9vbU9uUGluY2ggJiYgZXZlbnQuY3RybEtleSAmJiBldmVudC50eXBlID09PSAnd2hlZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGVyZSBpcyBubyBzY3JvbGwgaGFuZGxpbmcgZW5hYmxlZCwgd2UgcHJldmVudCBhbGwgd2hlZWwgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKCF6b29tU2Nyb2xsICYmICFwYW5PblNjcm9sbCAmJiAhcGluY2hab29tICYmIGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGFuZSBpcyBub3QgbW92YWJsZSwgd2UgcHJldmVudCBkcmFnZ2luZyBpdCB3aXRoIG1vdXNlc3RhcnQgb3IgdG91Y2hzdGFydFxuICAgICAgICAgICAgICAgIGlmICghcGFuT25EcmFnICYmIChldmVudC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudC50eXBlID09PSAndG91Y2hzdGFydCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBhbmUgaXMgb25seSBtb3ZhYmxlIHVzaW5nIGFsbG93ZWQgY2xpY2tzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJlxuICAgICAgICAgICAgICAgICAgICAhcGFuT25EcmFnLmluY2x1ZGVzKGV2ZW50LmJ1dHRvbikgJiZcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGFsbG93IHJpZ2h0IGNsaWNrcyBpZiBwYW4gb24gZHJhZyBpcyBzZXQgdG8gcmlnaHQgY2xpY2tcbiAgICAgICAgICAgICAgICBjb25zdCBidXR0b25BbGxvd2VkID0gKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSkgfHwgIWV2ZW50LmJ1dHRvbiB8fCBldmVudC5idXR0b24gPD0gMTtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGZpbHRlciBmb3IgZDMtem9vbVxuICAgICAgICAgICAgICAgIHJldHVybiAoIWV2ZW50LmN0cmxLZXkgfHwgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykgJiYgYnV0dG9uQWxsb3dlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICBkM1pvb20sXG4gICAgICAgIHpvb21PblNjcm9sbCxcbiAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICB6b29tT25Eb3VibGVDbGljayxcbiAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICBlbGVtZW50c1NlbGVjdGFibGUsXG4gICAgICAgIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCxcbiAgICBdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fcmVuZGVyZXJcIiwgcmVmOiB6b29tUGFuZSwgc3R5bGU6IGNvbnRhaW5lclN0eWxlIH0sIGNoaWxkcmVuKSk7XG59O1xuXG5jb25zdCBzZWxlY3RvciQ5ID0gKHMpID0+ICh7XG4gICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBzLnVzZXJTZWxlY3Rpb25SZWN0LFxufSk7XG5mdW5jdGlvbiBVc2VyU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvblJlY3QgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDksIHNoYWxsb3cpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdDtcbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fc2VsZWN0aW9uIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IHVzZXJTZWxlY3Rpb25SZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB1c2VyU2VsZWN0aW9uUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt1c2VyU2VsZWN0aW9uUmVjdC54fXB4LCAke3VzZXJTZWxlY3Rpb25SZWN0Lnl9cHgpYCxcbiAgICAgICAgfSB9KSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVBhcmVudEV4cGFuZChyZXMsIHVwZGF0ZUl0ZW0pIHtcbiAgICBjb25zdCBwYXJlbnQgPSByZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gdXBkYXRlSXRlbS5wYXJlbnROb2RlKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGV4dGVuZFdpZHRoID0gdXBkYXRlSXRlbS5wb3NpdGlvbi54ICsgdXBkYXRlSXRlbS53aWR0aCAtIHBhcmVudC53aWR0aDtcbiAgICAgICAgY29uc3QgZXh0ZW5kSGVpZ2h0ID0gdXBkYXRlSXRlbS5wb3NpdGlvbi55ICsgdXBkYXRlSXRlbS5oZWlnaHQgLSBwYXJlbnQuaGVpZ2h0O1xuICAgICAgICBpZiAoZXh0ZW5kV2lkdGggPiAwIHx8IGV4dGVuZEhlaWdodCA+IDAgfHwgdXBkYXRlSXRlbS5wb3NpdGlvbi54IDwgMCB8fCB1cGRhdGVJdGVtLnBvc2l0aW9uLnkgPCAwKSB7XG4gICAgICAgICAgICBwYXJlbnQuc3R5bGUgPSB7IC4uLnBhcmVudC5zdHlsZSB9IHx8IHt9O1xuICAgICAgICAgICAgcGFyZW50LnN0eWxlLndpZHRoID0gcGFyZW50LnN0eWxlLndpZHRoID8/IHBhcmVudC53aWR0aDtcbiAgICAgICAgICAgIHBhcmVudC5zdHlsZS5oZWlnaHQgPSBwYXJlbnQuc3R5bGUuaGVpZ2h0ID8/IHBhcmVudC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoZXh0ZW5kV2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnN0eWxlLndpZHRoICs9IGV4dGVuZFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dGVuZEhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUuaGVpZ2h0ICs9IGV4dGVuZEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGVJdGVtLnBvc2l0aW9uLnggPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeERpZmYgPSBNYXRoLmFicyh1cGRhdGVJdGVtLnBvc2l0aW9uLngpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5wb3NpdGlvbi54ID0gcGFyZW50LnBvc2l0aW9uLnggLSB4RGlmZjtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUud2lkdGggKz0geERpZmY7XG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbS5wb3NpdGlvbi54ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGVJdGVtLnBvc2l0aW9uLnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeURpZmYgPSBNYXRoLmFicyh1cGRhdGVJdGVtLnBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5wb3NpdGlvbi55ID0gcGFyZW50LnBvc2l0aW9uLnkgLSB5RGlmZjtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUuaGVpZ2h0ICs9IHlEaWZmO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ucG9zaXRpb24ueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQud2lkdGggPSBwYXJlbnQuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICBwYXJlbnQuaGVpZ2h0ID0gcGFyZW50LnN0eWxlLmhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBlbGVtZW50cykge1xuICAgIC8vIHdlIG5lZWQgdGhpcyBoYWNrIHRvIGhhbmRsZSB0aGUgc2V0Tm9kZXMgYW5kIHNldEVkZ2VzIGZ1bmN0aW9uIG9mIHRoZSB1c2VSZWFjdEZsb3cgaG9vayBmb3IgY29udHJvbGxlZCBmbG93c1xuICAgIGlmIChjaGFuZ2VzLnNvbWUoKGMpID0+IGMudHlwZSA9PT0gJ3Jlc2V0JykpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZmlsdGVyKChjKSA9PiBjLnR5cGUgPT09ICdyZXNldCcpLm1hcCgoYykgPT4gYy5pdGVtKTtcbiAgICB9XG4gICAgY29uc3QgaW5pdEVsZW1lbnRzID0gY2hhbmdlcy5maWx0ZXIoKGMpID0+IGMudHlwZSA9PT0gJ2FkZCcpLm1hcCgoYykgPT4gYy5pdGVtKTtcbiAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKChyZXMsIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudENoYW5nZXMgPSBjaGFuZ2VzLmZpbHRlcigoYykgPT4gYy5pZCA9PT0gaXRlbS5pZCk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVJdGVtID0geyAuLi5pdGVtIH07XG4gICAgICAgIGZvciAoY29uc3QgY3VycmVudENoYW5nZSBvZiBjdXJyZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDaGFuZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtLnNlbGVjdGVkID0gY3VycmVudENoYW5nZS5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q2hhbmdlLnBvc2l0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ucG9zaXRpb24gPSBjdXJyZW50Q2hhbmdlLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q2hhbmdlLnBvc2l0aW9uQWJzb2x1dGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbS5wb3NpdGlvbkFic29sdXRlID0gY3VycmVudENoYW5nZS5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q2hhbmdlLmRyYWdnaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0uZHJhZ2dpbmcgPSBjdXJyZW50Q2hhbmdlLmRyYWdnaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUl0ZW0uZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlUGFyZW50RXhwYW5kKHJlcywgdXBkYXRlSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaW1lbnNpb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q2hhbmdlLmRpbWVuc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbS53aWR0aCA9IGN1cnJlbnRDaGFuZ2UuZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtLmhlaWdodCA9IGN1cnJlbnRDaGFuZ2UuZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRDaGFuZ2UudXBkYXRlU3R5bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbS5zdHlsZSA9IHsgLi4uKHVwZGF0ZUl0ZW0uc3R5bGUgfHwge30pLCAuLi5jdXJyZW50Q2hhbmdlLmRpbWVuc2lvbnMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudENoYW5nZS5yZXNpemluZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbS5yZXNpemluZyA9IGN1cnJlbnRDaGFuZ2UucmVzaXppbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlSXRlbS5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVQYXJlbnRFeHBhbmQocmVzLCB1cGRhdGVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2godXBkYXRlSXRlbSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgaW5pdEVsZW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKTtcbn1cbmZ1bmN0aW9uIGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKTtcbn1cbmNvbnN0IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZSA9IChpZCwgc2VsZWN0ZWQpID0+ICh7XG4gICAgaWQsXG4gICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgc2VsZWN0ZWQsXG59KTtcbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkNoYW5nZXMoaXRlbXMsIHNlbGVjdGVkSWRzKSB7XG4gICAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgocmVzLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbGxCZVNlbGVjdGVkID0gc2VsZWN0ZWRJZHMuaW5jbHVkZXMoaXRlbS5pZCk7XG4gICAgICAgIGlmICghaXRlbS5zZWxlY3RlZCAmJiB3aWxsQmVTZWxlY3RlZCkge1xuICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXMucHVzaChjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaXRlbS5pZCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0uc2VsZWN0ZWQgJiYgIXdpbGxCZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXMucHVzaChjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaXRlbS5pZCwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBUaGUgdXNlciBzZWxlY3Rpb24gcmVjdGFuZ2xlIGdldHMgZGlzcGxheWVkIHdoZW4gYSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyBzaGlmdFxuICovXG5jb25zdCB3cmFwSGFuZGxlciA9IChoYW5kbGVyLCBjb250YWluZXJSZWYpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcj8uKGV2ZW50KTtcbiAgICB9O1xufTtcbmNvbnN0IHNlbGVjdG9yJDggPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBkcmFnZ2luZzogcy5wYW5lRHJhZ2dpbmcsXG59KTtcbmNvbnN0IFBhbmUgPSBtZW1vKCh7IGlzU2VsZWN0aW5nLCBzZWxlY3Rpb25Nb2RlID0gU2VsZWN0aW9uTW9kZS5GdWxsLCBwYW5PbkRyYWcsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBvblBhbmVDbGljaywgb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbCwgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBjaGlsZHJlbiwgfSkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgcHJldlNlbGVjdGVkTm9kZXNDb3VudCA9IHVzZVJlZigwKTtcbiAgICBjb25zdCBwcmV2U2VsZWN0ZWRFZGdlc0NvdW50ID0gdXNlUmVmKDApO1xuICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IHVzZVJlZigpO1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBkcmFnZ2luZyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkOCwgc2hhbGxvdyk7XG4gICAgY29uc3QgcmVzZXRVc2VyU2VsZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLCB1c2VyU2VsZWN0aW9uUmVjdDogbnVsbCB9KTtcbiAgICAgICAgcHJldlNlbGVjdGVkTm9kZXNDb3VudC5jdXJyZW50ID0gMDtcbiAgICAgICAgcHJldlNlbGVjdGVkRWRnZXNDb3VudC5jdXJyZW50ID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgb25QYW5lQ2xpY2s/LihldmVudCk7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkucmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZz8uaW5jbHVkZXMoMikpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ29udGV4dE1lbnU/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvbldoZWVsID0gb25QYW5lU2Nyb2xsID8gKGV2ZW50KSA9PiBvblBhbmVTY3JvbGwoZXZlbnQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uTW91c2VEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVzZXRTZWxlY3RlZEVsZW1lbnRzLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb250YWluZXJCb3VuZHMuY3VycmVudCA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzU2VsZWN0YWJsZSB8fFxuICAgICAgICAgICAgIWlzU2VsZWN0aW5nIHx8XG4gICAgICAgICAgICBldmVudC5idXR0b24gIT09IDAgfHxcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCAhPT0gY29udGFpbmVyLmN1cnJlbnQgfHxcbiAgICAgICAgICAgICFjb250YWluZXJCb3VuZHMuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICByZXNldFNlbGVjdGVkRWxlbWVudHMoKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgc3RhcnRYOiB4LFxuICAgICAgICAgICAgICAgIHN0YXJ0WTogeSxcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgb25TZWxlY3Rpb25TdGFydD8uKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QsIG5vZGVJbnRlcm5hbHMsIGVkZ2VzLCB0cmFuc2Zvcm0sIG9uTm9kZXNDaGFuZ2UsIG9uRWRnZXNDaGFuZ2UsIG5vZGVPcmlnaW4sIGdldE5vZGVzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIWlzU2VsZWN0aW5nIHx8ICFjb250YWluZXJCb3VuZHMuY3VycmVudCB8fCAhdXNlclNlbGVjdGlvblJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHVzZXJTZWxlY3Rpb25BY3RpdmU6IHRydWUsIG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgICAgY29uc3QgbW91c2VQb3MgPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0WCA9IHVzZXJTZWxlY3Rpb25SZWN0LnN0YXJ0WCA/PyAwO1xuICAgICAgICBjb25zdCBzdGFydFkgPSB1c2VyU2VsZWN0aW9uUmVjdC5zdGFydFkgPz8gMDtcbiAgICAgICAgY29uc3QgbmV4dFVzZXJTZWxlY3RSZWN0ID0ge1xuICAgICAgICAgICAgLi4udXNlclNlbGVjdGlvblJlY3QsXG4gICAgICAgICAgICB4OiBtb3VzZVBvcy54IDwgc3RhcnRYID8gbW91c2VQb3MueCA6IHN0YXJ0WCxcbiAgICAgICAgICAgIHk6IG1vdXNlUG9zLnkgPCBzdGFydFkgPyBtb3VzZVBvcy55IDogc3RhcnRZLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKG1vdXNlUG9zLnggLSBzdGFydFgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyhtb3VzZVBvcy55IC0gc3RhcnRZKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBnZXROb2RlcygpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gZ2V0Tm9kZXNJbnNpZGUobm9kZUludGVybmFscywgbmV4dFVzZXJTZWxlY3RSZWN0LCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuUGFydGlhbCwgdHJ1ZSwgbm9kZU9yaWdpbik7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRWRnZUlkcyA9IGdldENvbm5lY3RlZEVkZ2VzKHNlbGVjdGVkTm9kZXMsIGVkZ2VzKS5tYXAoKGUpID0+IGUuaWQpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVJZHMgPSBzZWxlY3RlZE5vZGVzLm1hcCgobikgPT4gbi5pZCk7XG4gICAgICAgIGlmIChwcmV2U2VsZWN0ZWROb2Rlc0NvdW50LmN1cnJlbnQgIT09IHNlbGVjdGVkTm9kZUlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHByZXZTZWxlY3RlZE5vZGVzQ291bnQuY3VycmVudCA9IHNlbGVjdGVkTm9kZUlkcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2Rlcywgc2VsZWN0ZWROb2RlSWRzKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9uTm9kZXNDaGFuZ2U/LihjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlNlbGVjdGVkRWRnZXNDb3VudC5jdXJyZW50ICE9PSBzZWxlY3RlZEVkZ2VJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwcmV2U2VsZWN0ZWRFZGdlc0NvdW50LmN1cnJlbnQgPSBzZWxlY3RlZEVkZ2VJZHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZXMsIHNlbGVjdGVkRWRnZUlkcyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG5leHRVc2VyU2VsZWN0UmVjdCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvbk1vdXNlVXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB0cmlnZ2VyIGNsaWNrIGZ1bmN0aW9ucyB3aGVuIGluIHNlbGVjdGlvbiBtb2RlIGlmXG4gICAgICAgIC8vIHRoZSB1c2VyIGRpZCBub3QgbW92ZSB0aGUgbW91c2UuXG4gICAgICAgIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdCAmJiBldmVudC50YXJnZXQgPT09IGNvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkNsaWNrPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IHByZXZTZWxlY3RlZE5vZGVzQ291bnQuY3VycmVudCA+IDAgfSk7XG4gICAgICAgIHJlc2V0VXNlclNlbGVjdGlvbigpO1xuICAgICAgICBvblNlbGVjdGlvbkVuZD8uKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogcHJldlNlbGVjdGVkTm9kZXNDb3VudC5jdXJyZW50ID4gMCB9KTtcbiAgICAgICAgICAgIG9uU2VsZWN0aW9uRW5kPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0VXNlclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgY29uc3QgaGFzQWN0aXZlU2VsZWN0aW9uID0gZWxlbWVudHNTZWxlY3RhYmxlICYmIChpc1NlbGVjdGluZyB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcGFuZScsIHsgZHJhZ2dpbmcsIHNlbGVjdGlvbjogaXNTZWxlY3RpbmcgfV0pLCBvbkNsaWNrOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyB1bmRlZmluZWQgOiB3cmFwSGFuZGxlcihvbkNsaWNrLCBjb250YWluZXIpLCBvbkNvbnRleHRNZW51OiB3cmFwSGFuZGxlcihvbkNvbnRleHRNZW51LCBjb250YWluZXIpLCBvbldoZWVsOiB3cmFwSGFuZGxlcihvbldoZWVsLCBjb250YWluZXIpLCBvbk1vdXNlRW50ZXI6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IHVuZGVmaW5lZCA6IG9uUGFuZU1vdXNlRW50ZXIsIG9uTW91c2VEb3duOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyBvbk1vdXNlRG93biA6IHVuZGVmaW5lZCwgb25Nb3VzZU1vdmU6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uTW91c2VNb3ZlIDogb25QYW5lTW91c2VNb3ZlLCBvbk1vdXNlVXA6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uTW91c2VVcCA6IHVuZGVmaW5lZCwgb25Nb3VzZUxlYXZlOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyBvbk1vdXNlTGVhdmUgOiBvblBhbmVNb3VzZUxlYXZlLCByZWY6IGNvbnRhaW5lciwgc3R5bGU6IGNvbnRhaW5lclN0eWxlIH0sXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFVzZXJTZWxlY3Rpb24sIG51bGwpKSk7XG59KTtcblBhbmUuZGlzcGxheU5hbWUgPSAnUGFuZSc7XG5cbmZ1bmN0aW9uIGlzUGFyZW50U2VsZWN0ZWQobm9kZSwgbm9kZUludGVybmFscykge1xuICAgIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVJbnRlcm5hbHMuZ2V0KG5vZGUucGFyZW50Tm9kZSk7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc1BhcmVudFNlbGVjdGVkKHBhcmVudE5vZGUsIG5vZGVJbnRlcm5hbHMpO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0b3IodGFyZ2V0LCBzZWxlY3Rvciwgbm9kZVJlZikge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKGN1cnJlbnQ/Lm1hdGNoZXMoc2VsZWN0b3IpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBub2RlUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfSB3aGlsZSAoY3VycmVudCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gbG9va3MgZm9yIGFsbCBzZWxlY3RlZCBub2RlcyBhbmQgY3JlYXRlZCBhIE5vZGVEcmFnSXRlbSBmb3IgZWFjaCBvZiB0aGVtXG5mdW5jdGlvbiBnZXREcmFnSXRlbXMobm9kZUludGVybmFscywgbm9kZXNEcmFnZ2FibGUsIG1vdXNlUG9zLCBub2RlSWQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShub2RlSW50ZXJuYWxzLnZhbHVlcygpKVxuICAgICAgICAuZmlsdGVyKChuKSA9PiAobi5zZWxlY3RlZCB8fCBuLmlkID09PSBub2RlSWQpICYmXG4gICAgICAgICghbi5wYXJlbnROb2RlIHx8ICFpc1BhcmVudFNlbGVjdGVkKG4sIG5vZGVJbnRlcm5hbHMpKSAmJlxuICAgICAgICAobi5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBuLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKSlcbiAgICAgICAgLm1hcCgobikgPT4gKHtcbiAgICAgICAgaWQ6IG4uaWQsXG4gICAgICAgIHBvc2l0aW9uOiBuLnBvc2l0aW9uIHx8IHsgeDogMCwgeTogMCB9LFxuICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBuLnBvc2l0aW9uQWJzb2x1dGUgfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgIGRpc3RhbmNlOiB7XG4gICAgICAgICAgICB4OiBtb3VzZVBvcy54IC0gKG4ucG9zaXRpb25BYnNvbHV0ZT8ueCA/PyAwKSxcbiAgICAgICAgICAgIHk6IG1vdXNlUG9zLnkgLSAobi5wb3NpdGlvbkFic29sdXRlPy55ID8/IDApLFxuICAgICAgICB9LFxuICAgICAgICBkZWx0YToge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVudDogbi5leHRlbnQsXG4gICAgICAgIHBhcmVudE5vZGU6IG4ucGFyZW50Tm9kZSxcbiAgICAgICAgd2lkdGg6IG4ud2lkdGgsXG4gICAgICAgIGhlaWdodDogbi5oZWlnaHQsXG4gICAgICAgIGV4cGFuZFBhcmVudDogbi5leHBhbmRQYXJlbnQsXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gY2xhbXBOb2RlRXh0ZW50KG5vZGUsIGV4dGVudCkge1xuICAgIGlmICghZXh0ZW50IHx8IGV4dGVudCA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVudDtcbiAgICB9XG4gICAgcmV0dXJuIFtleHRlbnRbMF0sIFtleHRlbnRbMV1bMF0gLSAobm9kZS53aWR0aCB8fCAwKSwgZXh0ZW50WzFdWzFdIC0gKG5vZGUuaGVpZ2h0IHx8IDApXV07XG59XG5mdW5jdGlvbiBjYWxjTmV4dFBvc2l0aW9uKG5vZGUsIG5leHRQb3NpdGlvbiwgbm9kZUludGVybmFscywgbm9kZUV4dGVudCwgbm9kZU9yaWdpbiA9IFswLCAwXSwgb25FcnJvcikge1xuICAgIGNvbnN0IGNsYW1wZWROb2RlRXh0ZW50ID0gY2xhbXBOb2RlRXh0ZW50KG5vZGUsIG5vZGUuZXh0ZW50IHx8IG5vZGVFeHRlbnQpO1xuICAgIGxldCBjdXJyZW50RXh0ZW50ID0gY2xhbXBlZE5vZGVFeHRlbnQ7XG4gICAgaWYgKG5vZGUuZXh0ZW50ID09PSAncGFyZW50JyAmJiAhbm9kZS5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLndpZHRoICYmIG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlSW50ZXJuYWxzLmdldChub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKHBhcmVudCwgbm9kZU9yaWdpbikucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIGN1cnJlbnRFeHRlbnQgPVxuICAgICAgICAgICAgICAgIHBhcmVudCAmJiBpc051bWVyaWMocGFyZW50WCkgJiYgaXNOdW1lcmljKHBhcmVudFkpICYmIGlzTnVtZXJpYyhwYXJlbnQud2lkdGgpICYmIGlzTnVtZXJpYyhwYXJlbnQuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJlbnRYICsgbm9kZS53aWR0aCAqIG5vZGVPcmlnaW5bMF0sIHBhcmVudFkgKyBub2RlLmhlaWdodCAqIG5vZGVPcmlnaW5bMV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFggKyBwYXJlbnQud2lkdGggLSBub2RlLndpZHRoICsgbm9kZS53aWR0aCAqIG5vZGVPcmlnaW5bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50WSArIHBhcmVudC5oZWlnaHQgLSBub2RlLmhlaWdodCArIG5vZGUuaGVpZ2h0ICogbm9kZU9yaWdpblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50RXh0ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25FcnJvcj8uKCcwMDUnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNSddKCkpO1xuICAgICAgICAgICAgY3VycmVudEV4dGVudCA9IGNsYW1wZWROb2RlRXh0ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUuZXh0ZW50ICYmIG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLmV4dGVudCAhPT0gJ3BhcmVudCcpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZUludGVybmFscy5nZXQobm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKHBhcmVudCwgbm9kZU9yaWdpbikucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgY3VycmVudEV4dGVudCA9IFtcbiAgICAgICAgICAgIFtub2RlLmV4dGVudFswXVswXSArIHBhcmVudFgsIG5vZGUuZXh0ZW50WzBdWzFdICsgcGFyZW50WV0sXG4gICAgICAgICAgICBbbm9kZS5leHRlbnRbMV1bMF0gKyBwYXJlbnRYLCBub2RlLmV4dGVudFsxXVsxXSArIHBhcmVudFldLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBsZXQgcGFyZW50UG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICBwYXJlbnRQb3NpdGlvbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4ocGFyZW50Tm9kZSwgbm9kZU9yaWdpbikucG9zaXRpb25BYnNvbHV0ZTtcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb25BYnNvbHV0ZSA9IGN1cnJlbnRFeHRlbnQgJiYgY3VycmVudEV4dGVudCAhPT0gJ3BhcmVudCdcbiAgICAgICAgPyBjbGFtcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgY3VycmVudEV4dGVudClcbiAgICAgICAgOiBuZXh0UG9zaXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uQWJzb2x1dGUueCAtIHBhcmVudFBvc2l0aW9uLngsXG4gICAgICAgICAgICB5OiBwb3NpdGlvbkFic29sdXRlLnkgLSBwYXJlbnRQb3NpdGlvbi55LFxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbkFic29sdXRlLFxuICAgIH07XG59XG4vLyByZXR1cm5zIHR3byBwYXJhbXM6XG4vLyAxLiB0aGUgZHJhZ2dlZCBub2RlIChvciB0aGUgZmlyc3Qgb2YgdGhlIGxpc3QsIGlmIHdlIGFyZSBkcmFnZ2luZyBhIG5vZGUgc2VsZWN0aW9uKVxuLy8gMi4gYXJyYXkgb2Ygc2VsZWN0ZWQgbm9kZXMgKGZvciBtdWx0aSBzZWxlY3Rpb25zKVxuZnVuY3Rpb24gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHsgbm9kZUlkLCBkcmFnSXRlbXMsIG5vZGVJbnRlcm5hbHMsIH0pIHtcbiAgICBjb25zdCBleHRlbnRlZERyYWdJdGVtcyA9IGRyYWdJdGVtcy5tYXAoKG4pID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVJbnRlcm5hbHMuZ2V0KG4uaWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuLnBvc2l0aW9uLFxuICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogbi5wb3NpdGlvbkFic29sdXRlLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBbbm9kZUlkID8gZXh0ZW50ZWREcmFnSXRlbXMuZmluZCgobikgPT4gbi5pZCA9PT0gbm9kZUlkKSA6IGV4dGVudGVkRHJhZ0l0ZW1zWzBdLCBleHRlbnRlZERyYWdJdGVtc107XG59XG5cbmNvbnN0IGdldEhhbmRsZUJvdW5kcyA9IChzZWxlY3Rvciwgbm9kZUVsZW1lbnQsIHpvb20sIG5vZGVPcmlnaW4pID0+IHtcbiAgICBjb25zdCBoYW5kbGVzID0gbm9kZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgaWYgKCFoYW5kbGVzIHx8ICFoYW5kbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlc0FycmF5ID0gQXJyYXkuZnJvbShoYW5kbGVzKTtcbiAgICBjb25zdCBub2RlQm91bmRzID0gbm9kZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgbm9kZU9mZnNldCA9IHtcbiAgICAgICAgeDogbm9kZUJvdW5kcy53aWR0aCAqIG5vZGVPcmlnaW5bMF0sXG4gICAgICAgIHk6IG5vZGVCb3VuZHMuaGVpZ2h0ICogbm9kZU9yaWdpblsxXSxcbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGVzQXJyYXkubWFwKChoYW5kbGUpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlQm91bmRzID0gaGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGhhbmRsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlaWQnKSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBoYW5kbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZXBvcycpLFxuICAgICAgICAgICAgeDogKGhhbmRsZUJvdW5kcy5sZWZ0IC0gbm9kZUJvdW5kcy5sZWZ0IC0gbm9kZU9mZnNldC54KSAvIHpvb20sXG4gICAgICAgICAgICB5OiAoaGFuZGxlQm91bmRzLnRvcCAtIG5vZGVCb3VuZHMudG9wIC0gbm9kZU9mZnNldC55KSAvIHpvb20sXG4gICAgICAgICAgICAuLi5nZXREaW1lbnNpb25zKGhhbmRsZSksXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZ2V0TW91c2VIYW5kbGVyKGlkLCBnZXRTdGF0ZSwgaGFuZGxlcikge1xuICAgIHJldHVybiBoYW5kbGVyID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBoYW5kbGVyXG4gICAgICAgIDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZ2V0U3RhdGUoKS5ub2RlSW50ZXJuYWxzLmdldChpZCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXZlbnQsIHsgLi4ubm9kZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbn1cbi8vIHRoaXMgaGFuZGxlciBpcyBjYWxsZWQgYnlcbi8vIDEuIHRoZSBjbGljayBoYW5kbGVyIHdoZW4gbm9kZSBpcyBub3QgZHJhZ2dhYmxlIG9yIHNlbGVjdE5vZGVzT25EcmFnID0gZmFsc2Vcbi8vIG9yXG4vLyAyLiB0aGUgb24gZHJhZyBzdGFydCBoYW5kbGVyIHdoZW4gbm9kZSBpcyBkcmFnZ2FibGUgYW5kIHNlbGVjdE5vZGVzT25EcmFnID0gdHJ1ZVxuZnVuY3Rpb24gaGFuZGxlTm9kZUNsaWNrKHsgaWQsIHN0b3JlLCB1bnNlbGVjdCA9IGZhbHNlLCBub2RlUmVmLCB9KSB7XG4gICAgY29uc3QgeyBhZGRTZWxlY3RlZE5vZGVzLCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIG11bHRpU2VsZWN0aW9uQWN0aXZlLCBub2RlSW50ZXJuYWxzLCBvbkVycm9yIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IG5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChpZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIG9uRXJyb3I/LignMDEyJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTInXShpZCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIGlmICghbm9kZS5zZWxlY3RlZCkge1xuICAgICAgICBhZGRTZWxlY3RlZE5vZGVzKFtpZF0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh1bnNlbGVjdCB8fCAobm9kZS5zZWxlY3RlZCAmJiBtdWx0aVNlbGVjdGlvbkFjdGl2ZSkpIHtcbiAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKHsgbm9kZXM6IFtub2RlXSwgZWRnZXM6IFtdIH0pO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gbm9kZVJlZj8uY3VycmVudD8uYmx1cigpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZUdldFBvaW50ZXJQb3NpdGlvbigpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgLy8gcmV0dXJucyB0aGUgcG9pbnRlciBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIFJGIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgY29uc3QgZ2V0UG9pbnRlclBvc2l0aW9uID0gdXNlQ2FsbGJhY2soKHsgc291cmNlRXZlbnQgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IHggPSBzb3VyY2VFdmVudC50b3VjaGVzID8gc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYIDogc291cmNlRXZlbnQuY2xpZW50WDtcbiAgICAgICAgY29uc3QgeSA9IHNvdXJjZUV2ZW50LnRvdWNoZXMgPyBzb3VyY2VFdmVudC50b3VjaGVzWzBdLmNsaWVudFkgOiBzb3VyY2VFdmVudC5jbGllbnRZO1xuICAgICAgICBjb25zdCBwb2ludGVyUG9zID0ge1xuICAgICAgICAgICAgeDogKHggLSB0cmFuc2Zvcm1bMF0pIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICAgICAgeTogKHkgLSB0cmFuc2Zvcm1bMV0pIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICB9O1xuICAgICAgICAvLyB3ZSBuZWVkIHRoZSBzbmFwcGVkIHBvc2l0aW9uIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gc2tpcCB1bm5lY2Vzc2FyeSBkcmFnIGV2ZW50c1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeFNuYXBwZWQ6IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFswXSAqIE1hdGgucm91bmQocG9pbnRlclBvcy54IC8gc25hcEdyaWRbMF0pIDogcG9pbnRlclBvcy54LFxuICAgICAgICAgICAgeVNuYXBwZWQ6IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFsxXSAqIE1hdGgucm91bmQocG9pbnRlclBvcy55IC8gc25hcEdyaWRbMV0pIDogcG9pbnRlclBvcy55LFxuICAgICAgICAgICAgLi4ucG9pbnRlclBvcyxcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGdldFBvaW50ZXJQb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gd3JhcFNlbGVjdGlvbkRyYWdGdW5jKHNlbGVjdGlvbkZ1bmMpIHtcbiAgICByZXR1cm4gKGV2ZW50LCBfLCBub2RlcykgPT4gc2VsZWN0aW9uRnVuYz8uKGV2ZW50LCBub2Rlcyk7XG59XG5mdW5jdGlvbiB1c2VEcmFnKHsgbm9kZVJlZiwgZGlzYWJsZWQgPSBmYWxzZSwgbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3Rvciwgbm9kZUlkLCBpc1NlbGVjdGFibGUsIHNlbGVjdE5vZGVzT25EcmFnLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IFtkcmFnZ2luZywgc2V0RHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGRyYWdJdGVtcyA9IHVzZVJlZihbXSk7XG4gICAgY29uc3QgbGFzdFBvcyA9IHVzZVJlZih7IHg6IG51bGwsIHk6IG51bGwgfSk7XG4gICAgY29uc3QgYXV0b1BhbklkID0gdXNlUmVmKDApO1xuICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBtb3VzZVBvc2l0aW9uID0gdXNlUmVmKHsgeDogMCwgeTogMCB9KTtcbiAgICBjb25zdCBkcmFnRXZlbnQgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgYXV0b1BhblN0YXJ0ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGRyYWdTdGFydGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBnZXRQb2ludGVyUG9zaXRpb24gPSB1c2VHZXRQb2ludGVyUG9zaXRpb24oKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobm9kZVJlZj8uY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc2VsZWN0KG5vZGVSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVOb2RlcyA9ICh7IHgsIHkgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUludGVybmFscywgb25Ob2RlRHJhZywgb25TZWxlY3Rpb25EcmFnLCB1cGRhdGVOb2RlUG9zaXRpb25zLCBub2RlRXh0ZW50LCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgb25FcnJvciwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgbGFzdFBvcy5jdXJyZW50ID0geyB4LCB5IH07XG4gICAgICAgICAgICAgICAgbGV0IGhhc0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBub2Rlc0JveCA9IHsgeDogMCwgeTogMCwgeDI6IDAsIHkyOiAwIH07XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdJdGVtcy5jdXJyZW50Lmxlbmd0aCA+IDEgJiYgbm9kZUV4dGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gZ2V0Tm9kZXNCb3VuZHMoZHJhZ0l0ZW1zLmN1cnJlbnQsIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc0JveCA9IHJlY3RUb0JveChyZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLmN1cnJlbnQgPSBkcmFnSXRlbXMuY3VycmVudC5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0geyB4OiB4IC0gbi5kaXN0YW5jZS54LCB5OiB5IC0gbi5kaXN0YW5jZS55IH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbmFwVG9HcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24ueCA9IHNuYXBHcmlkWzBdICogTWF0aC5yb3VuZChuZXh0UG9zaXRpb24ueCAvIHNuYXBHcmlkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi55ID0gc25hcEdyaWRbMV0gKiBNYXRoLnJvdW5kKG5leHRQb3NpdGlvbi55IC8gc25hcEdyaWRbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIHNlbGVjdGlvbiB3aXRoIG11bHRpcGxlIG5vZGVzIGFuZCBhIG5vZGUgZXh0ZW50IGlzIHNldCwgd2UgbmVlZCB0byBhZGp1c3QgdGhlIG5vZGUgZXh0ZW50IGZvciBlYWNoIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFzZWQgb24gaXRzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIG5vZGUgc3RheXMgYXQgaXQncyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RlZE5vZGVFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBbbm9kZUV4dGVudFswXVswXSwgbm9kZUV4dGVudFswXVsxXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbbm9kZUV4dGVudFsxXVswXSwgbm9kZUV4dGVudFsxXVsxXV0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnSXRlbXMuY3VycmVudC5sZW5ndGggPiAxICYmIG5vZGVFeHRlbnQgJiYgIW4uZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZE5vZGVFeHRlbnRbMF1bMF0gPSBuLnBvc2l0aW9uQWJzb2x1dGUueCAtIG5vZGVzQm94LnggKyBub2RlRXh0ZW50WzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWROb2RlRXh0ZW50WzFdWzBdID0gbi5wb3NpdGlvbkFic29sdXRlLnggKyAobi53aWR0aCA/PyAwKSAtIG5vZGVzQm94LngyICsgbm9kZUV4dGVudFsxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdGVkTm9kZUV4dGVudFswXVsxXSA9IG4ucG9zaXRpb25BYnNvbHV0ZS55IC0gbm9kZXNCb3gueSArIG5vZGVFeHRlbnRbMF1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZE5vZGVFeHRlbnRbMV1bMV0gPSBuLnBvc2l0aW9uQWJzb2x1dGUueSArIChuLmhlaWdodCA/PyAwKSAtIG5vZGVzQm94LnkyICsgbm9kZUV4dGVudFsxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkUG9zID0gY2FsY05leHRQb3NpdGlvbihuLCBuZXh0UG9zaXRpb24sIG5vZGVJbnRlcm5hbHMsIGFkanVzdGVkTm9kZUV4dGVudCwgbm9kZU9yaWdpbiwgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgd2Ugb25seSBmaXJlIGEgY2hhbmdlIGV2ZW50IHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlID0gaGFzQ2hhbmdlIHx8IG4ucG9zaXRpb24ueCAhPT0gdXBkYXRlZFBvcy5wb3NpdGlvbi54IHx8IG4ucG9zaXRpb24ueSAhPT0gdXBkYXRlZFBvcy5wb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgICAgICBuLnBvc2l0aW9uID0gdXBkYXRlZFBvcy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgbi5wb3NpdGlvbkFic29sdXRlID0gdXBkYXRlZFBvcy5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoZHJhZ0l0ZW1zLmN1cnJlbnQsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNldERyYWdnaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uRHJhZyA9IG5vZGVJZCA/IG9uTm9kZURyYWcgOiB3cmFwU2VsZWN0aW9uRHJhZ0Z1bmMob25TZWxlY3Rpb25EcmFnKTtcbiAgICAgICAgICAgICAgICBpZiAob25EcmFnICYmIGRyYWdFdmVudC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgbm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtczogZHJhZ0l0ZW1zLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb25EcmFnKGRyYWdFdmVudC5jdXJyZW50LCBjdXJyZW50Tm9kZSwgbm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhdXRvUGFuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVyQm91bmRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbeE1vdmVtZW50LCB5TW92ZW1lbnRdID0gY2FsY0F1dG9QYW4obW91c2VQb3NpdGlvbi5jdXJyZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHhNb3ZlbWVudCAhPT0gMCB8fCB5TW92ZW1lbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHBhbkJ5IH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0UG9zLmN1cnJlbnQueCA9IChsYXN0UG9zLmN1cnJlbnQueCA/PyAwKSAtIHhNb3ZlbWVudCAvIHRyYW5zZm9ybVsyXTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBvcy5jdXJyZW50LnkgPSAobGFzdFBvcy5jdXJyZW50LnkgPz8gMCkgLSB5TW92ZW1lbnQgLyB0cmFuc2Zvcm1bMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYW5CeSh7IHg6IHhNb3ZlbWVudCwgeTogeU1vdmVtZW50IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVOb2RlcyhsYXN0UG9zLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF1dG9QYW5JZC5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9QYW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0RHJhZyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUludGVybmFscywgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIG5vZGVzRHJhZ2dhYmxlLCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIG9uTm9kZURyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RhcnQsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGRyYWdTdGFydGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uU3RhcnQgPSBub2RlSWQgPyBvbk5vZGVEcmFnU3RhcnQgOiB3cmFwU2VsZWN0aW9uRHJhZ0Z1bmMob25TZWxlY3Rpb25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmICgoIXNlbGVjdE5vZGVzT25EcmFnIHx8ICFpc1NlbGVjdGFibGUpICYmICFtdWx0aVNlbGVjdGlvbkFjdGl2ZSAmJiBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlSW50ZXJuYWxzLmdldChub2RlSWQpPy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXNldCBzZWxlY3RlZCBub2RlcyB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPWZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZUlkICYmIGlzU2VsZWN0YWJsZSAmJiBzZWxlY3ROb2Rlc09uRHJhZykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlZjogbm9kZVJlZixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGxhc3RQb3MuY3VycmVudCA9IHBvaW50ZXJQb3M7XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLmN1cnJlbnQgPSBnZXREcmFnSXRlbXMobm9kZUludGVybmFscywgbm9kZXNEcmFnZ2FibGUsIHBvaW50ZXJQb3MsIG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uU3RhcnQgJiYgZHJhZ0l0ZW1zLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBub2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zOiBkcmFnSXRlbXMuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvblN0YXJ0KGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZSwgbm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkcmFnSGFuZGxlciA9IGRyYWcoKVxuICAgICAgICAgICAgICAgICAgICAub24oJ3N0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgbm9kZURyYWdUaHJlc2hvbGQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlRHJhZ1RocmVzaG9sZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBvcy5jdXJyZW50ID0gcG9pbnRlclBvcztcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyQm91bmRzLmN1cnJlbnQgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICBtb3VzZVBvc2l0aW9uLmN1cnJlbnQgPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdkcmFnJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGF1dG9QYW5Pbk5vZGVEcmFnLCBub2RlRHJhZ1RocmVzaG9sZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZC5jdXJyZW50ICYmIGRyYWdTdGFydGVkLmN1cnJlbnQgJiYgYXV0b1Bhbk9uTm9kZURyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1BhbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHBvaW50ZXJQb3MueFNuYXBwZWQgLSAobGFzdFBvcz8uY3VycmVudD8ueCA/PyAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwb2ludGVyUG9zLnlTbmFwcGVkIC0gKGxhc3RQb3M/LmN1cnJlbnQ/LnkgPz8gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG5vZGVEcmFnVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGV2ZW50cyB3aXRob3V0IG1vdmVtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICgobGFzdFBvcy5jdXJyZW50LnggIT09IHBvaW50ZXJQb3MueFNuYXBwZWQgfHwgbGFzdFBvcy5jdXJyZW50LnkgIT09IHBvaW50ZXJQb3MueVNuYXBwZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbXMuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0V2ZW50LmN1cnJlbnQgPSBldmVudC5zb3VyY2VFdmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlUG9zaXRpb24uY3VycmVudCA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzKHBvaW50ZXJQb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdlbmQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0RHJhZ2dpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvUGFuU3RhcnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdTdGFydGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXBkYXRlTm9kZVBvc2l0aW9ucywgbm9kZUludGVybmFscywgb25Ob2RlRHJhZ1N0b3AsIG9uU2VsZWN0aW9uRHJhZ1N0b3AgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvblN0b3AgPSBub2RlSWQgPyBvbk5vZGVEcmFnU3RvcCA6IHdyYXBTZWxlY3Rpb25EcmFnRnVuYyhvblNlbGVjdGlvbkRyYWdTdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoZHJhZ0l0ZW1zLmN1cnJlbnQsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25TdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBub2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtczogZHJhZ0l0ZW1zLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdG9wKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZSwgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0RyYWdnYWJsZSA9ICFldmVudC5idXR0b24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghbm9EcmFnQ2xhc3NOYW1lIHx8ICFoYXNTZWxlY3Rvcih0YXJnZXQsIGAuJHtub0RyYWdDbGFzc05hbWV9YCwgbm9kZVJlZikpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWhhbmRsZVNlbGVjdG9yIHx8IGhhc1NlbGVjdG9yKHRhcmdldCwgaGFuZGxlU2VsZWN0b3IsIG5vZGVSZWYpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRHJhZ2dhYmxlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5jYWxsKGRyYWdIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgbm9kZVJlZixcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgaGFuZGxlU2VsZWN0b3IsXG4gICAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgICAgc3RvcmUsXG4gICAgICAgIG5vZGVJZCxcbiAgICAgICAgc2VsZWN0Tm9kZXNPbkRyYWcsXG4gICAgICAgIGdldFBvaW50ZXJQb3NpdGlvbixcbiAgICBdKTtcbiAgICByZXR1cm4gZHJhZ2dpbmc7XG59XG5cbmZ1bmN0aW9uIHVzZVVwZGF0ZU5vZGVQb3NpdGlvbnMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHVwZGF0ZVBvc2l0aW9ucyA9IHVzZUNhbGxiYWNrKChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBub2RlSW50ZXJuYWxzLCBub2RlRXh0ZW50LCB1cGRhdGVOb2RlUG9zaXRpb25zLCBnZXROb2Rlcywgc25hcFRvR3JpZCwgc25hcEdyaWQsIG9uRXJyb3IsIG5vZGVzRHJhZ2dhYmxlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gZ2V0Tm9kZXMoKS5maWx0ZXIoKG4pID0+IG4uc2VsZWN0ZWQgJiYgKG4uZHJhZ2dhYmxlIHx8IChub2Rlc0RyYWdnYWJsZSAmJiB0eXBlb2Ygbi5kcmFnZ2FibGUgPT09ICd1bmRlZmluZWQnKSkpO1xuICAgICAgICAvLyBieSBkZWZhdWx0IGEgbm9kZSBtb3ZlcyA1cHggb24gZWFjaCBrZXkgcHJlc3MsIG9yIDIwcHggaWYgc2hpZnQgaXMgcHJlc3NlZFxuICAgICAgICAvLyBpZiBzbmFwIGdyaWQgaXMgZW5hYmxlZCwgd2UgdXNlIHRoYXQgZm9yIHRoZSB2ZWxvY2l0eS5cbiAgICAgICAgY29uc3QgeFZlbG8gPSBzbmFwVG9HcmlkID8gc25hcEdyaWRbMF0gOiA1O1xuICAgICAgICBjb25zdCB5VmVsbyA9IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFsxXSA6IDU7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IHBhcmFtcy5pc1NoaWZ0UHJlc3NlZCA/IDQgOiAxO1xuICAgICAgICBjb25zdCBwb3NpdGlvbkRpZmZYID0gcGFyYW1zLnggKiB4VmVsbyAqIGZhY3RvcjtcbiAgICAgICAgY29uc3QgcG9zaXRpb25EaWZmWSA9IHBhcmFtcy55ICogeVZlbG8gKiBmYWN0b3I7XG4gICAgICAgIGNvbnN0IG5vZGVVcGRhdGVzID0gc2VsZWN0ZWROb2Rlcy5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgIGlmIChuLnBvc2l0aW9uQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB7IHg6IG4ucG9zaXRpb25BYnNvbHV0ZS54ICsgcG9zaXRpb25EaWZmWCwgeTogbi5wb3NpdGlvbkFic29sdXRlLnkgKyBwb3NpdGlvbkRpZmZZIH07XG4gICAgICAgICAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLnggPSBzbmFwR3JpZFswXSAqIE1hdGgucm91bmQobmV4dFBvc2l0aW9uLnggLyBzbmFwR3JpZFswXSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi55ID0gc25hcEdyaWRbMV0gKiBNYXRoLnJvdW5kKG5leHRQb3NpdGlvbi55IC8gc25hcEdyaWRbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUsIHBvc2l0aW9uIH0gPSBjYWxjTmV4dFBvc2l0aW9uKG4sIG5leHRQb3NpdGlvbiwgbm9kZUludGVybmFscywgbm9kZUV4dGVudCwgdW5kZWZpbmVkLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBuLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgbi5wb3NpdGlvbkFic29sdXRlID0gcG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhub2RlVXBkYXRlcywgdHJ1ZSwgZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXBkYXRlUG9zaXRpb25zO1xufVxuXG5jb25zdCBhcnJvd0tleURpZmZzID0ge1xuICAgIEFycm93VXA6IHsgeDogMCwgeTogLTEgfSxcbiAgICBBcnJvd0Rvd246IHsgeDogMCwgeTogMSB9LFxuICAgIEFycm93TGVmdDogeyB4OiAtMSwgeTogMCB9LFxuICAgIEFycm93UmlnaHQ6IHsgeDogMSwgeTogMCB9LFxufTtcbnZhciB3cmFwTm9kZSA9IChOb2RlQ29tcG9uZW50KSA9PiB7XG4gICAgY29uc3QgTm9kZVdyYXBwZXIgPSAoeyBpZCwgdHlwZSwgZGF0YSwgeFBvcywgeVBvcywgeFBvc09yaWdpbiwgeVBvc09yaWdpbiwgc2VsZWN0ZWQsIG9uQ2xpY2ssIG9uTW91c2VFbnRlciwgb25Nb3VzZU1vdmUsIG9uTW91c2VMZWF2ZSwgb25Db250ZXh0TWVudSwgb25Eb3VibGVDbGljaywgc3R5bGUsIGNsYXNzTmFtZSwgaXNEcmFnZ2FibGUsIGlzU2VsZWN0YWJsZSwgaXNDb25uZWN0YWJsZSwgaXNGb2N1c2FibGUsIHNlbGVjdE5vZGVzT25EcmFnLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGhpZGRlbiwgcmVzaXplT2JzZXJ2ZXIsIGRyYWdIYW5kbGUsIHpJbmRleCwgaXNQYXJlbnQsIG5vRHJhZ0NsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGluaXRpYWxpemVkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBhcmlhTGFiZWwsIHJmSWQsIH0pID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgICAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgICAgICBjb25zdCBwcmV2U291cmNlUG9zaXRpb24gPSB1c2VSZWYoc291cmNlUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBwcmV2VGFyZ2V0UG9zaXRpb24gPSB1c2VSZWYodGFyZ2V0UG9zaXRpb24pO1xuICAgICAgICBjb25zdCBwcmV2VHlwZSA9IHVzZVJlZih0eXBlKTtcbiAgICAgICAgY29uc3QgaGFzUG9pbnRlckV2ZW50cyA9IGlzU2VsZWN0YWJsZSB8fCBpc0RyYWdnYWJsZSB8fCBvbkNsaWNrIHx8IG9uTW91c2VFbnRlciB8fCBvbk1vdXNlTW92ZSB8fCBvbk1vdXNlTGVhdmU7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVBvc2l0aW9ucyA9IHVzZVVwZGF0ZU5vZGVQb3NpdGlvbnMoKTtcbiAgICAgICAgY29uc3Qgb25Nb3VzZUVudGVySGFuZGxlciA9IGdldE1vdXNlSGFuZGxlcihpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uTW91c2VFbnRlcik7XG4gICAgICAgIGNvbnN0IG9uTW91c2VNb3ZlSGFuZGxlciA9IGdldE1vdXNlSGFuZGxlcihpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgY29uc3Qgb25Nb3VzZUxlYXZlSGFuZGxlciA9IGdldE1vdXNlSGFuZGxlcihpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uTW91c2VMZWF2ZSk7XG4gICAgICAgIGNvbnN0IG9uQ29udGV4dE1lbnVIYW5kbGVyID0gZ2V0TW91c2VIYW5kbGVyKGlkLCBzdG9yZS5nZXRTdGF0ZSwgb25Db250ZXh0TWVudSk7XG4gICAgICAgIGNvbnN0IG9uRG91YmxlQ2xpY2tIYW5kbGVyID0gZ2V0TW91c2VIYW5kbGVyKGlkLCBzdG9yZS5nZXRTdGF0ZSwgb25Eb3VibGVDbGljayk7XG4gICAgICAgIGNvbnN0IG9uU2VsZWN0Tm9kZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZURyYWdUaHJlc2hvbGQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RhYmxlICYmICghc2VsZWN0Tm9kZXNPbkRyYWcgfHwgIWlzRHJhZ2dhYmxlIHx8IG5vZGVEcmFnVGhyZXNob2xkID4gMCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGhhbmRsZXIgZ2V0cyBjYWxsZWQgd2l0aGluIHRoZSBkcmFnIHN0YXJ0IGV2ZW50IHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9dHJ1ZVxuICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHN0b3JlLmdldFN0YXRlKCkubm9kZUludGVybmFscy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIHsgLi4ubm9kZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzSW5wdXRET01Ob2RlKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuc2VsZWN0ID0gZXZlbnQua2V5ID09PSAnRXNjYXBlJztcbiAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0LFxuICAgICAgICAgICAgICAgICAgICBub2RlUmVmLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRpc2FibGVLZXlib2FyZEExMXkgJiZcbiAgICAgICAgICAgICAgICBpc0RyYWdnYWJsZSAmJlxuICAgICAgICAgICAgICAgIHNlbGVjdGVkICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycm93S2V5RGlmZnMsIGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZTogYE1vdmVkIHNlbGVjdGVkIG5vZGUgJHtldmVudC5rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdBcnJvdycsICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9LiBOZXcgcG9zaXRpb24sIHg6ICR7fn54UG9zfSwgeTogJHt+fnlQb3N9YCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1cGRhdGVQb3NpdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICB4OiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogYXJyb3dLZXlEaWZmc1tldmVudC5rZXldLnksXG4gICAgICAgICAgICAgICAgICAgIGlzU2hpZnRQcmVzc2VkOiBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQgJiYgIWhpZGRlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlID0gbm9kZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKGN1cnJOb2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gcmVzaXplT2JzZXJ2ZXI/LnVub2JzZXJ2ZShjdXJyTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtoaWRkZW5dKTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIHVzZXIgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VzIHRoZSBzb3VyY2Ugb3IgaGFuZGxlIHBvc2l0aW9uLCB3ZSByZS1pbml0aWFsaXplIHRoZSBub2RlXG4gICAgICAgICAgICBjb25zdCB0eXBlQ2hhbmdlZCA9IHByZXZUeXBlLmN1cnJlbnQgIT09IHR5cGU7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQb3NDaGFuZ2VkID0gcHJldlNvdXJjZVBvc2l0aW9uLmN1cnJlbnQgIT09IHNvdXJjZVBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zQ2hhbmdlZCA9IHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ICE9PSB0YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQgJiYgKHR5cGVDaGFuZ2VkIHx8IHNvdXJjZVBvc0NoYW5nZWQgfHwgdGFyZ2V0UG9zQ2hhbmdlZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlR5cGUuY3VycmVudCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VQb3NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZTb3VyY2VQb3NpdGlvbi5jdXJyZW50ID0gc291cmNlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRQb3NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ID0gdGFyZ2V0UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkudXBkYXRlTm9kZURpbWVuc2lvbnMoW3sgaWQsIG5vZGVFbGVtZW50OiBub2RlUmVmLmN1cnJlbnQsIGZvcmNlVXBkYXRlOiB0cnVlIH1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW2lkLCB0eXBlLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb25dKTtcbiAgICAgICAgY29uc3QgZHJhZ2dpbmcgPSB1c2VEcmFnKHtcbiAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICBkaXNhYmxlZDogaGlkZGVuIHx8ICFpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgICAgIGhhbmRsZVNlbGVjdG9yOiBkcmFnSGFuZGxlLFxuICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgICAgICAgIHNlbGVjdE5vZGVzT25EcmFnLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhpZGRlbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX25vZGUnLFxuICAgICAgICAgICAgICAgIGByZWFjdC1mbG93X19ub2RlLSR7dHlwZX1gLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBvdmVyd3JpdGFibGUgYnkgcGFzc2luZyBgbm9wYW5gIGFzIGEgY2xhc3MgbmFtZVxuICAgICAgICAgICAgICAgICAgICBbbm9QYW5DbGFzc05hbWVdOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogaXNQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKSwgcmVmOiBub2RlUmVmLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt4UG9zT3JpZ2lufXB4LCR7eVBvc09yaWdpbn1weClgLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IGhhc1BvaW50ZXJFdmVudHMgPyAnYWxsJyA6ICdub25lJyxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpbml0aWFsaXplZCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgfSwgXCJkYXRhLWlkXCI6IGlkLCBcImRhdGEtdGVzdGlkXCI6IGByZl9fbm9kZS0ke2lkfWAsIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVySGFuZGxlciwgb25Nb3VzZU1vdmU6IG9uTW91c2VNb3ZlSGFuZGxlciwgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmVIYW5kbGVyLCBvbkNvbnRleHRNZW51OiBvbkNvbnRleHRNZW51SGFuZGxlciwgb25DbGljazogb25TZWxlY3ROb2RlSGFuZGxlciwgb25Eb3VibGVDbGljazogb25Eb3VibGVDbGlja0hhbmRsZXIsIG9uS2V5RG93bjogaXNGb2N1c2FibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsIHRhYkluZGV4OiBpc0ZvY3VzYWJsZSA/IDAgOiB1bmRlZmluZWQsIHJvbGU6IGlzRm9jdXNhYmxlID8gJ2J1dHRvbicgOiB1bmRlZmluZWQsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogYCR7QVJJQV9OT0RFX0RFU0NfS0VZfS0ke3JmSWR9YCwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlciwgeyB2YWx1ZTogaWQgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE5vZGVDb21wb25lbnQsIHsgaWQ6IGlkLCBkYXRhOiBkYXRhLCB0eXBlOiB0eXBlLCB4UG9zOiB4UG9zLCB5UG9zOiB5UG9zLCBzZWxlY3RlZDogc2VsZWN0ZWQsIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBkcmFnZ2luZzogZHJhZ2dpbmcsIGRyYWdIYW5kbGU6IGRyYWdIYW5kbGUsIHpJbmRleDogekluZGV4IH0pKSkpO1xuICAgIH07XG4gICAgTm9kZVdyYXBwZXIuZGlzcGxheU5hbWUgPSAnTm9kZVdyYXBwZXInO1xuICAgIHJldHVybiBtZW1vKE5vZGVXcmFwcGVyKTtcbn07XG5cbi8qKlxuICogVGhlIG5vZGVzIHNlbGVjdGlvbiByZWN0YW5nbGUgZ2V0cyBkaXNwbGF5ZWQgd2hlbiBhIHVzZXJcbiAqIG1hZGUgYSBzZWxlY3Rpb24gd2l0aCBvbiBvciBzZXZlcmFsIG5vZGVzXG4gKi9cbmNvbnN0IHNlbGVjdG9yJDcgPSAocykgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzLmdldE5vZGVzKCkuZmlsdGVyKChuKSA9PiBuLnNlbGVjdGVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5nZXROb2Rlc0JvdW5kcyhzZWxlY3RlZE5vZGVzLCBzLm5vZGVPcmlnaW4pLFxuICAgICAgICB0cmFuc2Zvcm1TdHJpbmc6IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSlgLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgfTtcbn07XG5mdW5jdGlvbiBOb2Rlc1NlbGVjdGlvbih7IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4OiBsZWZ0LCB5OiB0b3AsIHRyYW5zZm9ybVN0cmluZywgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkNywgc2hhbGxvdyk7XG4gICAgY29uc3QgdXBkYXRlUG9zaXRpb25zID0gdXNlVXBkYXRlTm9kZVBvc2l0aW9ucygpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFkaXNhYmxlS2V5Ym9hcmRBMTF5KSB7XG4gICAgICAgICAgICBub2RlUmVmLmN1cnJlbnQ/LmZvY3VzKHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGlzYWJsZUtleWJvYXJkQTExeV0pO1xuICAgIHVzZURyYWcoe1xuICAgICAgICBub2RlUmVmLFxuICAgIH0pO1xuICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkNvbnRleHRNZW51ID0gb25TZWxlY3Rpb25Db250ZXh0TWVudVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHN0b3JlXG4gICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAuZ2V0Tm9kZXMoKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG4pID0+IG4uc2VsZWN0ZWQpO1xuICAgICAgICAgICAgb25TZWxlY3Rpb25Db250ZXh0TWVudShldmVudCwgc2VsZWN0ZWROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJyb3dLZXlEaWZmcywgZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgdXBkYXRlUG9zaXRpb25zKHtcbiAgICAgICAgICAgICAgICB4OiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0ueCxcbiAgICAgICAgICAgICAgICB5OiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0ueSxcbiAgICAgICAgICAgICAgICBpc1NoaWZ0UHJlc3NlZDogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX25vZGVzc2VsZWN0aW9uJywgJ3JlYWN0LWZsb3dfX2NvbnRhaW5lcicsIG5vUGFuQ2xhc3NOYW1lXSksIHN0eWxlOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVN0cmluZyxcbiAgICAgICAgfSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBub2RlUmVmLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbm9kZXNzZWxlY3Rpb24tcmVjdFwiLCBvbkNvbnRleHRNZW51OiBvbkNvbnRleHRNZW51LCB0YWJJbmRleDogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IC0xLCBvbktleURvd246IGRpc2FibGVLZXlib2FyZEExMXkgPyB1bmRlZmluZWQgOiBvbktleURvd24sIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgfSB9KSkpO1xufVxudmFyIE5vZGVzU2VsZWN0aW9uJDEgPSBtZW1vKE5vZGVzU2VsZWN0aW9uKTtcblxuY29uc3Qgc2VsZWN0b3IkNiA9IChzKSA9PiBzLm5vZGVzU2VsZWN0aW9uQWN0aXZlO1xuY29uc3QgRmxvd1JlbmRlcmVyID0gKHsgY2hpbGRyZW4sIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIGRlbGV0ZUtleUNvZGUsIG9uTW92ZSwgb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZCwgc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBlbGVtZW50c1NlbGVjdGFibGUsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsOiBfcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZzogX3Bhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmcsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSA9PiB7XG4gICAgY29uc3Qgbm9kZXNTZWxlY3Rpb25BY3RpdmUgPSB1c2VTdG9yZShzZWxlY3RvciQ2KTtcbiAgICBjb25zdCBzZWxlY3Rpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3Moc2VsZWN0aW9uS2V5Q29kZSk7XG4gICAgY29uc3QgcGFuQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhwYW5BY3RpdmF0aW9uS2V5Q29kZSk7XG4gICAgY29uc3QgcGFuT25EcmFnID0gcGFuQWN0aXZhdGlvbktleVByZXNzZWQgfHwgX3Bhbk9uRHJhZztcbiAgICBjb25zdCBwYW5PblNjcm9sbCA9IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IF9wYW5PblNjcm9sbDtcbiAgICBjb25zdCBpc1NlbGVjdGluZyA9IHNlbGVjdGlvbktleVByZXNzZWQgfHwgKHNlbGVjdGlvbk9uRHJhZyAmJiBwYW5PbkRyYWcgIT09IHRydWUpO1xuICAgIHVzZUdsb2JhbEtleUhhbmRsZXIoeyBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgfSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFpvb21QYW5lLCB7IG9uTW92ZTogb25Nb3ZlLCBvbk1vdmVTdGFydDogb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZDogb25Nb3ZlRW5kLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGw6IHpvb21PblNjcm9sbCwgem9vbU9uUGluY2g6IHpvb21PblBpbmNoLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljazogem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZzogIXNlbGVjdGlvbktleVByZXNzZWQgJiYgcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub1doZWVsQ2xhc3NOYW1lOiBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQYW5lLCB7IG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGw6IG9uUGFuZVNjcm9sbCwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIGlzU2VsZWN0aW5nOiAhIWlzU2VsZWN0aW5nLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlIH0sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIG5vZGVzU2VsZWN0aW9uQWN0aXZlICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KE5vZGVzU2VsZWN0aW9uJDEsIHsgb25TZWxlY3Rpb25Db250ZXh0TWVudTogb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pKSkpKTtcbn07XG5GbG93UmVuZGVyZXIuZGlzcGxheU5hbWUgPSAnRmxvd1JlbmRlcmVyJztcbnZhciBGbG93UmVuZGVyZXIkMSA9IG1lbW8oRmxvd1JlbmRlcmVyKTtcblxuZnVuY3Rpb24gdXNlVmlzaWJsZU5vZGVzKG9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4gb25seVJlbmRlclZpc2libGVcbiAgICAgICAgPyBnZXROb2Rlc0luc2lkZShzLm5vZGVJbnRlcm5hbHMsIHsgeDogMCwgeTogMCwgd2lkdGg6IHMud2lkdGgsIGhlaWdodDogcy5oZWlnaHQgfSwgcy50cmFuc2Zvcm0sIHRydWUpXG4gICAgICAgIDogcy5nZXROb2RlcygpLCBbb25seVJlbmRlclZpc2libGVdKSk7XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlVHlwZXMobm9kZVR5cGVzKSB7XG4gICAgY29uc3Qgc3RhbmRhcmRUeXBlcyA9IHtcbiAgICAgICAgaW5wdXQ6IHdyYXBOb2RlKChub2RlVHlwZXMuaW5wdXQgfHwgSW5wdXROb2RlJDEpKSxcbiAgICAgICAgZGVmYXVsdDogd3JhcE5vZGUoKG5vZGVUeXBlcy5kZWZhdWx0IHx8IERlZmF1bHROb2RlJDEpKSxcbiAgICAgICAgb3V0cHV0OiB3cmFwTm9kZSgobm9kZVR5cGVzLm91dHB1dCB8fCBPdXRwdXROb2RlJDEpKSxcbiAgICAgICAgZ3JvdXA6IHdyYXBOb2RlKChub2RlVHlwZXMuZ3JvdXAgfHwgR3JvdXBOb2RlKSksXG4gICAgfTtcbiAgICBjb25zdCB3cmFwcGVkVHlwZXMgPSB7fTtcbiAgICBjb25zdCBzcGVjaWFsVHlwZXMgPSBPYmplY3Qua2V5cyhub2RlVHlwZXMpXG4gICAgICAgIC5maWx0ZXIoKGspID0+ICFbJ2lucHV0JywgJ2RlZmF1bHQnLCAnb3V0cHV0JywgJ2dyb3VwJ10uaW5jbHVkZXMoaykpXG4gICAgICAgIC5yZWR1Y2UoKHJlcywga2V5KSA9PiB7XG4gICAgICAgIHJlc1trZXldID0gd3JhcE5vZGUoKG5vZGVUeXBlc1trZXldIHx8IERlZmF1bHROb2RlJDEpKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCB3cmFwcGVkVHlwZXMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YW5kYXJkVHlwZXMsXG4gICAgICAgIC4uLnNwZWNpYWxUeXBlcyxcbiAgICB9O1xufVxuY29uc3QgZ2V0UG9zaXRpb25XaXRoT3JpZ2luID0gKHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCB9KSA9PiB7XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9XG4gICAgaWYgKG9yaWdpblswXSA8IDAgfHwgb3JpZ2luWzFdIDwgMCB8fCBvcmlnaW5bMF0gPiAxIHx8IG9yaWdpblsxXSA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4IC0gd2lkdGggKiBvcmlnaW5bMF0sXG4gICAgICAgIHk6IHkgLSBoZWlnaHQgKiBvcmlnaW5bMV0sXG4gICAgfTtcbn07XG5cbmNvbnN0IHNlbGVjdG9yJDUgPSAocykgPT4gKHtcbiAgICBub2Rlc0RyYWdnYWJsZTogcy5ub2Rlc0RyYWdnYWJsZSxcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgbm9kZXNGb2N1c2FibGU6IHMubm9kZXNGb2N1c2FibGUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICB1cGRhdGVOb2RlRGltZW5zaW9uczogcy51cGRhdGVOb2RlRGltZW5zaW9ucyxcbiAgICBvbkVycm9yOiBzLm9uRXJyb3IsXG59KTtcbmNvbnN0IE5vZGVSZW5kZXJlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIHVwZGF0ZU5vZGVEaW1lbnNpb25zLCBvbkVycm9yIH0gPSB1c2VTdG9yZShzZWxlY3RvciQ1LCBzaGFsbG93KTtcbiAgICBjb25zdCBub2RlcyA9IHVzZVZpc2libGVOb2Rlcyhwcm9wcy5vbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzKTtcbiAgICBjb25zdCByZXNpemVPYnNlcnZlclJlZiA9IHVzZVJlZigpO1xuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlcyA9IGVudHJpZXMubWFwKChlbnRyeSkgPT4gKHtcbiAgICAgICAgICAgICAgICBpZDogZW50cnkudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpLFxuICAgICAgICAgICAgICAgIG5vZGVFbGVtZW50OiBlbnRyeS50YXJnZXQsXG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGU6IHRydWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB1cGRhdGVOb2RlRGltZW5zaW9ucyh1cGRhdGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQgPSBvYnNlcnZlcjtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXJSZWY/LmN1cnJlbnQ/LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX25vZGVzXCIsIHN0eWxlOiBjb250YWluZXJTdHlsZSB9LCBub2Rlcy5tYXAoKG5vZGUpID0+IHtcbiAgICAgICAgbGV0IG5vZGVUeXBlID0gbm9kZS50eXBlIHx8ICdkZWZhdWx0JztcbiAgICAgICAgaWYgKCFwcm9wcy5ub2RlVHlwZXNbbm9kZVR5cGVdKSB7XG4gICAgICAgICAgICBvbkVycm9yPy4oJzAwMycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAzJ10obm9kZVR5cGUpKTtcbiAgICAgICAgICAgIG5vZGVUeXBlID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IE5vZGVDb21wb25lbnQgPSAocHJvcHMubm9kZVR5cGVzW25vZGVUeXBlXSB8fCBwcm9wcy5ub2RlVHlwZXMuZGVmYXVsdCk7XG4gICAgICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISEobm9kZS5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBub2RlLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RhYmxlID0gISEobm9kZS5zZWxlY3RhYmxlIHx8IChlbGVtZW50c1NlbGVjdGFibGUgJiYgdHlwZW9mIG5vZGUuc2VsZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0YWJsZSA9ICEhKG5vZGUuY29ubmVjdGFibGUgfHwgKG5vZGVzQ29ubmVjdGFibGUgJiYgdHlwZW9mIG5vZGUuY29ubmVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgICAgIGNvbnN0IGlzRm9jdXNhYmxlID0gISEobm9kZS5mb2N1c2FibGUgfHwgKG5vZGVzRm9jdXNhYmxlICYmIHR5cGVvZiBub2RlLmZvY3VzYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICAgICAgY29uc3QgY2xhbXBlZFBvc2l0aW9uID0gcHJvcHMubm9kZUV4dGVudFxuICAgICAgICAgICAgPyBjbGFtcFBvc2l0aW9uKG5vZGUucG9zaXRpb25BYnNvbHV0ZSwgcHJvcHMubm9kZUV4dGVudClcbiAgICAgICAgICAgIDogbm9kZS5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICBjb25zdCBwb3NYID0gY2xhbXBlZFBvc2l0aW9uPy54ID8/IDA7XG4gICAgICAgIGNvbnN0IHBvc1kgPSBjbGFtcGVkUG9zaXRpb24/LnkgPz8gMDtcbiAgICAgICAgY29uc3QgcG9zT3JpZ2luID0gZ2V0UG9zaXRpb25XaXRoT3JpZ2luKHtcbiAgICAgICAgICAgIHg6IHBvc1gsXG4gICAgICAgICAgICB5OiBwb3NZLFxuICAgICAgICAgICAgd2lkdGg6IG5vZGUud2lkdGggPz8gMCxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgIG9yaWdpbjogcHJvcHMubm9kZU9yaWdpbixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChOb2RlQ29tcG9uZW50LCB7IGtleTogbm9kZS5pZCwgaWQ6IG5vZGUuaWQsIGNsYXNzTmFtZTogbm9kZS5jbGFzc05hbWUsIHN0eWxlOiBub2RlLnN0eWxlLCB0eXBlOiBub2RlVHlwZSwgZGF0YTogbm9kZS5kYXRhLCBzb3VyY2VQb3NpdGlvbjogbm9kZS5zb3VyY2VQb3NpdGlvbiB8fCBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uOiBub2RlLnRhcmdldFBvc2l0aW9uIHx8IFBvc2l0aW9uLlRvcCwgaGlkZGVuOiBub2RlLmhpZGRlbiwgeFBvczogcG9zWCwgeVBvczogcG9zWSwgeFBvc09yaWdpbjogcG9zT3JpZ2luLngsIHlQb3NPcmlnaW46IHBvc09yaWdpbi55LCBzZWxlY3ROb2Rlc09uRHJhZzogcHJvcHMuc2VsZWN0Tm9kZXNPbkRyYWcsIG9uQ2xpY2s6IHByb3BzLm9uTm9kZUNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLm9uTm9kZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBwcm9wcy5vbk5vZGVNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogcHJvcHMub25Ob2RlTW91c2VMZWF2ZSwgb25Db250ZXh0TWVudTogcHJvcHMub25Ob2RlQ29udGV4dE1lbnUsIG9uRG91YmxlQ2xpY2s6IHByb3BzLm9uTm9kZURvdWJsZUNsaWNrLCBzZWxlY3RlZDogISFub2RlLnNlbGVjdGVkLCBpc0RyYWdnYWJsZTogaXNEcmFnZ2FibGUsIGlzU2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlLCBpc0ZvY3VzYWJsZTogaXNGb2N1c2FibGUsIHJlc2l6ZU9ic2VydmVyOiByZXNpemVPYnNlcnZlciwgZHJhZ0hhbmRsZTogbm9kZS5kcmFnSGFuZGxlLCB6SW5kZXg6IG5vZGVbaW50ZXJuYWxzU3ltYm9sXT8ueiA/PyAwLCBpc1BhcmVudDogISFub2RlW2ludGVybmFsc1N5bWJvbF0/LmlzUGFyZW50LCBub0RyYWdDbGFzc05hbWU6IHByb3BzLm5vRHJhZ0NsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IHByb3BzLm5vUGFuQ2xhc3NOYW1lLCBpbml0aWFsaXplZDogISFub2RlLndpZHRoICYmICEhbm9kZS5oZWlnaHQsIHJmSWQ6IHByb3BzLnJmSWQsIGRpc2FibGVLZXlib2FyZEExMXk6IHByb3BzLmRpc2FibGVLZXlib2FyZEExMXksIGFyaWFMYWJlbDogbm9kZS5hcmlhTGFiZWwgfSkpO1xuICAgIH0pKSk7XG59O1xuTm9kZVJlbmRlcmVyLmRpc3BsYXlOYW1lID0gJ05vZGVSZW5kZXJlcic7XG52YXIgTm9kZVJlbmRlcmVyJDEgPSBtZW1vKE5vZGVSZW5kZXJlcik7XG5cbmNvbnN0IHNoaWZ0WCA9ICh4LCBzaGlmdCwgcG9zaXRpb24pID0+IHtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkxlZnQpXG4gICAgICAgIHJldHVybiB4IC0gc2hpZnQ7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5SaWdodClcbiAgICAgICAgcmV0dXJuIHggKyBzaGlmdDtcbiAgICByZXR1cm4geDtcbn07XG5jb25zdCBzaGlmdFkgPSAoeSwgc2hpZnQsIHBvc2l0aW9uKSA9PiB7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5Ub3ApXG4gICAgICAgIHJldHVybiB5IC0gc2hpZnQ7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5Cb3R0b20pXG4gICAgICAgIHJldHVybiB5ICsgc2hpZnQ7XG4gICAgcmV0dXJuIHk7XG59O1xuY29uc3QgRWRnZVVwZGF0ZXJDbGFzc05hbWUgPSAncmVhY3QtZmxvd19fZWRnZXVwZGF0ZXInO1xuY29uc3QgRWRnZUFuY2hvciA9ICh7IHBvc2l0aW9uLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMgPSAxMCwgb25Nb3VzZURvd24sIG9uTW91c2VFbnRlciwgb25Nb3VzZU91dCwgdHlwZSwgfSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwgeyBvbk1vdXNlRG93bjogb25Nb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvbk1vdXNlT3V0LCBjbGFzc05hbWU6IGNjKFtFZGdlVXBkYXRlckNsYXNzTmFtZSwgYCR7RWRnZVVwZGF0ZXJDbGFzc05hbWV9LSR7dHlwZX1gXSksIGN4OiBzaGlmdFgoY2VudGVyWCwgcmFkaXVzLCBwb3NpdGlvbiksIGN5OiBzaGlmdFkoY2VudGVyWSwgcmFkaXVzLCBwb3NpdGlvbiksIHI6IHJhZGl1cywgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsIGZpbGw6IFwidHJhbnNwYXJlbnRcIiB9KSk7XG5cbmNvbnN0IGFsd2F5c1ZhbGlkQ29ubmVjdGlvbiA9ICgpID0+IHRydWU7XG52YXIgd3JhcEVkZ2UgPSAoRWRnZUNvbXBvbmVudCkgPT4ge1xuICAgIGNvbnN0IEVkZ2VXcmFwcGVyID0gKHsgaWQsIGNsYXNzTmFtZSwgdHlwZSwgZGF0YSwgb25DbGljaywgb25FZGdlRG91YmxlQ2xpY2ssIHNlbGVjdGVkLCBhbmltYXRlZCwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgc291cmNlLCB0YXJnZXQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgZWxlbWVudHNTZWxlY3RhYmxlLCBoaWRkZW4sIHNvdXJjZUhhbmRsZUlkLCB0YXJnZXRIYW5kbGVJZCwgb25Db250ZXh0TWVudSwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlLCBlZGdlVXBkYXRlclJhZGl1cywgb25FZGdlVXBkYXRlLCBvbkVkZ2VVcGRhdGVTdGFydCwgb25FZGdlVXBkYXRlRW5kLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCByZklkLCBhcmlhTGFiZWwsIGlzRm9jdXNhYmxlLCBpc1VwZGF0YWJsZSwgcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgZWRnZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICAgICAgY29uc3QgW3VwZGF0ZUhvdmVyLCBzZXRVcGRhdGVIb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgICAgIGNvbnN0IFt1cGRhdGluZywgc2V0VXBkYXRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgICAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgICAgIGNvbnN0IG1hcmtlclN0YXJ0VXJsID0gdXNlTWVtbygoKSA9PiBgdXJsKCMke2dldE1hcmtlcklkKG1hcmtlclN0YXJ0LCByZklkKX0pYCwgW21hcmtlclN0YXJ0LCByZklkXSk7XG4gICAgICAgIGNvbnN0IG1hcmtlckVuZFVybCA9IHVzZU1lbW8oKCkgPT4gYHVybCgjJHtnZXRNYXJrZXJJZChtYXJrZXJFbmQsIHJmSWQpfSlgLCBbbWFya2VyRW5kLCByZklkXSk7XG4gICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRWRnZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzLCBhZGRTZWxlY3RlZEVkZ2VzLCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIG11bHRpU2VsZWN0aW9uQWN0aXZlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgZWRnZSA9IGVkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IGlkKTtcbiAgICAgICAgICAgIGlmICghZWRnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtZW50c1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZS5zZWxlY3RlZCAmJiBtdWx0aVNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW10sIGVkZ2VzOiBbZWRnZV0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VSZWYuY3VycmVudD8uYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VsZWN0ZWRFZGdlcyhbaWRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkVkZ2VEb3VibGVDbGlja0hhbmRsZXIgPSBnZXRNb3VzZUhhbmRsZXIkMShpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uRWRnZURvdWJsZUNsaWNrKTtcbiAgICAgICAgY29uc3Qgb25FZGdlQ29udGV4dE1lbnUgPSBnZXRNb3VzZUhhbmRsZXIkMShpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uQ29udGV4dE1lbnUpO1xuICAgICAgICBjb25zdCBvbkVkZ2VNb3VzZUVudGVyID0gZ2V0TW91c2VIYW5kbGVyJDEoaWQsIHN0b3JlLmdldFN0YXRlLCBvbk1vdXNlRW50ZXIpO1xuICAgICAgICBjb25zdCBvbkVkZ2VNb3VzZU1vdmUgPSBnZXRNb3VzZUhhbmRsZXIkMShpZCwgc3RvcmUuZ2V0U3RhdGUsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgY29uc3Qgb25FZGdlTW91c2VMZWF2ZSA9IGdldE1vdXNlSGFuZGxlciQxKGlkLCBzdG9yZS5nZXRTdGF0ZSwgb25Nb3VzZUxlYXZlKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRWRnZVVwZGF0ZXIgPSAoZXZlbnQsIGlzU291cmNlSGFuZGxlKSA9PiB7XG4gICAgICAgICAgICAvLyBhdm9pZCB0cmlnZ2VyaW5nIGVkZ2UgdXBkYXRlciBpZiBtb3VzZSBidG4gaXMgbm90IGxlZnRcbiAgICAgICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzLCBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb25TdG9yZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVJZCA9IGlzU291cmNlSGFuZGxlID8gdGFyZ2V0IDogc291cmNlO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlSWQgPSAoaXNTb3VyY2VIYW5kbGUgPyB0YXJnZXRIYW5kbGVJZCA6IHNvdXJjZUhhbmRsZUlkKSB8fCBudWxsO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlVHlwZSA9IGlzU291cmNlSGFuZGxlID8gJ3RhcmdldCcgOiAnc291cmNlJztcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRDb25uZWN0aW9uID0gaXNWYWxpZENvbm5lY3Rpb25TdG9yZSB8fCBhbHdheXNWYWxpZENvbm5lY3Rpb247XG4gICAgICAgICAgICBjb25zdCBpc1RhcmdldCA9IGlzU291cmNlSGFuZGxlO1xuICAgICAgICAgICAgY29uc3QgZWRnZSA9IGVkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IGlkKTtcbiAgICAgICAgICAgIHNldFVwZGF0aW5nKHRydWUpO1xuICAgICAgICAgICAgb25FZGdlVXBkYXRlU3RhcnQ/LihldmVudCwgZWRnZSwgaGFuZGxlVHlwZSk7XG4gICAgICAgICAgICBjb25zdCBfb25FZGdlVXBkYXRlRW5kID0gKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFVwZGF0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBvbkVkZ2VVcGRhdGVFbmQ/LihldnQsIGVkZ2UsIGhhbmRsZVR5cGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uQ29ubmVjdEVkZ2UgPSAoY29ubmVjdGlvbikgPT4gb25FZGdlVXBkYXRlPy4oZWRnZSwgY29ubmVjdGlvbik7XG4gICAgICAgICAgICBoYW5kbGVQb2ludGVyRG93bih7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RWRnZSxcbiAgICAgICAgICAgICAgICBpc1RhcmdldCxcbiAgICAgICAgICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgICAgICAgICAgc2V0U3RhdGU6IHN0b3JlLnNldFN0YXRlLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgIGVkZ2VVcGRhdGVyVHlwZTogaGFuZGxlVHlwZSxcbiAgICAgICAgICAgICAgICBvbkVkZ2VVcGRhdGVFbmQ6IF9vbkVkZ2VVcGRhdGVFbmQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25FZGdlVXBkYXRlclNvdXJjZU1vdXNlRG93biA9IChldmVudCkgPT4gaGFuZGxlRWRnZVVwZGF0ZXIoZXZlbnQsIHRydWUpO1xuICAgICAgICBjb25zdCBvbkVkZ2VVcGRhdGVyVGFyZ2V0TW91c2VEb3duID0gKGV2ZW50KSA9PiBoYW5kbGVFZGdlVXBkYXRlcihldmVudCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBvbkVkZ2VVcGRhdGVyTW91c2VFbnRlciA9ICgpID0+IHNldFVwZGF0ZUhvdmVyKHRydWUpO1xuICAgICAgICBjb25zdCBvbkVkZ2VVcGRhdGVyTW91c2VPdXQgPSAoKSA9PiBzZXRVcGRhdGVIb3ZlcihmYWxzZSk7XG4gICAgICAgIGNvbnN0IGluYWN0aXZlID0gIWVsZW1lbnRzU2VsZWN0YWJsZSAmJiAhb25DbGljaztcbiAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFNlbGVjdGlvbktleXMuaW5jbHVkZXMoZXZlbnQua2V5KSAmJiBlbGVtZW50c1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgYWRkU2VsZWN0ZWRFZGdlcywgZWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5zZWxlY3QgPSBldmVudC5rZXkgPT09ICdFc2NhcGUnO1xuICAgICAgICAgICAgICAgIGlmICh1bnNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBlZGdlUmVmLmN1cnJlbnQ/LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKHsgZWRnZXM6IFtlZGdlcy5maW5kKChlKSA9PiBlLmlkID09PSBpZCldIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VsZWN0ZWRFZGdlcyhbaWRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgeyBjbGFzc05hbWU6IGNjKFtcbiAgICAgICAgICAgICAgICAncmVhY3QtZmxvd19fZWRnZScsXG4gICAgICAgICAgICAgICAgYHJlYWN0LWZsb3dfX2VkZ2UtJHt0eXBlfWAsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHsgc2VsZWN0ZWQsIGFuaW1hdGVkLCBpbmFjdGl2ZSwgdXBkYXRpbmc6IHVwZGF0ZUhvdmVyIH0sXG4gICAgICAgICAgICBdKSwgb25DbGljazogb25FZGdlQ2xpY2ssIG9uRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrSGFuZGxlciwgb25Db250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25Nb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlOiBvbkVkZ2VNb3VzZUxlYXZlLCBvbktleURvd246IGlzRm9jdXNhYmxlID8gb25LZXlEb3duIDogdW5kZWZpbmVkLCB0YWJJbmRleDogaXNGb2N1c2FibGUgPyAwIDogdW5kZWZpbmVkLCByb2xlOiBpc0ZvY3VzYWJsZSA/ICdidXR0b24nIDogJ2ltZycsIFwiZGF0YS10ZXN0aWRcIjogYHJmX19lZGdlLSR7aWR9YCwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFyaWFMYWJlbCA/IGFyaWFMYWJlbCA6IGBFZGdlIGZyb20gJHtzb3VyY2V9IHRvICR7dGFyZ2V0fWAsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBpc0ZvY3VzYWJsZSA/IGAke0FSSUFfRURHRV9ERVNDX0tFWX0tJHtyZklkfWAgOiB1bmRlZmluZWQsIHJlZjogZWRnZVJlZiB9LFxuICAgICAgICAgICAgIXVwZGF0aW5nICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KEVkZ2VDb21wb25lbnQsIHsgaWQ6IGlkLCBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHNlbGVjdGVkOiBzZWxlY3RlZCwgYW5pbWF0ZWQ6IGFuaW1hdGVkLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgZGF0YTogZGF0YSwgc3R5bGU6IHN0eWxlLCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgc291cmNlSGFuZGxlSWQ6IHNvdXJjZUhhbmRsZUlkLCB0YXJnZXRIYW5kbGVJZDogdGFyZ2V0SGFuZGxlSWQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydFVybCwgbWFya2VyRW5kOiBtYXJrZXJFbmRVcmwsIHBhdGhPcHRpb25zOiBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSksXG4gICAgICAgICAgICBpc1VwZGF0YWJsZSAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAoaXNVcGRhdGFibGUgPT09ICdzb3VyY2UnIHx8IGlzVXBkYXRhYmxlID09PSB0cnVlKSAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChFZGdlQW5jaG9yLCB7IHBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgY2VudGVyWDogc291cmNlWCwgY2VudGVyWTogc291cmNlWSwgcmFkaXVzOiBlZGdlVXBkYXRlclJhZGl1cywgb25Nb3VzZURvd246IG9uRWRnZVVwZGF0ZXJTb3VyY2VNb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25FZGdlVXBkYXRlck1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uRWRnZVVwZGF0ZXJNb3VzZU91dCwgdHlwZTogXCJzb3VyY2VcIiB9KSksXG4gICAgICAgICAgICAgICAgKGlzVXBkYXRhYmxlID09PSAndGFyZ2V0JyB8fCBpc1VwZGF0YWJsZSA9PT0gdHJ1ZSkgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRnZUFuY2hvciwgeyBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGNlbnRlclg6IHRhcmdldFgsIGNlbnRlclk6IHRhcmdldFksIHJhZGl1czogZWRnZVVwZGF0ZXJSYWRpdXMsIG9uTW91c2VEb3duOiBvbkVkZ2VVcGRhdGVyVGFyZ2V0TW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uRWRnZVVwZGF0ZXJNb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvbkVkZ2VVcGRhdGVyTW91c2VPdXQsIHR5cGU6IFwidGFyZ2V0XCIgfSkpKSkpKTtcbiAgICB9O1xuICAgIEVkZ2VXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ0VkZ2VXcmFwcGVyJztcbiAgICByZXR1cm4gbWVtbyhFZGdlV3JhcHBlcik7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVFZGdlVHlwZXMoZWRnZVR5cGVzKSB7XG4gICAgY29uc3Qgc3RhbmRhcmRUeXBlcyA9IHtcbiAgICAgICAgZGVmYXVsdDogd3JhcEVkZ2UoKGVkZ2VUeXBlcy5kZWZhdWx0IHx8IEJlemllckVkZ2UpKSxcbiAgICAgICAgc3RyYWlnaHQ6IHdyYXBFZGdlKChlZGdlVHlwZXMuYmV6aWVyIHx8IFN0cmFpZ2h0RWRnZSkpLFxuICAgICAgICBzdGVwOiB3cmFwRWRnZSgoZWRnZVR5cGVzLnN0ZXAgfHwgU3RlcEVkZ2UpKSxcbiAgICAgICAgc21vb3Roc3RlcDogd3JhcEVkZ2UoKGVkZ2VUeXBlcy5zdGVwIHx8IFNtb290aFN0ZXBFZGdlKSksXG4gICAgICAgIHNpbXBsZWJlemllcjogd3JhcEVkZ2UoKGVkZ2VUeXBlcy5zaW1wbGViZXppZXIgfHwgU2ltcGxlQmV6aWVyRWRnZSkpLFxuICAgIH07XG4gICAgY29uc3Qgd3JhcHBlZFR5cGVzID0ge307XG4gICAgY29uc3Qgc3BlY2lhbFR5cGVzID0gT2JqZWN0LmtleXMoZWRnZVR5cGVzKVxuICAgICAgICAuZmlsdGVyKChrKSA9PiAhWydkZWZhdWx0JywgJ2JlemllciddLmluY2x1ZGVzKGspKVxuICAgICAgICAucmVkdWNlKChyZXMsIGtleSkgPT4ge1xuICAgICAgICByZXNba2V5XSA9IHdyYXBFZGdlKChlZGdlVHlwZXNba2V5XSB8fCBCZXppZXJFZGdlKSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgd3JhcHBlZFR5cGVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGFuZGFyZFR5cGVzLFxuICAgICAgICAuLi5zcGVjaWFsVHlwZXMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZVBvc2l0aW9uKHBvc2l0aW9uLCBub2RlUmVjdCwgaGFuZGxlID0gbnVsbCkge1xuICAgIGNvbnN0IHggPSAoaGFuZGxlPy54IHx8IDApICsgbm9kZVJlY3QueDtcbiAgICBjb25zdCB5ID0gKGhhbmRsZT8ueSB8fCAwKSArIG5vZGVSZWN0Lnk7XG4gICAgY29uc3Qgd2lkdGggPSBoYW5kbGU/LndpZHRoIHx8IG5vZGVSZWN0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGhhbmRsZT8uaGVpZ2h0IHx8IG5vZGVSZWN0LmhlaWdodDtcbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uVG9wOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4ICsgd2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4ICsgd2lkdGgsXG4gICAgICAgICAgICAgICAgeTogeSArIGhlaWdodCAvIDIsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkJvdHRvbTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogeCArIHdpZHRoIC8gMixcbiAgICAgICAgICAgICAgICB5OiB5ICsgaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHk6IHkgKyBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRIYW5kbGUoYm91bmRzLCBoYW5kbGVJZCkge1xuICAgIGlmICghYm91bmRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoYm91bmRzLmxlbmd0aCA9PT0gMSB8fCAhaGFuZGxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kc1swXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kcy5maW5kKChkKSA9PiBkLmlkID09PSBoYW5kbGVJZCkgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBnZXRFZGdlUG9zaXRpb25zID0gKHNvdXJjZU5vZGVSZWN0LCBzb3VyY2VIYW5kbGUsIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXROb2RlUmVjdCwgdGFyZ2V0SGFuZGxlLCB0YXJnZXRQb3NpdGlvbikgPT4ge1xuICAgIGNvbnN0IHNvdXJjZUhhbmRsZVBvcyA9IGdldEhhbmRsZVBvc2l0aW9uKHNvdXJjZVBvc2l0aW9uLCBzb3VyY2VOb2RlUmVjdCwgc291cmNlSGFuZGxlKTtcbiAgICBjb25zdCB0YXJnZXRIYW5kbGVQb3MgPSBnZXRIYW5kbGVQb3NpdGlvbih0YXJnZXRQb3NpdGlvbiwgdGFyZ2V0Tm9kZVJlY3QsIHRhcmdldEhhbmRsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlWDogc291cmNlSGFuZGxlUG9zLngsXG4gICAgICAgIHNvdXJjZVk6IHNvdXJjZUhhbmRsZVBvcy55LFxuICAgICAgICB0YXJnZXRYOiB0YXJnZXRIYW5kbGVQb3MueCxcbiAgICAgICAgdGFyZ2V0WTogdGFyZ2V0SGFuZGxlUG9zLnksXG4gICAgfTtcbn07XG5mdW5jdGlvbiBpc0VkZ2VWaXNpYmxlKHsgc291cmNlUG9zLCB0YXJnZXRQb3MsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybSwgfSkge1xuICAgIGNvbnN0IGVkZ2VCb3ggPSB7XG4gICAgICAgIHg6IE1hdGgubWluKHNvdXJjZVBvcy54LCB0YXJnZXRQb3MueCksXG4gICAgICAgIHk6IE1hdGgubWluKHNvdXJjZVBvcy55LCB0YXJnZXRQb3MueSksXG4gICAgICAgIHgyOiBNYXRoLm1heChzb3VyY2VQb3MueCArIHNvdXJjZVdpZHRoLCB0YXJnZXRQb3MueCArIHRhcmdldFdpZHRoKSxcbiAgICAgICAgeTI6IE1hdGgubWF4KHNvdXJjZVBvcy55ICsgc291cmNlSGVpZ2h0LCB0YXJnZXRQb3MueSArIHRhcmdldEhlaWdodCksXG4gICAgfTtcbiAgICBpZiAoZWRnZUJveC54ID09PSBlZGdlQm94LngyKSB7XG4gICAgICAgIGVkZ2VCb3gueDIgKz0gMTtcbiAgICB9XG4gICAgaWYgKGVkZ2VCb3gueSA9PT0gZWRnZUJveC55Mikge1xuICAgICAgICBlZGdlQm94LnkyICs9IDE7XG4gICAgfVxuICAgIGNvbnN0IHZpZXdCb3ggPSByZWN0VG9Cb3goe1xuICAgICAgICB4OiAoMCAtIHRyYW5zZm9ybVswXSkgLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHk6ICgwIC0gdHJhbnNmb3JtWzFdKSAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgd2lkdGg6IHdpZHRoIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCAvIHRyYW5zZm9ybVsyXSxcbiAgICB9KTtcbiAgICBjb25zdCB4T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHZpZXdCb3gueDIsIGVkZ2VCb3gueDIpIC0gTWF0aC5tYXgodmlld0JveC54LCBlZGdlQm94LngpKTtcbiAgICBjb25zdCB5T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHZpZXdCb3gueTIsIGVkZ2VCb3gueTIpIC0gTWF0aC5tYXgodmlld0JveC55LCBlZGdlQm94LnkpKTtcbiAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBNYXRoLmNlaWwoeE92ZXJsYXAgKiB5T3ZlcmxhcCk7XG4gICAgcmV0dXJuIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG59XG5mdW5jdGlvbiBnZXROb2RlRGF0YShub2RlKSB7XG4gICAgY29uc3QgaGFuZGxlQm91bmRzID0gbm9kZT8uW2ludGVybmFsc1N5bWJvbF0/LmhhbmRsZUJvdW5kcyB8fCBudWxsO1xuICAgIGNvbnN0IGlzVmFsaWQgPSBoYW5kbGVCb3VuZHMgJiZcbiAgICAgICAgbm9kZT8ud2lkdGggJiZcbiAgICAgICAgbm9kZT8uaGVpZ2h0ICYmXG4gICAgICAgIHR5cGVvZiBub2RlPy5wb3NpdGlvbkFic29sdXRlPy54ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2Ygbm9kZT8ucG9zaXRpb25BYnNvbHV0ZT8ueSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgeDogbm9kZT8ucG9zaXRpb25BYnNvbHV0ZT8ueCB8fCAwLFxuICAgICAgICAgICAgeTogbm9kZT8ucG9zaXRpb25BYnNvbHV0ZT8ueSB8fCAwLFxuICAgICAgICAgICAgd2lkdGg6IG5vZGU/LndpZHRoIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IG5vZGU/LmhlaWdodCB8fCAwLFxuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVCb3VuZHMsXG4gICAgICAgICEhaXNWYWxpZCxcbiAgICBdO1xufVxuXG5jb25zdCBkZWZhdWx0RWRnZVRyZWUgPSBbeyBsZXZlbDogMCwgaXNNYXhMZXZlbDogdHJ1ZSwgZWRnZXM6IFtdIH1dO1xuZnVuY3Rpb24gZ3JvdXBFZGdlc0J5WkxldmVsKGVkZ2VzLCBub2RlSW50ZXJuYWxzLCBlbGV2YXRlRWRnZXNPblNlbGVjdCA9IGZhbHNlKSB7XG4gICAgbGV0IG1heExldmVsID0gLTE7XG4gICAgY29uc3QgbGV2ZWxMb29rdXAgPSBlZGdlcy5yZWR1Y2UoKHRyZWUsIGVkZ2UpID0+IHtcbiAgICAgICAgY29uc3QgaGFzWkluZGV4ID0gaXNOdW1lcmljKGVkZ2UuekluZGV4KTtcbiAgICAgICAgbGV0IHogPSBoYXNaSW5kZXggPyBlZGdlLnpJbmRleCA6IDA7XG4gICAgICAgIGlmIChlbGV2YXRlRWRnZXNPblNlbGVjdCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IG5vZGVJbnRlcm5hbHMuZ2V0KGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgICAgICBjb25zdCBlZGdlT3JDb25uZWN0ZWROb2RlU2VsZWN0ZWQgPSBlZGdlLnNlbGVjdGVkIHx8IHRhcmdldE5vZGU/LnNlbGVjdGVkIHx8IHNvdXJjZU5vZGU/LnNlbGVjdGVkO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRaSW5kZXggPSBNYXRoLm1heChzb3VyY2VOb2RlPy5baW50ZXJuYWxzU3ltYm9sXT8ueiB8fCAwLCB0YXJnZXROb2RlPy5baW50ZXJuYWxzU3ltYm9sXT8ueiB8fCAwLCAxMDAwKTtcbiAgICAgICAgICAgIHogPSAoaGFzWkluZGV4ID8gZWRnZS56SW5kZXggOiAwKSArIChlZGdlT3JDb25uZWN0ZWROb2RlU2VsZWN0ZWQgPyBzZWxlY3RlZFpJbmRleCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmVlW3pdKSB7XG4gICAgICAgICAgICB0cmVlW3pdLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmVlW3pdID0gW2VkZ2VdO1xuICAgICAgICB9XG4gICAgICAgIG1heExldmVsID0geiA+IG1heExldmVsID8geiA6IG1heExldmVsO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgZWRnZVRyZWUgPSBPYmplY3QuZW50cmllcyhsZXZlbExvb2t1cCkubWFwKChba2V5LCBlZGdlc10pID0+IHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSAra2V5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIGlzTWF4TGV2ZWw6IGxldmVsID09PSBtYXhMZXZlbCxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBpZiAoZWRnZVRyZWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RWRnZVRyZWU7XG4gICAgfVxuICAgIHJldHVybiBlZGdlVHJlZTtcbn1cbmZ1bmN0aW9uIHVzZVZpc2libGVFZGdlcyhvbmx5UmVuZGVyVmlzaWJsZSwgbm9kZUludGVybmFscywgZWxldmF0ZUVkZ2VzT25TZWxlY3QpIHtcbiAgICBjb25zdCBlZGdlcyA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiB7XG4gICAgICAgIGlmICghb25seVJlbmRlclZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzLmVkZ2VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzLmVkZ2VzLmZpbHRlcigoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IG5vZGVJbnRlcm5hbHMuZ2V0KGUuc291cmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBub2RlSW50ZXJuYWxzLmdldChlLnRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm4gKHNvdXJjZU5vZGU/LndpZHRoICYmXG4gICAgICAgICAgICAgICAgc291cmNlTm9kZT8uaGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZT8ud2lkdGggJiZcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlPy5oZWlnaHQgJiZcbiAgICAgICAgICAgICAgICBpc0VkZ2VWaXNpYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlUG9zOiBzb3VyY2VOb2RlLnBvc2l0aW9uQWJzb2x1dGUgfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFBvczogdGFyZ2V0Tm9kZS5wb3NpdGlvbkFic29sdXRlIHx8IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VXaWR0aDogc291cmNlTm9kZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlSGVpZ2h0OiBzb3VyY2VOb2RlLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0V2lkdGg6IHRhcmdldE5vZGUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodDogdGFyZ2V0Tm9kZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHMudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW29ubHlSZW5kZXJWaXNpYmxlLCBub2RlSW50ZXJuYWxzXSkpO1xuICAgIHJldHVybiBncm91cEVkZ2VzQnlaTGV2ZWwoZWRnZXMsIG5vZGVJbnRlcm5hbHMsIGVsZXZhdGVFZGdlc09uU2VsZWN0KTtcbn1cblxuY29uc3QgQXJyb3dTeW1ib2wgPSAoeyBjb2xvciA9ICdub25lJywgc3Ryb2tlV2lkdGggPSAxIH0pID0+IHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5bGluZVwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIH0sIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgZmlsbDogXCJub25lXCIsIHBvaW50czogXCItNSwtNCAwLDAgLTUsNFwiIH0pKTtcbn07XG5jb25zdCBBcnJvd0Nsb3NlZFN5bWJvbCA9ICh7IGNvbG9yID0gJ25vbmUnLCBzdHJva2VXaWR0aCA9IDEgfSkgPT4ge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB9LCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIHBvaW50czogXCItNSwtNCAwLDAgLTUsNCAtNSwtNFwiIH0pKTtcbn07XG5jb25zdCBNYXJrZXJTeW1ib2xzID0ge1xuICAgIFtNYXJrZXJUeXBlLkFycm93XTogQXJyb3dTeW1ib2wsXG4gICAgW01hcmtlclR5cGUuQXJyb3dDbG9zZWRdOiBBcnJvd0Nsb3NlZFN5bWJvbCxcbn07XG5mdW5jdGlvbiB1c2VNYXJrZXJTeW1ib2wodHlwZSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBzeW1ib2wgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3ltYm9sRXhpc3RzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE1hcmtlclN5bWJvbHMsIHR5cGUpO1xuICAgICAgICBpZiAoIXN5bWJvbEV4aXN0cykge1xuICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwOScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA5J10odHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hcmtlclN5bWJvbHNbdHlwZV07XG4gICAgfSwgW3R5cGVdKTtcbiAgICByZXR1cm4gc3ltYm9sO1xufVxuXG5jb25zdCBNYXJrZXIgPSAoeyBpZCwgdHlwZSwgY29sb3IsIHdpZHRoID0gMTIuNSwgaGVpZ2h0ID0gMTIuNSwgbWFya2VyVW5pdHMgPSAnc3Ryb2tlV2lkdGgnLCBzdHJva2VXaWR0aCwgb3JpZW50ID0gJ2F1dG8tc3RhcnQtcmV2ZXJzZScsIH0pID0+IHtcbiAgICBjb25zdCBTeW1ib2wgPSB1c2VNYXJrZXJTeW1ib2wodHlwZSk7XG4gICAgaWYgKCFTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcIm1hcmtlclwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19hcnJvd2hlYWRcIiwgaWQ6IGlkLCBtYXJrZXJXaWR0aDogYCR7d2lkdGh9YCwgbWFya2VySGVpZ2h0OiBgJHtoZWlnaHR9YCwgdmlld0JveDogXCItMTAgLTEwIDIwIDIwXCIsIG1hcmtlclVuaXRzOiBtYXJrZXJVbml0cywgb3JpZW50OiBvcmllbnQsIHJlZlg6IFwiMFwiLCByZWZZOiBcIjBcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFN5bWJvbCwgeyBjb2xvcjogY29sb3IsIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCB9KSkpO1xufTtcbmNvbnN0IG1hcmtlclNlbGVjdG9yID0gKHsgZGVmYXVsdENvbG9yLCByZklkIH0pID0+IChzKSA9PiB7XG4gICAgY29uc3QgaWRzID0gW107XG4gICAgcmV0dXJuIHMuZWRnZXNcbiAgICAgICAgLnJlZHVjZSgobWFya2VycywgZWRnZSkgPT4ge1xuICAgICAgICBbZWRnZS5tYXJrZXJTdGFydCwgZWRnZS5tYXJrZXJFbmRdLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtlciAmJiB0eXBlb2YgbWFya2VyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcklkID0gZ2V0TWFya2VySWQobWFya2VyLCByZklkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkcy5pbmNsdWRlcyhtYXJrZXJJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHsgaWQ6IG1hcmtlcklkLCBjb2xvcjogbWFya2VyLmNvbG9yIHx8IGRlZmF1bHRDb2xvciwgLi4ubWFya2VyIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChtYXJrZXJJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfSwgW10pXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmlkLmxvY2FsZUNvbXBhcmUoYi5pZCkpO1xufTtcbi8vIHdoZW4geW91IGhhdmUgbXVsdGlwbGUgZmxvd3Mgb24gYSBwYWdlIGFuZCB5b3UgaGlkZSB0aGUgZmlyc3Qgb25lLCB0aGUgb3RoZXIgb25lcyBoYXZlIG5vIG1hcmtlcnMgYW55bW9yZVxuLy8gd2hlbiB0aGV5IGRvIGhhdmUgbWFya2VycyB3aXRoIHRoZSBzYW1lIGlkcy4gVG8gcHJldmVudCB0aGlzIHRoZSB1c2VyIGNhbiBwYXNzIGEgdW5pcXVlIGlkIHRvIHRoZSByZWFjdCBmbG93IHdyYXBwZXJcbi8vIHRoYXQgd2UgY2FuIHRoZW4gdXNlIGZvciBjcmVhdGluZyBvdXIgdW5pcXVlIG1hcmtlciBpZHNcbmNvbnN0IE1hcmtlckRlZmluaXRpb25zID0gKHsgZGVmYXVsdENvbG9yLCByZklkIH0pID0+IHtcbiAgICBjb25zdCBtYXJrZXJzID0gdXNlU3RvcmUodXNlQ2FsbGJhY2sobWFya2VyU2VsZWN0b3IoeyBkZWZhdWx0Q29sb3IsIHJmSWQgfSksIFtkZWZhdWx0Q29sb3IsIHJmSWRdKSwgXG4gICAgLy8gdGhlIGlkIGluY2x1ZGVzIGFsbCBtYXJrZXIgb3B0aW9ucywgc28gd2UganVzdCBuZWVkIHRvIGxvb2sgYXQgdGhhdCBwYXJ0IG9mIHRoZSBtYXJrZXJcbiAgICAoYSwgYikgPT4gIShhLmxlbmd0aCAhPT0gYi5sZW5ndGggfHwgYS5zb21lKChtLCBpKSA9PiBtLmlkICE9PSBiW2ldLmlkKSkpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRlZnNcIiwgbnVsbCwgbWFya2Vycy5tYXAoKG1hcmtlcikgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya2VyLCB7IGlkOiBtYXJrZXIuaWQsIGtleTogbWFya2VyLmlkLCB0eXBlOiBtYXJrZXIudHlwZSwgY29sb3I6IG1hcmtlci5jb2xvciwgd2lkdGg6IG1hcmtlci53aWR0aCwgaGVpZ2h0OiBtYXJrZXIuaGVpZ2h0LCBtYXJrZXJVbml0czogbWFya2VyLm1hcmtlclVuaXRzLCBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoLCBvcmllbnQ6IG1hcmtlci5vcmllbnQgfSkpKSkpO1xufTtcbk1hcmtlckRlZmluaXRpb25zLmRpc3BsYXlOYW1lID0gJ01hcmtlckRlZmluaXRpb25zJztcbnZhciBNYXJrZXJEZWZpbml0aW9ucyQxID0gbWVtbyhNYXJrZXJEZWZpbml0aW9ucyk7XG5cbmNvbnN0IHNlbGVjdG9yJDQgPSAocykgPT4gKHtcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgZWRnZXNGb2N1c2FibGU6IHMuZWRnZXNGb2N1c2FibGUsXG4gICAgZWRnZXNVcGRhdGFibGU6IHMuZWRnZXNVcGRhdGFibGUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICB3aWR0aDogcy53aWR0aCxcbiAgICBoZWlnaHQ6IHMuaGVpZ2h0LFxuICAgIGNvbm5lY3Rpb25Nb2RlOiBzLmNvbm5lY3Rpb25Nb2RlLFxuICAgIG5vZGVJbnRlcm5hbHM6IHMubm9kZUludGVybmFscyxcbiAgICBvbkVycm9yOiBzLm9uRXJyb3IsXG59KTtcbmNvbnN0IEVkZ2VSZW5kZXJlciA9ICh7IGRlZmF1bHRNYXJrZXJDb2xvciwgb25seVJlbmRlclZpc2libGVFbGVtZW50cywgZWxldmF0ZUVkZ2VzT25TZWxlY3QsIHJmSWQsIGVkZ2VUeXBlcywgbm9QYW5DbGFzc05hbWUsIG9uRWRnZVVwZGF0ZSwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgb25FZGdlQ2xpY2ssIGVkZ2VVcGRhdGVyUmFkaXVzLCBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlVXBkYXRlU3RhcnQsIG9uRWRnZVVwZGF0ZUVuZCwgY2hpbGRyZW4sIH0pID0+IHtcbiAgICBjb25zdCB7IGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1VwZGF0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCB3aWR0aCwgaGVpZ2h0LCBjb25uZWN0aW9uTW9kZSwgbm9kZUludGVybmFscywgb25FcnJvciB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkNCwgc2hhbGxvdyk7XG4gICAgY29uc3QgZWRnZVRyZWUgPSB1c2VWaXNpYmxlRWRnZXMob25seVJlbmRlclZpc2libGVFbGVtZW50cywgbm9kZUludGVybmFscywgZWxldmF0ZUVkZ2VzT25TZWxlY3QpO1xuICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgZWRnZVRyZWUubWFwKCh7IGxldmVsLCBlZGdlcywgaXNNYXhMZXZlbCB9KSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IGtleTogbGV2ZWwsIHN0eWxlOiB7IHpJbmRleDogbGV2ZWwgfSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2VzIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICBpc01heExldmVsICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya2VyRGVmaW5pdGlvbnMkMSwgeyBkZWZhdWx0Q29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgcmZJZDogcmZJZCB9KSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIG51bGwsIGVkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzb3VyY2VOb2RlUmVjdCwgc291cmNlSGFuZGxlQm91bmRzLCBzb3VyY2VJc1ZhbGlkXSA9IGdldE5vZGVEYXRhKG5vZGVJbnRlcm5hbHMuZ2V0KGVkZ2Uuc291cmNlKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgW3RhcmdldE5vZGVSZWN0LCB0YXJnZXRIYW5kbGVCb3VuZHMsIHRhcmdldElzVmFsaWRdID0gZ2V0Tm9kZURhdGEobm9kZUludGVybmFscy5nZXQoZWRnZS50YXJnZXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZUlzVmFsaWQgfHwgIXRhcmdldElzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBlZGdlVHlwZSA9IGVkZ2UudHlwZSB8fCAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgaWYgKCFlZGdlVHlwZXNbZWRnZVR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I/LignMDExJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTEnXShlZGdlVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBlZGdlVHlwZSA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgRWRnZUNvbXBvbmVudCA9IGVkZ2VUeXBlc1tlZGdlVHlwZV0gfHwgZWRnZVR5cGVzLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjb25uZWN0aW9uIHR5cGUgaXMgbG9vc2Ugd2UgY2FuIGRlZmluZSBhbGwgaGFuZGxlcyBhcyBzb3VyY2VzIGFuZCBjb25uZWN0IHNvdXJjZSAtPiBzb3VyY2VcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlSGFuZGxlcyA9IGNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5TdHJpY3RcbiAgICAgICAgICAgICAgICAgICAgPyB0YXJnZXRIYW5kbGVCb3VuZHMudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIDogKHRhcmdldEhhbmRsZUJvdW5kcy50YXJnZXQgPz8gW10pLmNvbmNhdCh0YXJnZXRIYW5kbGVCb3VuZHMuc291cmNlID8/IFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VIYW5kbGUgPSBnZXRIYW5kbGUoc291cmNlSGFuZGxlQm91bmRzLnNvdXJjZSwgZWRnZS5zb3VyY2VIYW5kbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEhhbmRsZSA9IGdldEhhbmRsZSh0YXJnZXROb2RlSGFuZGxlcywgZWRnZS50YXJnZXRIYW5kbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gc291cmNlSGFuZGxlPy5wb3NpdGlvbiB8fCBQb3NpdGlvbi5Cb3R0b207XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRIYW5kbGU/LnBvc2l0aW9uIHx8IFBvc2l0aW9uLlRvcDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKGVkZ2UuZm9jdXNhYmxlIHx8IChlZGdlc0ZvY3VzYWJsZSAmJiB0eXBlb2YgZWRnZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNVcGRhdGFibGUgPSB0eXBlb2Ygb25FZGdlVXBkYXRlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAoZWRnZS51cGRhdGFibGUgfHwgKGVkZ2VzVXBkYXRhYmxlICYmIHR5cGVvZiBlZGdlLnVwZGF0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZUhhbmRsZSB8fCAhdGFyZ2V0SGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I/LignMDA4JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDgnXShzb3VyY2VIYW5kbGUsIGVkZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSB9ID0gZ2V0RWRnZVBvc2l0aW9ucyhzb3VyY2VOb2RlUmVjdCwgc291cmNlSGFuZGxlLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0Tm9kZVJlY3QsIHRhcmdldEhhbmRsZSwgdGFyZ2V0UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChFZGdlQ29tcG9uZW50LCB7IGtleTogZWRnZS5pZCwgaWQ6IGVkZ2UuaWQsIGNsYXNzTmFtZTogY2MoW2VkZ2UuY2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZV0pLCB0eXBlOiBlZGdlVHlwZSwgZGF0YTogZWRnZS5kYXRhLCBzZWxlY3RlZDogISFlZGdlLnNlbGVjdGVkLCBhbmltYXRlZDogISFlZGdlLmFuaW1hdGVkLCBoaWRkZW46ICEhZWRnZS5oaWRkZW4sIGxhYmVsOiBlZGdlLmxhYmVsLCBsYWJlbFN0eWxlOiBlZGdlLmxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBlZGdlLmxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGVkZ2UubGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogZWRnZS5sYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogZWRnZS5sYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogZWRnZS5zdHlsZSwgc291cmNlOiBlZGdlLnNvdXJjZSwgdGFyZ2V0OiBlZGdlLnRhcmdldCwgc291cmNlSGFuZGxlSWQ6IGVkZ2Uuc291cmNlSGFuZGxlLCB0YXJnZXRIYW5kbGVJZDogZWRnZS50YXJnZXRIYW5kbGUsIG1hcmtlckVuZDogZWRnZS5tYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBlZGdlLm1hcmtlclN0YXJ0LCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIG9uRWRnZVVwZGF0ZTogb25FZGdlVXBkYXRlLCBvbkNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25Nb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIG9uQ2xpY2s6IG9uRWRnZUNsaWNrLCBlZGdlVXBkYXRlclJhZGl1czogZWRnZVVwZGF0ZXJSYWRpdXMsIG9uRWRnZURvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlVXBkYXRlU3RhcnQ6IG9uRWRnZVVwZGF0ZVN0YXJ0LCBvbkVkZ2VVcGRhdGVFbmQ6IG9uRWRnZVVwZGF0ZUVuZCwgcmZJZDogcmZJZCwgYXJpYUxhYmVsOiBlZGdlLmFyaWFMYWJlbCwgaXNGb2N1c2FibGU6IGlzRm9jdXNhYmxlLCBpc1VwZGF0YWJsZTogaXNVcGRhdGFibGUsIHBhdGhPcHRpb25zOiAncGF0aE9wdGlvbnMnIGluIGVkZ2UgPyBlZGdlLnBhdGhPcHRpb25zIDogdW5kZWZpbmVkLCBpbnRlcmFjdGlvbldpZHRoOiBlZGdlLmludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgICAgICAgICAgfSkpKSkpLFxuICAgICAgICBjaGlsZHJlbikpO1xufTtcbkVkZ2VSZW5kZXJlci5kaXNwbGF5TmFtZSA9ICdFZGdlUmVuZGVyZXInO1xudmFyIEVkZ2VSZW5kZXJlciQxID0gbWVtbyhFZGdlUmVuZGVyZXIpO1xuXG5jb25zdCBzZWxlY3RvciQzID0gKHMpID0+IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSlgO1xuZnVuY3Rpb24gVmlld3BvcnQoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdXNlU3RvcmUoc2VsZWN0b3IkMyk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3ZpZXdwb3J0IHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBzdHlsZTogeyB0cmFuc2Zvcm0gfSB9LCBjaGlsZHJlbikpO1xufVxuXG5mdW5jdGlvbiB1c2VPbkluaXRIYW5kbGVyKG9uSW5pdCkge1xuICAgIGNvbnN0IHJmSW5zdGFuY2UgPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBpc0luaXRpYWxpemVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWlzSW5pdGlhbGl6ZWQuY3VycmVudCAmJiByZkluc3RhbmNlLnZpZXdwb3J0SW5pdGlhbGl6ZWQgJiYgb25Jbml0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG9uSW5pdChyZkluc3RhbmNlKSwgMSk7XG4gICAgICAgICAgICBpc0luaXRpYWxpemVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSwgW29uSW5pdCwgcmZJbnN0YW5jZS52aWV3cG9ydEluaXRpYWxpemVkXSk7XG59XG5cbmNvbnN0IG9wcG9zaXRlUG9zaXRpb24gPSB7XG4gICAgW1Bvc2l0aW9uLkxlZnRdOiBQb3NpdGlvbi5SaWdodCxcbiAgICBbUG9zaXRpb24uUmlnaHRdOiBQb3NpdGlvbi5MZWZ0LFxuICAgIFtQb3NpdGlvbi5Ub3BdOiBQb3NpdGlvbi5Cb3R0b20sXG4gICAgW1Bvc2l0aW9uLkJvdHRvbV06IFBvc2l0aW9uLlRvcCxcbn07XG5jb25zdCBDb25uZWN0aW9uTGluZSA9ICh7IG5vZGVJZCwgaGFuZGxlVHlwZSwgc3R5bGUsIHR5cGUgPSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyLCBDdXN0b21Db21wb25lbnQsIGNvbm5lY3Rpb25TdGF0dXMsIH0pID0+IHtcbiAgICBjb25zdCB7IGZyb21Ob2RlLCBoYW5kbGVJZCwgdG9YLCB0b1ksIGNvbm5lY3Rpb25Nb2RlIH0gPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4gKHtcbiAgICAgICAgZnJvbU5vZGU6IHMubm9kZUludGVybmFscy5nZXQobm9kZUlkKSxcbiAgICAgICAgaGFuZGxlSWQ6IHMuY29ubmVjdGlvbkhhbmRsZUlkLFxuICAgICAgICB0b1g6IChzLmNvbm5lY3Rpb25Qb3NpdGlvbi54IC0gcy50cmFuc2Zvcm1bMF0pIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIHRvWTogKHMuY29ubmVjdGlvblBvc2l0aW9uLnkgLSBzLnRyYW5zZm9ybVsxXSkgLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgY29ubmVjdGlvbk1vZGU6IHMuY29ubmVjdGlvbk1vZGUsXG4gICAgfSksIFtub2RlSWRdKSwgc2hhbGxvdyk7XG4gICAgY29uc3QgZnJvbUhhbmRsZUJvdW5kcyA9IGZyb21Ob2RlPy5baW50ZXJuYWxzU3ltYm9sXT8uaGFuZGxlQm91bmRzO1xuICAgIGxldCBoYW5kbGVCb3VuZHMgPSBmcm9tSGFuZGxlQm91bmRzPy5baGFuZGxlVHlwZV07XG4gICAgaWYgKGNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5Mb29zZSkge1xuICAgICAgICBoYW5kbGVCb3VuZHMgPSBoYW5kbGVCb3VuZHMgPyBoYW5kbGVCb3VuZHMgOiBmcm9tSGFuZGxlQm91bmRzPy5baGFuZGxlVHlwZSA9PT0gJ3NvdXJjZScgPyAndGFyZ2V0JyA6ICdzb3VyY2UnXTtcbiAgICB9XG4gICAgaWYgKCFmcm9tTm9kZSB8fCAhaGFuZGxlQm91bmRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSGFuZGxlID0gaGFuZGxlSWQgPyBoYW5kbGVCb3VuZHMuZmluZCgoZCkgPT4gZC5pZCA9PT0gaGFuZGxlSWQpIDogaGFuZGxlQm91bmRzWzBdO1xuICAgIGNvbnN0IGZyb21IYW5kbGVYID0gZnJvbUhhbmRsZSA/IGZyb21IYW5kbGUueCArIGZyb21IYW5kbGUud2lkdGggLyAyIDogKGZyb21Ob2RlLndpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCBmcm9tSGFuZGxlWSA9IGZyb21IYW5kbGUgPyBmcm9tSGFuZGxlLnkgKyBmcm9tSGFuZGxlLmhlaWdodCAvIDIgOiBmcm9tTm9kZS5oZWlnaHQgPz8gMDtcbiAgICBjb25zdCBmcm9tWCA9IChmcm9tTm9kZS5wb3NpdGlvbkFic29sdXRlPy54ID8/IDApICsgZnJvbUhhbmRsZVg7XG4gICAgY29uc3QgZnJvbVkgPSAoZnJvbU5vZGUucG9zaXRpb25BYnNvbHV0ZT8ueSA/PyAwKSArIGZyb21IYW5kbGVZO1xuICAgIGNvbnN0IGZyb21Qb3NpdGlvbiA9IGZyb21IYW5kbGU/LnBvc2l0aW9uO1xuICAgIGNvbnN0IHRvUG9zaXRpb24gPSBmcm9tUG9zaXRpb24gPyBvcHBvc2l0ZVBvc2l0aW9uW2Zyb21Qb3NpdGlvbl0gOiBudWxsO1xuICAgIGlmICghZnJvbVBvc2l0aW9uIHx8ICF0b1Bvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoQ3VzdG9tQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDdXN0b21Db21wb25lbnQsIHsgY29ubmVjdGlvbkxpbmVUeXBlOiB0eXBlLCBjb25uZWN0aW9uTGluZVN0eWxlOiBzdHlsZSwgZnJvbU5vZGU6IGZyb21Ob2RlLCBmcm9tSGFuZGxlOiBmcm9tSGFuZGxlLCBmcm9tWDogZnJvbVgsIGZyb21ZOiBmcm9tWSwgdG9YOiB0b1gsIHRvWTogdG9ZLCBmcm9tUG9zaXRpb246IGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbjogdG9Qb3NpdGlvbiwgY29ubmVjdGlvblN0YXR1czogY29ubmVjdGlvblN0YXR1cyB9KSk7XG4gICAgfVxuICAgIGxldCBkQXR0ciA9ICcnO1xuICAgIGNvbnN0IHBhdGhQYXJhbXMgPSB7XG4gICAgICAgIHNvdXJjZVg6IGZyb21YLFxuICAgICAgICBzb3VyY2VZOiBmcm9tWSxcbiAgICAgICAgc291cmNlUG9zaXRpb246IGZyb21Qb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0WDogdG9YLFxuICAgICAgICB0YXJnZXRZOiB0b1ksXG4gICAgICAgIHRhcmdldFBvc2l0aW9uOiB0b1Bvc2l0aW9uLFxuICAgIH07XG4gICAgaWYgKHR5cGUgPT09IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIpIHtcbiAgICAgICAgLy8gd2UgYXNzdW1lIHRoZSBkZXN0aW5hdGlvbiBwb3NpdGlvbiBpcyBvcHBvc2l0ZSB0byB0aGUgc291cmNlIHBvc2l0aW9uXG4gICAgICAgIFtkQXR0cl0gPSBnZXRCZXppZXJQYXRoKHBhdGhQYXJhbXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBDb25uZWN0aW9uTGluZVR5cGUuU3RlcCkge1xuICAgICAgICBbZEF0dHJdID0gZ2V0U21vb3RoU3RlcFBhdGgoe1xuICAgICAgICAgICAgLi4ucGF0aFBhcmFtcyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IENvbm5lY3Rpb25MaW5lVHlwZS5TbW9vdGhTdGVwKSB7XG4gICAgICAgIFtkQXR0cl0gPSBnZXRTbW9vdGhTdGVwUGF0aChwYXRoUGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gQ29ubmVjdGlvbkxpbmVUeXBlLlNpbXBsZUJlemllcikge1xuICAgICAgICBbZEF0dHJdID0gZ2V0U2ltcGxlQmV6aWVyUGF0aChwYXRoUGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRBdHRyID0gYE0ke2Zyb21YfSwke2Zyb21ZfSAke3RvWH0sJHt0b1l9YDtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogZEF0dHIsIGZpbGw6IFwibm9uZVwiLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29ubmVjdGlvbi1wYXRoXCIsIHN0eWxlOiBzdHlsZSB9KTtcbn07XG5Db25uZWN0aW9uTGluZS5kaXNwbGF5TmFtZSA9ICdDb25uZWN0aW9uTGluZSc7XG5jb25zdCBzZWxlY3RvciQyID0gKHMpID0+ICh7XG4gICAgbm9kZUlkOiBzLmNvbm5lY3Rpb25Ob2RlSWQsXG4gICAgaGFuZGxlVHlwZTogcy5jb25uZWN0aW9uSGFuZGxlVHlwZSxcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgY29ubmVjdGlvblN0YXR1czogcy5jb25uZWN0aW9uU3RhdHVzLFxuICAgIHdpZHRoOiBzLndpZHRoLFxuICAgIGhlaWdodDogcy5oZWlnaHQsXG59KTtcbmZ1bmN0aW9uIENvbm5lY3Rpb25MaW5lV3JhcHBlcih7IGNvbnRhaW5lclN0eWxlLCBzdHlsZSwgdHlwZSwgY29tcG9uZW50IH0pIHtcbiAgICBjb25zdCB7IG5vZGVJZCwgaGFuZGxlVHlwZSwgbm9kZXNDb25uZWN0YWJsZSwgd2lkdGgsIGhlaWdodCwgY29ubmVjdGlvblN0YXR1cyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkMiwgc2hhbGxvdyk7XG4gICAgY29uc3QgaXNWYWxpZCA9ICEhKG5vZGVJZCAmJiBoYW5kbGVUeXBlICYmIHdpZHRoICYmIG5vZGVzQ29ubmVjdGFibGUpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgc3R5bGU6IGNvbnRhaW5lclN0eWxlLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZXMgcmVhY3QtZmxvd19fY29ubmVjdGlvbmxpbmUgcmVhY3QtZmxvd19fY29udGFpbmVyXCIgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fY29ubmVjdGlvbicsIGNvbm5lY3Rpb25TdGF0dXNdKSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0aW9uTGluZSwgeyBub2RlSWQ6IG5vZGVJZCwgaGFuZGxlVHlwZTogaGFuZGxlVHlwZSwgc3R5bGU6IHN0eWxlLCB0eXBlOiB0eXBlLCBDdXN0b21Db21wb25lbnQ6IGNvbXBvbmVudCwgY29ubmVjdGlvblN0YXR1czogY29ubmVjdGlvblN0YXR1cyB9KSkpKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHVzZU5vZGVPckVkZ2VUeXBlcyhub2RlT3JFZGdlVHlwZXMsIGNyZWF0ZVR5cGVzKSB7XG4gICAgY29uc3QgdHlwZXNLZXlzUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB0eXBlc1BhcnNlZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVLZXlzID0gT2JqZWN0LmtleXMobm9kZU9yRWRnZVR5cGVzKTtcbiAgICAgICAgICAgIGlmIChzaGFsbG93KHR5cGVzS2V5c1JlZi5jdXJyZW50LCB0eXBlS2V5cykpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDAyJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDInXSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzS2V5c1JlZi5jdXJyZW50ID0gdHlwZUtleXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVR5cGVzKG5vZGVPckVkZ2VUeXBlcyk7XG4gICAgfSwgW25vZGVPckVkZ2VUeXBlc10pO1xuICAgIHJldHVybiB0eXBlc1BhcnNlZDtcbn1cblxuY29uc3QgR3JhcGhWaWV3ID0gKHsgbm9kZVR5cGVzLCBlZGdlVHlwZXMsIG9uTW92ZSwgb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZCwgb25Jbml0LCBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2ssIG9uTm9kZURvdWJsZUNsaWNrLCBvbkVkZ2VEb3VibGVDbGljaywgb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudSwgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIGNvbm5lY3Rpb25MaW5lVHlwZSwgY29ubmVjdGlvbkxpbmVTdHlsZSwgY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZywgc2VsZWN0aW9uTW9kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBkZWxldGVLZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBlbGVtZW50c1NlbGVjdGFibGUsIHNlbGVjdE5vZGVzT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZywgZGVmYXVsdE1hcmtlckNvbG9yLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51LCBvbkVkZ2VVcGRhdGUsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIGVkZ2VVcGRhdGVyUmFkaXVzLCBvbkVkZ2VVcGRhdGVTdGFydCwgb25FZGdlVXBkYXRlRW5kLCBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBlbGV2YXRlRWRnZXNPblNlbGVjdCwgZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgcmZJZCwgfSkgPT4ge1xuICAgIGNvbnN0IG5vZGVUeXBlc1dyYXBwZWQgPSB1c2VOb2RlT3JFZGdlVHlwZXMobm9kZVR5cGVzLCBjcmVhdGVOb2RlVHlwZXMpO1xuICAgIGNvbnN0IGVkZ2VUeXBlc1dyYXBwZWQgPSB1c2VOb2RlT3JFZGdlVHlwZXMoZWRnZVR5cGVzLCBjcmVhdGVFZGdlVHlwZXMpO1xuICAgIHVzZU9uSW5pdEhhbmRsZXIob25Jbml0KTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvd1JlbmRlcmVyJDEsIHsgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGw6IG9uUGFuZVNjcm9sbCwgZGVsZXRlS2V5Q29kZTogZGVsZXRlS2V5Q29kZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlOiBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlOiBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlOiB6b29tQWN0aXZhdGlvbktleUNvZGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBvbk1vdmU6IG9uTW92ZSwgb25Nb3ZlU3RhcnQ6IG9uTW92ZVN0YXJ0LCBvbk1vdmVFbmQ6IG9uTW92ZUVuZCwgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBvblNlbGVjdGlvbkNvbnRleHRNZW51OiBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVmlld3BvcnQsIG51bGwsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEVkZ2VSZW5kZXJlciQxLCB7IGVkZ2VUeXBlczogZWRnZVR5cGVzV3JhcHBlZCwgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbkVkZ2VEb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uRWRnZVVwZGF0ZTogb25FZGdlVXBkYXRlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBvbkVkZ2VDb250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlOiBvbkVkZ2VNb3VzZUxlYXZlLCBvbkVkZ2VVcGRhdGVTdGFydDogb25FZGdlVXBkYXRlU3RhcnQsIG9uRWRnZVVwZGF0ZUVuZDogb25FZGdlVXBkYXRlRW5kLCBlZGdlVXBkYXRlclJhZGl1czogZWRnZVVwZGF0ZXJSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIGVsZXZhdGVFZGdlc09uU2VsZWN0OiAhIWVsZXZhdGVFZGdlc09uU2VsZWN0LCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCByZklkOiByZklkIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0aW9uTGluZVdyYXBwZXIsIHsgc3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIHR5cGU6IGNvbm5lY3Rpb25MaW5lVHlwZSwgY29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29udGFpbmVyU3R5bGU6IGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUgfSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlbGFiZWwtcmVuZGVyZXJcIiB9KSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTm9kZVJlbmRlcmVyJDEsIHsgbm9kZVR5cGVzOiBub2RlVHlwZXNXcmFwcGVkLCBvbk5vZGVDbGljazogb25Ob2RlQ2xpY2ssIG9uTm9kZURvdWJsZUNsaWNrOiBvbk5vZGVEb3VibGVDbGljaywgb25Ob2RlTW91c2VFbnRlcjogb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlOiBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmU6IG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51OiBvbk5vZGVDb250ZXh0TWVudSwgc2VsZWN0Tm9kZXNPbkRyYWc6IHNlbGVjdE5vZGVzT25EcmFnLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG5vRHJhZ0NsYXNzTmFtZTogbm9EcmFnQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCByZklkOiByZklkIH0pKSkpO1xufTtcbkdyYXBoVmlldy5kaXNwbGF5TmFtZSA9ICdHcmFwaFZpZXcnO1xudmFyIEdyYXBoVmlldyQxID0gbWVtbyhHcmFwaFZpZXcpO1xuXG5jb25zdCBpbmZpbml0ZUV4dGVudCA9IFtcbiAgICBbTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFldLFxuICAgIFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0sXG5dO1xuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIHJmSWQ6ICcxJyxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgdHJhbnNmb3JtOiBbMCwgMCwgMV0sXG4gICAgbm9kZUludGVybmFsczogbmV3IE1hcCgpLFxuICAgIGVkZ2VzOiBbXSxcbiAgICBvbk5vZGVzQ2hhbmdlOiBudWxsLFxuICAgIG9uRWRnZXNDaGFuZ2U6IG51bGwsXG4gICAgaGFzRGVmYXVsdE5vZGVzOiBmYWxzZSxcbiAgICBoYXNEZWZhdWx0RWRnZXM6IGZhbHNlLFxuICAgIGQzWm9vbTogbnVsbCxcbiAgICBkM1NlbGVjdGlvbjogbnVsbCxcbiAgICBkM1pvb21IYW5kbGVyOiB1bmRlZmluZWQsXG4gICAgbWluWm9vbTogMC41LFxuICAgIG1heFpvb206IDIsXG4gICAgdHJhbnNsYXRlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICBub2RlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgY29ubmVjdGlvbk5vZGVJZDogbnVsbCxcbiAgICBjb25uZWN0aW9uSGFuZGxlSWQ6IG51bGwsXG4gICAgY29ubmVjdGlvbkhhbmRsZVR5cGU6ICdzb3VyY2UnLFxuICAgIGNvbm5lY3Rpb25Qb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgY29ubmVjdGlvblN0YXR1czogbnVsbCxcbiAgICBjb25uZWN0aW9uTW9kZTogQ29ubmVjdGlvbk1vZGUuU3RyaWN0LFxuICAgIGRvbU5vZGU6IG51bGwsXG4gICAgcGFuZURyYWdnaW5nOiBmYWxzZSxcbiAgICBub1BhbkNsYXNzTmFtZTogJ25vcGFuJyxcbiAgICBub2RlT3JpZ2luOiBbMCwgMF0sXG4gICAgbm9kZURyYWdUaHJlc2hvbGQ6IDAsXG4gICAgc25hcEdyaWQ6IFsxNSwgMTVdLFxuICAgIHNuYXBUb0dyaWQ6IGZhbHNlLFxuICAgIG5vZGVzRHJhZ2dhYmxlOiB0cnVlLFxuICAgIG5vZGVzQ29ubmVjdGFibGU6IHRydWUsXG4gICAgbm9kZXNGb2N1c2FibGU6IHRydWUsXG4gICAgZWRnZXNGb2N1c2FibGU6IHRydWUsXG4gICAgZWRnZXNVcGRhdGFibGU6IHRydWUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiB0cnVlLFxuICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0OiB0cnVlLFxuICAgIGZpdFZpZXdPbkluaXQ6IGZhbHNlLFxuICAgIGZpdFZpZXdPbkluaXREb25lOiBmYWxzZSxcbiAgICBmaXRWaWV3T25Jbml0T3B0aW9uczogdW5kZWZpbmVkLFxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlOiBbXSxcbiAgICBtdWx0aVNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgY29ubmVjdGlvblN0YXJ0SGFuZGxlOiBudWxsLFxuICAgIGNvbm5lY3Rpb25FbmRIYW5kbGU6IG51bGwsXG4gICAgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwsXG4gICAgY29ubmVjdE9uQ2xpY2s6IHRydWUsXG4gICAgYXJpYUxpdmVNZXNzYWdlOiAnJyxcbiAgICBhdXRvUGFuT25Db25uZWN0OiB0cnVlLFxuICAgIGF1dG9QYW5Pbk5vZGVEcmFnOiB0cnVlLFxuICAgIGNvbm5lY3Rpb25SYWRpdXM6IDIwLFxuICAgIG9uRXJyb3I6IGRldldhcm4sXG4gICAgaXNWYWxpZENvbm5lY3Rpb246IHVuZGVmaW5lZCxcbn07XG5cbmNvbnN0IGNyZWF0ZVJGU3RvcmUgPSAoKSA9PiBjcmVhdGVXaXRoRXF1YWxpdHlGbigoc2V0LCBnZXQpID0+ICh7XG4gICAgLi4uaW5pdGlhbFN0YXRlLFxuICAgIHNldE5vZGVzOiAobm9kZXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBub2RlSW50ZXJuYWxzLCBub2RlT3JpZ2luLCBlbGV2YXRlTm9kZXNPblNlbGVjdCB9ID0gZ2V0KCk7XG4gICAgICAgIHNldCh7IG5vZGVJbnRlcm5hbHM6IGNyZWF0ZU5vZGVJbnRlcm5hbHMobm9kZXMsIG5vZGVJbnRlcm5hbHMsIG5vZGVPcmlnaW4sIGVsZXZhdGVOb2Rlc09uU2VsZWN0KSB9KTtcbiAgICB9LFxuICAgIGdldE5vZGVzOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGdldCgpLm5vZGVJbnRlcm5hbHMudmFsdWVzKCkpO1xuICAgIH0sXG4gICAgc2V0RWRnZXM6IChlZGdlcykgPT4ge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRFZGdlT3B0aW9ucyA9IHt9IH0gPSBnZXQoKTtcbiAgICAgICAgc2V0KHsgZWRnZXM6IGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZGVmYXVsdEVkZ2VPcHRpb25zLCAuLi5lIH0pKSB9KTtcbiAgICB9LFxuICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzOiAobm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc0RlZmF1bHROb2RlcyA9IHR5cGVvZiBub2RlcyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGNvbnN0IGhhc0RlZmF1bHRFZGdlcyA9IHR5cGVvZiBlZGdlcyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGNvbnN0IG5vZGVJbnRlcm5hbHMgPSBoYXNEZWZhdWx0Tm9kZXNcbiAgICAgICAgICAgID8gY3JlYXRlTm9kZUludGVybmFscyhub2RlcywgbmV3IE1hcCgpLCBnZXQoKS5ub2RlT3JpZ2luLCBnZXQoKS5lbGV2YXRlTm9kZXNPblNlbGVjdClcbiAgICAgICAgICAgIDogbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBuZXh0RWRnZXMgPSBoYXNEZWZhdWx0RWRnZXMgPyBlZGdlcyA6IFtdO1xuICAgICAgICBzZXQoeyBub2RlSW50ZXJuYWxzLCBlZGdlczogbmV4dEVkZ2VzLCBoYXNEZWZhdWx0Tm9kZXMsIGhhc0RlZmF1bHRFZGdlcyB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZU5vZGVEaW1lbnNpb25zOiAodXBkYXRlcykgPT4ge1xuICAgICAgICBjb25zdCB7IG9uTm9kZXNDaGFuZ2UsIG5vZGVJbnRlcm5hbHMsIGZpdFZpZXdPbkluaXQsIGZpdFZpZXdPbkluaXREb25lLCBmaXRWaWV3T25Jbml0T3B0aW9ucywgZG9tTm9kZSwgbm9kZU9yaWdpbiwgfSA9IGdldCgpO1xuICAgICAgICBjb25zdCB2aWV3cG9ydE5vZGUgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fdmlld3BvcnQnKTtcbiAgICAgICAgaWYgKCF2aWV3cG9ydE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHZpZXdwb3J0Tm9kZSk7XG4gICAgICAgIGNvbnN0IHsgbTIyOiB6b29tIH0gPSBuZXcgd2luZG93LkRPTU1hdHJpeFJlYWRPbmx5KHN0eWxlLnRyYW5zZm9ybSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSB1cGRhdGVzLnJlZHVjZSgocmVzLCB1cGRhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlSW50ZXJuYWxzLmdldCh1cGRhdGUuaWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyh1cGRhdGUubm9kZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvVXBkYXRlID0gISEoZGltZW5zaW9ucy53aWR0aCAmJlxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCAmJlxuICAgICAgICAgICAgICAgICAgICAobm9kZS53aWR0aCAhPT0gZGltZW5zaW9ucy53aWR0aCB8fCBub2RlLmhlaWdodCAhPT0gZGltZW5zaW9ucy5oZWlnaHQgfHwgdXBkYXRlLmZvcmNlVXBkYXRlKSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbnRlcm5hbHMuc2V0KG5vZGUuaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBbaW50ZXJuYWxzU3ltYm9sXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5vZGVbaW50ZXJuYWxzU3ltYm9sXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBnZXRIYW5kbGVCb3VuZHMoJy5zb3VyY2UnLCB1cGRhdGUubm9kZUVsZW1lbnQsIHpvb20sIG5vZGVPcmlnaW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGdldEhhbmRsZUJvdW5kcygnLnRhcmdldCcsIHVwZGF0ZS5ub2RlRWxlbWVudCwgem9vbSwgbm9kZU9yaWdpbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHVwZGF0ZUFic29sdXRlTm9kZVBvc2l0aW9ucyhub2RlSW50ZXJuYWxzLCBub2RlT3JpZ2luKTtcbiAgICAgICAgY29uc3QgbmV4dEZpdFZpZXdPbkluaXREb25lID0gZml0Vmlld09uSW5pdERvbmUgfHxcbiAgICAgICAgICAgIChmaXRWaWV3T25Jbml0ICYmICFmaXRWaWV3T25Jbml0RG9uZSAmJiBmaXRWaWV3KGdldCwgeyBpbml0aWFsOiB0cnVlLCAuLi5maXRWaWV3T25Jbml0T3B0aW9ucyB9KSk7XG4gICAgICAgIHNldCh7IG5vZGVJbnRlcm5hbHM6IG5ldyBNYXAobm9kZUludGVybmFscyksIGZpdFZpZXdPbkluaXREb25lOiBuZXh0Rml0Vmlld09uSW5pdERvbmUgfSk7XG4gICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnM6IChub2RlRHJhZ0l0ZW1zLCBwb3NpdGlvbkNoYW5nZWQgPSB0cnVlLCBkcmFnZ2luZyA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHJpZ2dlck5vZGVDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5vZGVEcmFnSXRlbXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnBvc2l0aW9uQWJzb2x1dGUgPSBub2RlLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgfSxcbiAgICB0cmlnZ2VyTm9kZUNoYW5nZXM6IChjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25Ob2Rlc0NoYW5nZSwgbm9kZUludGVybmFscywgaGFzRGVmYXVsdE5vZGVzLCBub2RlT3JpZ2luLCBnZXROb2RlcywgZWxldmF0ZU5vZGVzT25TZWxlY3QgfSA9IGdldCgpO1xuICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIGdldE5vZGVzKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlSW50ZXJuYWxzID0gY3JlYXRlTm9kZUludGVybmFscyhub2Rlcywgbm9kZUludGVybmFscywgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QpO1xuICAgICAgICAgICAgICAgIHNldCh7IG5vZGVJbnRlcm5hbHM6IG5leHROb2RlSW50ZXJuYWxzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhZGRTZWxlY3RlZE5vZGVzOiAoc2VsZWN0ZWROb2RlSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VzLCBnZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGxldCBjaGFuZ2VkTm9kZXM7XG4gICAgICAgIGxldCBjaGFuZ2VkRWRnZXMgPSBudWxsO1xuICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyA9IHNlbGVjdGVkTm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKG5vZGVJZCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlZE5vZGVzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhnZXROb2RlcygpLCBzZWxlY3RlZE5vZGVJZHMpO1xuICAgICAgICAgICAgY2hhbmdlZEVkZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlcywgW10pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZU5vZGVzQW5kRWRnZXNTZWxlY3Rpb25zKHtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyxcbiAgICAgICAgICAgIGNoYW5nZWRFZGdlcyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHNldCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBhZGRTZWxlY3RlZEVkZ2VzOiAoc2VsZWN0ZWRFZGdlSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VzLCBnZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGxldCBjaGFuZ2VkRWRnZXM7XG4gICAgICAgIGxldCBjaGFuZ2VkTm9kZXMgPSBudWxsO1xuICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIGNoYW5nZWRFZGdlcyA9IHNlbGVjdGVkRWRnZUlkcy5tYXAoKGVkZ2VJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2VJZCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlZEVkZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlcywgc2VsZWN0ZWRFZGdlSWRzKTtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZ2V0Tm9kZXMoKSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZU5vZGVzQW5kRWRnZXNTZWxlY3Rpb25zKHtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyxcbiAgICAgICAgICAgIGNoYW5nZWRFZGdlcyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHNldCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXM6ICh7IG5vZGVzLCBlZGdlcyB9ID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgeyBlZGdlczogc3RvcmVFZGdlcywgZ2V0Tm9kZXMgfSA9IGdldCgpO1xuICAgICAgICBjb25zdCBub2Rlc1RvVW5zZWxlY3QgPSBub2RlcyA/IG5vZGVzIDogZ2V0Tm9kZXMoKTtcbiAgICAgICAgY29uc3QgZWRnZXNUb1Vuc2VsZWN0ID0gZWRnZXMgPyBlZGdlcyA6IHN0b3JlRWRnZXM7XG4gICAgICAgIGNvbnN0IGNoYW5nZWROb2RlcyA9IG5vZGVzVG9VbnNlbGVjdC5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgIG4uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobi5pZCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2hhbmdlZEVkZ2VzID0gZWRnZXNUb1Vuc2VsZWN0Lm1hcCgoZWRnZSkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKSk7XG4gICAgICAgIHVwZGF0ZU5vZGVzQW5kRWRnZXNTZWxlY3Rpb25zKHtcbiAgICAgICAgICAgIGNoYW5nZWROb2RlcyxcbiAgICAgICAgICAgIGNoYW5nZWRFZGdlcyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHNldCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRNaW5ab29tOiAobWluWm9vbSkgPT4ge1xuICAgICAgICBjb25zdCB7IGQzWm9vbSwgbWF4Wm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgIGQzWm9vbT8uc2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKTtcbiAgICAgICAgc2V0KHsgbWluWm9vbSB9KTtcbiAgICB9LFxuICAgIHNldE1heFpvb206IChtYXhab29tKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZDNab29tLCBtaW5ab29tIH0gPSBnZXQoKTtcbiAgICAgICAgZDNab29tPy5zY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICBzZXQoeyBtYXhab29tIH0pO1xuICAgIH0sXG4gICAgc2V0VHJhbnNsYXRlRXh0ZW50OiAodHJhbnNsYXRlRXh0ZW50KSA9PiB7XG4gICAgICAgIGdldCgpLmQzWm9vbT8udHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIHNldCh7IHRyYW5zbGF0ZUV4dGVudCB9KTtcbiAgICB9LFxuICAgIHJlc2V0U2VsZWN0ZWRFbGVtZW50czogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVkZ2VzLCBnZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gZ2V0Tm9kZXMoKTtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1Vuc2VsZWN0ID0gbm9kZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKGUpID0+IGUuc2VsZWN0ZWQpXG4gICAgICAgICAgICAubWFwKChuKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobi5pZCwgZmFsc2UpKTtcbiAgICAgICAgY29uc3QgZWRnZXNUb1Vuc2VsZWN0ID0gZWRnZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKGUpID0+IGUuc2VsZWN0ZWQpXG4gICAgICAgICAgICAubWFwKChlKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoZS5pZCwgZmFsc2UpKTtcbiAgICAgICAgdXBkYXRlTm9kZXNBbmRFZGdlc1NlbGVjdGlvbnMoe1xuICAgICAgICAgICAgY2hhbmdlZE5vZGVzOiBub2Rlc1RvVW5zZWxlY3QsXG4gICAgICAgICAgICBjaGFuZ2VkRWRnZXM6IGVkZ2VzVG9VbnNlbGVjdCxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHNldCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXROb2RlRXh0ZW50OiAobm9kZUV4dGVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVJbnRlcm5hbHMgfSA9IGdldCgpO1xuICAgICAgICBub2RlSW50ZXJuYWxzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIG5vZGUucG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wUG9zaXRpb24obm9kZS5wb3NpdGlvbiwgbm9kZUV4dGVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXQoe1xuICAgICAgICAgICAgbm9kZUV4dGVudCxcbiAgICAgICAgICAgIG5vZGVJbnRlcm5hbHM6IG5ldyBNYXAobm9kZUludGVybmFscyksXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFuQnk6IChkZWx0YSkgPT4ge1xuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgd2lkdGgsIGhlaWdodCwgZDNab29tLCBkM1NlbGVjdGlvbiwgdHJhbnNsYXRlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKCFkM1pvb20gfHwgIWQzU2VsZWN0aW9uIHx8ICghZGVsdGEueCAmJiAhZGVsdGEueSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gem9vbUlkZW50aXR5XG4gICAgICAgICAgICAudHJhbnNsYXRlKHRyYW5zZm9ybVswXSArIGRlbHRhLngsIHRyYW5zZm9ybVsxXSArIGRlbHRhLnkpXG4gICAgICAgICAgICAuc2NhbGUodHJhbnNmb3JtWzJdKTtcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gW1xuICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBjb25zdHJhaW5lZFRyYW5zZm9ybSA9IGQzWm9vbT8uY29uc3RyYWluKCkobmV4dFRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICBkM1pvb20udHJhbnNmb3JtKGQzU2VsZWN0aW9uLCBjb25zdHJhaW5lZFRyYW5zZm9ybSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybUNoYW5nZWQgPSB0cmFuc2Zvcm1bMF0gIT09IGNvbnN0cmFpbmVkVHJhbnNmb3JtLnggfHxcbiAgICAgICAgICAgIHRyYW5zZm9ybVsxXSAhPT0gY29uc3RyYWluZWRUcmFuc2Zvcm0ueSB8fFxuICAgICAgICAgICAgdHJhbnNmb3JtWzJdICE9PSBjb25zdHJhaW5lZFRyYW5zZm9ybS5rO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtQ2hhbmdlZDtcbiAgICB9LFxuICAgIGNhbmNlbENvbm5lY3Rpb246ICgpID0+IHNldCh7XG4gICAgICAgIGNvbm5lY3Rpb25Ob2RlSWQ6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uTm9kZUlkLFxuICAgICAgICBjb25uZWN0aW9uSGFuZGxlSWQ6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uSGFuZGxlSWQsXG4gICAgICAgIGNvbm5lY3Rpb25IYW5kbGVUeXBlOiBpbml0aWFsU3RhdGUuY29ubmVjdGlvbkhhbmRsZVR5cGUsXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uU3RhdHVzLFxuICAgICAgICBjb25uZWN0aW9uU3RhcnRIYW5kbGU6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uU3RhcnRIYW5kbGUsXG4gICAgICAgIGNvbm5lY3Rpb25FbmRIYW5kbGU6IGluaXRpYWxTdGF0ZS5jb25uZWN0aW9uRW5kSGFuZGxlLFxuICAgIH0pLFxuICAgIHJlc2V0OiAoKSA9PiBzZXQoeyAuLi5pbml0aWFsU3RhdGUgfSksXG59KSwgT2JqZWN0LmlzKTtcblxuY29uc3QgUmVhY3RGbG93UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgY29uc3Qgc3RvcmVSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgaWYgKCFzdG9yZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBjcmVhdGVSRlN0b3JlKCk7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVyJDEsIHsgdmFsdWU6IHN0b3JlUmVmLmN1cnJlbnQgfSwgY2hpbGRyZW4pO1xufTtcblJlYWN0Rmxvd1Byb3ZpZGVyLmRpc3BsYXlOYW1lID0gJ1JlYWN0Rmxvd1Byb3ZpZGVyJztcblxuY29uc3QgV3JhcHBlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICBjb25zdCBpc1dyYXBwZWQgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKGlzV3JhcHBlZCkge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgaXQgd2l0aCBhIGZyYWdtZW50IGJlY2F1c2UgaXQncyBub3QgYWxsb3dlZCBmb3IgY2hpbGRyZW4gdG8gYmUgYSBSZWFjdE5vZGVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvaXNzdWVzLzE4MDUxXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0Rmxvd1Byb3ZpZGVyLCBudWxsLCBjaGlsZHJlbik7XG59O1xuV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdSZWFjdEZsb3dXcmFwcGVyJztcblxuY29uc3QgZGVmYXVsdE5vZGVUeXBlcyA9IHtcbiAgICBpbnB1dDogSW5wdXROb2RlJDEsXG4gICAgZGVmYXVsdDogRGVmYXVsdE5vZGUkMSxcbiAgICBvdXRwdXQ6IE91dHB1dE5vZGUkMSxcbiAgICBncm91cDogR3JvdXBOb2RlLFxufTtcbmNvbnN0IGRlZmF1bHRFZGdlVHlwZXMgPSB7XG4gICAgZGVmYXVsdDogQmV6aWVyRWRnZSxcbiAgICBzdHJhaWdodDogU3RyYWlnaHRFZGdlLFxuICAgIHN0ZXA6IFN0ZXBFZGdlLFxuICAgIHNtb290aHN0ZXA6IFNtb290aFN0ZXBFZGdlLFxuICAgIHNpbXBsZWJlemllcjogU2ltcGxlQmV6aWVyRWRnZSxcbn07XG5jb25zdCBpbml0Tm9kZU9yaWdpbiA9IFswLCAwXTtcbmNvbnN0IGluaXRTbmFwR3JpZCA9IFsxNSwgMTVdO1xuY29uc3QgaW5pdERlZmF1bHRWaWV3cG9ydCA9IHsgeDogMCwgeTogMCwgem9vbTogMSB9O1xuY29uc3Qgd3JhcHBlclN0eWxlID0ge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHpJbmRleDogMCxcbn07XG5jb25zdCBSZWFjdEZsb3cgPSBmb3J3YXJkUmVmKCh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIGNsYXNzTmFtZSwgbm9kZVR5cGVzID0gZGVmYXVsdE5vZGVUeXBlcywgZWRnZVR5cGVzID0gZGVmYXVsdEVkZ2VUeXBlcywgb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrLCBvbkluaXQsIG9uTW92ZSwgb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZCwgb25Db25uZWN0LCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kLCBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZCwgb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudSwgb25Ob2RlRG91YmxlQ2xpY2ssIG9uTm9kZURyYWdTdGFydCwgb25Ob2RlRHJhZywgb25Ob2RlRHJhZ1N0b3AsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIG9uU2VsZWN0aW9uQ2hhbmdlLCBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdG9wLCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgY29ubmVjdGlvbk1vZGUgPSBDb25uZWN0aW9uTW9kZS5TdHJpY3QsIGNvbm5lY3Rpb25MaW5lVHlwZSA9IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIsIGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlLCBkZWxldGVLZXlDb2RlID0gJ0JhY2tzcGFjZScsIHNlbGVjdGlvbktleUNvZGUgPSAnU2hpZnQnLCBzZWxlY3Rpb25PbkRyYWcgPSBmYWxzZSwgc2VsZWN0aW9uTW9kZSA9IFNlbGVjdGlvbk1vZGUuRnVsbCwgcGFuQWN0aXZhdGlvbktleUNvZGUgPSAnU3BhY2UnLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgPSBpc01hY09zKCkgPyAnTWV0YScgOiAnQ29udHJvbCcsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSA9IGlzTWFjT3MoKSA/ICdNZXRhJyA6ICdDb250cm9sJywgc25hcFRvR3JpZCA9IGZhbHNlLCBzbmFwR3JpZCA9IGluaXRTbmFwR3JpZCwgb25seVJlbmRlclZpc2libGVFbGVtZW50cyA9IGZhbHNlLCBzZWxlY3ROb2Rlc09uRHJhZyA9IHRydWUsIG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgbm9kZU9yaWdpbiA9IGluaXROb2RlT3JpZ2luLCBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNVcGRhdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgZGVmYXVsdFZpZXdwb3J0ID0gaW5pdERlZmF1bHRWaWV3cG9ydCwgbWluWm9vbSA9IDAuNSwgbWF4Wm9vbSA9IDIsIHRyYW5zbGF0ZUV4dGVudCA9IGluZmluaXRlRXh0ZW50LCBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZSwgbm9kZUV4dGVudCwgZGVmYXVsdE1hcmtlckNvbG9yID0gJyNiMWIxYjcnLCB6b29tT25TY3JvbGwgPSB0cnVlLCB6b29tT25QaW5jaCA9IHRydWUsIHBhbk9uU2Nyb2xsID0gZmFsc2UsIHBhbk9uU2Nyb2xsU3BlZWQgPSAwLjUsIHBhbk9uU2Nyb2xsTW9kZSA9IFBhbk9uU2Nyb2xsTW9kZS5GcmVlLCB6b29tT25Eb3VibGVDbGljayA9IHRydWUsIHBhbk9uRHJhZyA9IHRydWUsIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbCwgb25QYW5lQ29udGV4dE1lbnUsIGNoaWxkcmVuLCBvbkVkZ2VVcGRhdGUsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCBvbkVkZ2VVcGRhdGVTdGFydCwgb25FZGdlVXBkYXRlRW5kLCBlZGdlVXBkYXRlclJhZGl1cyA9IDEwLCBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlLCBub0RyYWdDbGFzc05hbWUgPSAnbm9kcmFnJywgbm9XaGVlbENsYXNzTmFtZSA9ICdub3doZWVsJywgbm9QYW5DbGFzc05hbWUgPSAnbm9wYW4nLCBmaXRWaWV3ID0gZmFsc2UsIGZpdFZpZXdPcHRpb25zLCBjb25uZWN0T25DbGljayA9IHRydWUsIGF0dHJpYnV0aW9uUG9zaXRpb24sIHByb09wdGlvbnMsIGRlZmF1bHRFZGdlT3B0aW9ucywgZWxldmF0ZU5vZGVzT25TZWxlY3QgPSB0cnVlLCBlbGV2YXRlRWRnZXNPblNlbGVjdCA9IGZhbHNlLCBkaXNhYmxlS2V5Ym9hcmRBMTF5ID0gZmFsc2UsIGF1dG9QYW5PbkNvbm5lY3QgPSB0cnVlLCBhdXRvUGFuT25Ob2RlRHJhZyA9IHRydWUsIGNvbm5lY3Rpb25SYWRpdXMgPSAyMCwgaXNWYWxpZENvbm5lY3Rpb24sIG9uRXJyb3IsIHN0eWxlLCBpZCwgbm9kZURyYWdUaHJlc2hvbGQsIC4uLnJlc3QgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgcmZJZCA9IGlkIHx8ICcxJztcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyAuLi5yZXN0LCBzdHlsZTogeyAuLi5zdHlsZSwgLi4ud3JhcHBlclN0eWxlIH0sIHJlZjogcmVmLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvdycsIGNsYXNzTmFtZV0pLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX3dyYXBwZXJcIiwgaWQ6IGlkIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlciwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3JhcGhWaWV3JDEsIHsgb25Jbml0OiBvbkluaXQsIG9uTW92ZTogb25Nb3ZlLCBvbk1vdmVTdGFydDogb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZDogb25Nb3ZlRW5kLCBvbk5vZGVDbGljazogb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrOiBvbkVkZ2VDbGljaywgb25Ob2RlTW91c2VFbnRlcjogb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlOiBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmU6IG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51OiBvbk5vZGVDb250ZXh0TWVudSwgb25Ob2RlRG91YmxlQ2xpY2s6IG9uTm9kZURvdWJsZUNsaWNrLCBub2RlVHlwZXM6IG5vZGVUeXBlcywgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIGNvbm5lY3Rpb25MaW5lVHlwZTogY29ubmVjdGlvbkxpbmVUeXBlLCBjb25uZWN0aW9uTGluZVN0eWxlOiBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudDogY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGU6IGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIHNlbGVjdGlvbktleUNvZGU6IHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZzogc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBkZWxldGVLZXlDb2RlOiBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGU6IG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGU6IHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgc2VsZWN0Tm9kZXNPbkRyYWc6IHNlbGVjdE5vZGVzT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25FZGdlVXBkYXRlOiBvbkVkZ2VVcGRhdGUsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25FZGdlVXBkYXRlU3RhcnQ6IG9uRWRnZVVwZGF0ZVN0YXJ0LCBvbkVkZ2VVcGRhdGVFbmQ6IG9uRWRnZVVwZGF0ZUVuZCwgZWRnZVVwZGF0ZXJSYWRpdXM6IGVkZ2VVcGRhdGVyUmFkaXVzLCBkZWZhdWx0TWFya2VyQ29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZWxldmF0ZUVkZ2VzT25TZWxlY3Q6IGVsZXZhdGVFZGdlc09uU2VsZWN0LCByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50IH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTdG9yZVVwZGF0ZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgb25Db25uZWN0OiBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0OiBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kOiBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQ6IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kOiBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlOiBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZTogbm9kZXNGb2N1c2FibGUsIGVkZ2VzRm9jdXNhYmxlOiBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNVcGRhdGFibGU6IGVkZ2VzVXBkYXRhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBvbk5vZGVzQ2hhbmdlOiBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlOiBvbkVkZ2VzQ2hhbmdlLCBzbmFwVG9HcmlkOiBzbmFwVG9HcmlkLCBzbmFwR3JpZDogc25hcEdyaWQsIGNvbm5lY3Rpb25Nb2RlOiBjb25uZWN0aW9uTW9kZSwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIGNvbm5lY3RPbkNsaWNrOiBjb25uZWN0T25DbGljaywgZGVmYXVsdEVkZ2VPcHRpb25zOiBkZWZhdWx0RWRnZU9wdGlvbnMsIGZpdFZpZXc6IGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgb25Ob2Rlc0RlbGV0ZTogb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZTogb25FZGdlc0RlbGV0ZSwgb25Ob2RlRHJhZ1N0YXJ0OiBvbk5vZGVEcmFnU3RhcnQsIG9uTm9kZURyYWc6IG9uTm9kZURyYWcsIG9uTm9kZURyYWdTdG9wOiBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnOiBvblNlbGVjdGlvbkRyYWcsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0OiBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RvcDogb25TZWxlY3Rpb25EcmFnU3RvcCwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCByZklkOiByZklkLCBhdXRvUGFuT25Db25uZWN0OiBhdXRvUGFuT25Db25uZWN0LCBhdXRvUGFuT25Ob2RlRHJhZzogYXV0b1Bhbk9uTm9kZURyYWcsIG9uRXJyb3I6IG9uRXJyb3IsIGNvbm5lY3Rpb25SYWRpdXM6IGNvbm5lY3Rpb25SYWRpdXMsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiwgbm9kZURyYWdUaHJlc2hvbGQ6IG5vZGVEcmFnVGhyZXNob2xkIH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVyJDEsIHsgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlIH0pLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEF0dHJpYnV0aW9uLCB7IHByb09wdGlvbnM6IHByb09wdGlvbnMsIHBvc2l0aW9uOiBhdHRyaWJ1dGlvblBvc2l0aW9uIH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChBMTF5RGVzY3JpcHRpb25zLCB7IHJmSWQ6IHJmSWQsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXkgfSkpKSk7XG59KTtcblJlYWN0Rmxvdy5kaXNwbGF5TmFtZSA9ICdSZWFjdEZsb3cnO1xuXG5jb25zdCBzZWxlY3RvciQxID0gKHMpID0+IHMuZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX2VkZ2VsYWJlbC1yZW5kZXJlcicpO1xuZnVuY3Rpb24gRWRnZUxhYmVsUmVuZGVyZXIoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgZWRnZUxhYmVsUmVuZGVyZXIgPSB1c2VTdG9yZShzZWxlY3RvciQxKTtcbiAgICBpZiAoIWVkZ2VMYWJlbFJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBlZGdlTGFiZWxSZW5kZXJlcik7XG59XG5cbmZ1bmN0aW9uIHVzZVVwZGF0ZU5vZGVJbnRlcm5hbHMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoaWQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkb21Ob2RlLCB1cGRhdGVOb2RlRGltZW5zaW9ucyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlSWRzID0gQXJyYXkuaXNBcnJheShpZCkgPyBpZCA6IFtpZF07XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSB1cGRhdGVJZHMucmVkdWNlKChyZXMsIHVwZGF0ZUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlRWxlbWVudCA9IGRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoYC5yZWFjdC1mbG93X19ub2RlW2RhdGEtaWQ9XCIke3VwZGF0ZUlkfVwiXWApO1xuICAgICAgICAgICAgaWYgKG5vZGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goeyBpZDogdXBkYXRlSWQsIG5vZGVFbGVtZW50LCBmb3JjZVVwZGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHVwZGF0ZU5vZGVEaW1lbnNpb25zKHVwZGF0ZXMpKTtcbiAgICB9LCBbXSk7XG59XG5cbmNvbnN0IG5vZGVzU2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLmdldE5vZGVzKCk7XG5mdW5jdGlvbiB1c2VOb2RlcygpIHtcbiAgICBjb25zdCBub2RlcyA9IHVzZVN0b3JlKG5vZGVzU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2Rlcztcbn1cblxuY29uc3QgZWRnZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUuZWRnZXM7XG5mdW5jdGlvbiB1c2VFZGdlcygpIHtcbiAgICBjb25zdCBlZGdlcyA9IHVzZVN0b3JlKGVkZ2VzU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiBlZGdlcztcbn1cblxuY29uc3Qgdmlld3BvcnRTZWxlY3RvciA9IChzdGF0ZSkgPT4gKHtcbiAgICB4OiBzdGF0ZS50cmFuc2Zvcm1bMF0sXG4gICAgeTogc3RhdGUudHJhbnNmb3JtWzFdLFxuICAgIHpvb206IHN0YXRlLnRyYW5zZm9ybVsyXSxcbn0pO1xuZnVuY3Rpb24gdXNlVmlld3BvcnQoKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB1c2VTdG9yZSh2aWV3cG9ydFNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gdmlld3BvcnQ7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmZ1bmN0aW9uIGNyZWF0ZVVzZUl0ZW1zU3RhdGUoYXBwbHlDaGFuZ2VzKSB7XG4gICAgcmV0dXJuIChpbml0aWFsSXRlbXMpID0+IHtcbiAgICAgICAgY29uc3QgW2l0ZW1zLCBzZXRJdGVtc10gPSB1c2VTdGF0ZShpbml0aWFsSXRlbXMpO1xuICAgICAgICBjb25zdCBvbkl0ZW1zQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGNoYW5nZXMpID0+IHNldEl0ZW1zKChpdGVtcykgPT4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGl0ZW1zKSksIFtdKTtcbiAgICAgICAgcmV0dXJuIFtpdGVtcywgc2V0SXRlbXMsIG9uSXRlbXNDaGFuZ2VdO1xuICAgIH07XG59XG5jb25zdCB1c2VOb2Rlc1N0YXRlID0gY3JlYXRlVXNlSXRlbXNTdGF0ZShhcHBseU5vZGVDaGFuZ2VzKTtcbmNvbnN0IHVzZUVkZ2VzU3RhdGUgPSBjcmVhdGVVc2VJdGVtc1N0YXRlKGFwcGx5RWRnZUNoYW5nZXMpO1xuXG5mdW5jdGlvbiB1c2VPblZpZXdwb3J0Q2hhbmdlKHsgb25TdGFydCwgb25DaGFuZ2UsIG9uRW5kIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlU3RhcnQ6IG9uU3RhcnQgfSk7XG4gICAgfSwgW29uU3RhcnRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2U6IG9uQ2hhbmdlIH0pO1xuICAgIH0sIFtvbkNoYW5nZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZUVuZDogb25FbmQgfSk7XG4gICAgfSwgW29uRW5kXSk7XG59XG5cbmZ1bmN0aW9uIHVzZU9uU2VsZWN0aW9uQ2hhbmdlKHsgb25DaGFuZ2UgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0U2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgPSBbLi4uc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZSwgb25DaGFuZ2VdO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uU2VsZWN0aW9uQ2hhbmdlOiBuZXh0U2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0SGFuZGxlcnMgPSBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlLmZpbHRlcigoZm4pID0+IGZuICE9PSBvbkNoYW5nZSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uU2VsZWN0aW9uQ2hhbmdlOiBuZXh0SGFuZGxlcnMgfSk7XG4gICAgICAgIH07XG4gICAgfSwgW29uQ2hhbmdlXSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yID0gKG9wdGlvbnMpID0+IChzKSA9PiB7XG4gICAgaWYgKHMubm9kZUludGVybmFscy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNcbiAgICAgICAgLmdldE5vZGVzKClcbiAgICAgICAgLmZpbHRlcigobikgPT4gKG9wdGlvbnMuaW5jbHVkZUhpZGRlbk5vZGVzID8gdHJ1ZSA6ICFuLmhpZGRlbikpXG4gICAgICAgIC5ldmVyeSgobikgPT4gbltpbnRlcm5hbHNTeW1ib2xdPy5oYW5kbGVCb3VuZHMgIT09IHVuZGVmaW5lZCk7XG59O1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgaW5jbHVkZUhpZGRlbk5vZGVzOiBmYWxzZSxcbn07XG5mdW5jdGlvbiB1c2VOb2Rlc0luaXRpYWxpemVkKG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucykge1xuICAgIGNvbnN0IGluaXRpYWxpemVkID0gdXNlU3RvcmUoc2VsZWN0b3Iob3B0aW9ucykpO1xuICAgIHJldHVybiBpbml0aWFsaXplZDtcbn1cblxuZXhwb3J0IHsgQmFzZUVkZ2UsIEJlemllckVkZ2UsIENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIEVkZ2VMYWJlbFJlbmRlcmVyLCBFZGdlVGV4dCQxIGFzIEVkZ2VUZXh0LCBIYW5kbGUkMSBhcyBIYW5kbGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUGFuZWwsIFBvc2l0aW9uLCBSZWFjdEZsb3csIFJlYWN0Rmxvd1Byb3ZpZGVyLCBTZWxlY3Rpb25Nb2RlLCBTaW1wbGVCZXppZXJFZGdlLCBTbW9vdGhTdGVwRWRnZSwgU3RlcEVkZ2UsIFN0cmFpZ2h0RWRnZSwgYWRkRWRnZSwgYXBwbHlFZGdlQ2hhbmdlcywgYXBwbHlOb2RlQ2hhbmdlcywgYm94VG9SZWN0LCBjbGFtcCwgZ2V0QmV6aWVyUGF0aCwgZ2V0Qm91bmRzT2ZSZWN0cywgZ2V0Q29ubmVjdGVkRWRnZXMsIGdldEluY29tZXJzLCBnZXRNYXJrZXJFbmQsIGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4sIGdldE5vZGVzQm91bmRzLCBnZXRPdXRnb2VycywgZ2V0UmVjdE9mTm9kZXMsIGdldFNpbXBsZUJlemllclBhdGgsIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldFRyYW5zZm9ybUZvckJvdW5kcywgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIGhhbmRsZVBhcmVudEV4cGFuZCwgaW50ZXJuYWxzU3ltYm9sLCBpc0VkZ2UsIGlzTm9kZSwgcmVjdFRvQm94LCB1cGRhdGVFZGdlLCB1c2VFZGdlcywgdXNlRWRnZXNTdGF0ZSwgdXNlR2V0UG9pbnRlclBvc2l0aW9uLCB1c2VLZXlQcmVzcywgdXNlTm9kZUlkLCB1c2VOb2RlcywgdXNlTm9kZXNJbml0aWFsaXplZCwgdXNlTm9kZXNTdGF0ZSwgdXNlT25TZWxlY3Rpb25DaGFuZ2UsIHVzZU9uVmlld3BvcnRDaGFuZ2UsIHVzZVJlYWN0RmxvdywgdXNlU3RvcmUsIHVzZVN0b3JlQXBpLCB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzLCB1c2VWaWV3cG9ydCB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VNZW1vIiwibWVtbyIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiZm9yd2FyZFJlZiIsInVzZUNhbGxiYWNrIiwiY2MiLCJ1c2VTdG9yZVdpdGhFcXVhbGl0eUZuIiwiY3JlYXRlV2l0aEVxdWFsaXR5Rm4iLCJzaGFsbG93Iiwiem9vbUlkZW50aXR5Iiwiem9vbSIsInNlbGVjdCIsInBvaW50ZXIiLCJkcmFnIiwiY3JlYXRlUG9ydGFsIiwiU3RvcmVDb250ZXh0IiwiUHJvdmlkZXIkMSIsIlByb3ZpZGVyIiwiZXJyb3JNZXNzYWdlcyIsImVycm9yMDAxIiwiZXJyb3IwMDIiLCJlcnJvcjAwMyIsIm5vZGVUeXBlIiwiZXJyb3IwMDQiLCJlcnJvcjAwNSIsImVycm9yMDA2IiwiZXJyb3IwMDciLCJpZCIsImVycm9yMDA5IiwidHlwZSIsImVycm9yMDA4Iiwic291cmNlSGFuZGxlIiwiZWRnZSIsInRhcmdldEhhbmRsZSIsImVycm9yMDEwIiwiZXJyb3IwMTEiLCJlZGdlVHlwZSIsImVycm9yMDEyIiwienVzdGFuZEVycm9yTWVzc2FnZSIsInVzZVN0b3JlIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwic3RvcmUiLCJFcnJvciIsInVzZVN0b3JlQXBpIiwiZ2V0U3RhdGUiLCJzZXRTdGF0ZSIsInN1YnNjcmliZSIsImRlc3Ryb3kiLCJzZWxlY3RvciRnIiwicyIsInVzZXJTZWxlY3Rpb25BY3RpdmUiLCJQYW5lbCIsInBvc2l0aW9uIiwiY2hpbGRyZW4iLCJjbGFzc05hbWUiLCJzdHlsZSIsInJlc3QiLCJwb2ludGVyRXZlbnRzIiwicG9zaXRpb25DbGFzc2VzIiwic3BsaXQiLCJjcmVhdGVFbGVtZW50IiwiQXR0cmlidXRpb24iLCJwcm9PcHRpb25zIiwiaGlkZUF0dHJpYnV0aW9uIiwiaHJlZiIsInRhcmdldCIsInJlbCIsIkVkZ2VUZXh0IiwieCIsInkiLCJsYWJlbCIsImxhYmVsU3R5bGUiLCJsYWJlbFNob3dCZyIsImxhYmVsQmdTdHlsZSIsImxhYmVsQmdQYWRkaW5nIiwibGFiZWxCZ0JvcmRlclJhZGl1cyIsImVkZ2VSZWYiLCJlZGdlVGV4dEJib3giLCJzZXRFZGdlVGV4dEJib3giLCJ3aWR0aCIsImhlaWdodCIsImVkZ2VUZXh0Q2xhc3NlcyIsImN1cnJlbnQiLCJ0ZXh0QmJveCIsImdldEJCb3giLCJ0cmFuc2Zvcm0iLCJ2aXNpYmlsaXR5IiwicngiLCJyeSIsImR5IiwicmVmIiwiRWRnZVRleHQkMSIsImdldERpbWVuc2lvbnMiLCJub2RlIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJjbGFtcCIsInZhbCIsIm1pbiIsIm1heCIsIk1hdGgiLCJjbGFtcFBvc2l0aW9uIiwiZXh0ZW50IiwiY2FsY0F1dG9QYW5WZWxvY2l0eSIsInZhbHVlIiwiYWJzIiwiY2FsY0F1dG9QYW4iLCJwb3MiLCJib3VuZHMiLCJ4TW92ZW1lbnQiLCJ5TW92ZW1lbnQiLCJnZXRIb3N0Rm9yRWxlbWVudCIsImVsZW1lbnQiLCJnZXRSb290Tm9kZSIsIndpbmRvdyIsImRvY3VtZW50IiwiZ2V0Qm91bmRzT2ZCb3hlcyIsImJveDEiLCJib3gyIiwieDIiLCJ5MiIsInJlY3RUb0JveCIsImJveFRvUmVjdCIsIm5vZGVUb1JlY3QiLCJwb3NpdGlvbkFic29sdXRlIiwiZ2V0Qm91bmRzT2ZSZWN0cyIsInJlY3QxIiwicmVjdDIiLCJnZXRPdmVybGFwcGluZ0FyZWEiLCJyZWN0QSIsInJlY3RCIiwieE92ZXJsYXAiLCJ5T3ZlcmxhcCIsImNlaWwiLCJpc1JlY3RPYmplY3QiLCJvYmoiLCJpc051bWVyaWMiLCJuIiwiaXNOYU4iLCJpc0Zpbml0ZSIsImludGVybmFsc1N5bWJvbCIsIlN5bWJvbCIsImZvciIsImVsZW1lbnRTZWxlY3Rpb25LZXlzIiwiZGV2V2FybiIsIm1lc3NhZ2UiLCJwcm9jZXNzIiwiY29uc29sZSIsIndhcm4iLCJpc1JlYWN0S2V5Ym9hcmRFdmVudCIsImV2ZW50IiwiaXNJbnB1dERPTU5vZGUiLCJrYkV2ZW50IiwibmF0aXZlRXZlbnQiLCJjb21wb3NlZFBhdGgiLCJpc0lucHV0IiwiaW5jbHVkZXMiLCJub2RlTmFtZSIsImhhc0F0dHJpYnV0ZSIsImNsb3Nlc3QiLCJpc01vdXNlRXZlbnQiLCJnZXRFdmVudFBvc2l0aW9uIiwiaXNNb3VzZVRyaWdnZXJlZCIsImV2dFgiLCJjbGllbnRYIiwidG91Y2hlcyIsImV2dFkiLCJjbGllbnRZIiwibGVmdCIsInRvcCIsImlzTWFjT3MiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiQmFzZUVkZ2UiLCJwYXRoIiwibGFiZWxYIiwibGFiZWxZIiwibWFya2VyRW5kIiwibWFya2VyU3RhcnQiLCJpbnRlcmFjdGlvbldpZHRoIiwiRnJhZ21lbnQiLCJkIiwiZmlsbCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsImRpc3BsYXlOYW1lIiwiZ2V0TWFya2VyRW5kIiwibWFya2VyVHlwZSIsIm1hcmtlckVuZElkIiwiZ2V0TW91c2VIYW5kbGVyJDEiLCJoYW5kbGVyIiwidW5kZWZpbmVkIiwiZWRnZXMiLCJmaW5kIiwiZSIsImdldEVkZ2VDZW50ZXIiLCJzb3VyY2VYIiwic291cmNlWSIsInRhcmdldFgiLCJ0YXJnZXRZIiwieE9mZnNldCIsImNlbnRlclgiLCJ5T2Zmc2V0IiwiY2VudGVyWSIsImdldEJlemllckVkZ2VDZW50ZXIiLCJzb3VyY2VDb250cm9sWCIsInNvdXJjZUNvbnRyb2xZIiwidGFyZ2V0Q29udHJvbFgiLCJ0YXJnZXRDb250cm9sWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwiQ29ubmVjdGlvbk1vZGUiLCJQYW5PblNjcm9sbE1vZGUiLCJTZWxlY3Rpb25Nb2RlIiwiQ29ubmVjdGlvbkxpbmVUeXBlIiwiTWFya2VyVHlwZSIsIlBvc2l0aW9uIiwiZ2V0Q29udHJvbCIsIngxIiwieTEiLCJMZWZ0IiwiUmlnaHQiLCJnZXRTaW1wbGVCZXppZXJQYXRoIiwic291cmNlUG9zaXRpb24iLCJCb3R0b20iLCJ0YXJnZXRQb3NpdGlvbiIsIlRvcCIsIlNpbXBsZUJlemllckVkZ2UiLCJoYW5kbGVEaXJlY3Rpb25zIiwiZ2V0RGlyZWN0aW9uIiwic291cmNlIiwiZGlzdGFuY2UiLCJhIiwiYiIsInNxcnQiLCJwb3ciLCJnZXRQb2ludHMiLCJjZW50ZXIiLCJvZmZzZXQiLCJzb3VyY2VEaXIiLCJ0YXJnZXREaXIiLCJzb3VyY2VHYXBwZWQiLCJ0YXJnZXRHYXBwZWQiLCJkaXIiLCJkaXJBY2Nlc3NvciIsImN1cnJEaXIiLCJwb2ludHMiLCJzb3VyY2VHYXBPZmZzZXQiLCJ0YXJnZXRHYXBPZmZzZXQiLCJkZWZhdWx0Q2VudGVyWCIsImRlZmF1bHRDZW50ZXJZIiwiZGVmYXVsdE9mZnNldFgiLCJkZWZhdWx0T2Zmc2V0WSIsInZlcnRpY2FsU3BsaXQiLCJob3Jpem9udGFsU3BsaXQiLCJzb3VyY2VUYXJnZXQiLCJ0YXJnZXRTb3VyY2UiLCJkaWZmIiwiZ2FwT2Zmc2V0IiwiZGlyQWNjZXNzb3JPcHBvc2l0ZSIsImlzU2FtZURpciIsInNvdXJjZUd0VGFyZ2V0T3BwbyIsInNvdXJjZUx0VGFyZ2V0T3BwbyIsImZsaXBTb3VyY2VUYXJnZXQiLCJzb3VyY2VHYXBQb2ludCIsInRhcmdldEdhcFBvaW50IiwibWF4WERpc3RhbmNlIiwibWF4WURpc3RhbmNlIiwicGF0aFBvaW50cyIsImdldEJlbmQiLCJjIiwic2l6ZSIsImJlbmRTaXplIiwieERpciIsInlEaXIiLCJnZXRTbW9vdGhTdGVwUGF0aCIsImJvcmRlclJhZGl1cyIsInJlZHVjZSIsInJlcyIsInAiLCJpIiwic2VnbWVudCIsImxlbmd0aCIsIlNtb290aFN0ZXBFZGdlIiwicGF0aE9wdGlvbnMiLCJTdGVwRWRnZSIsInByb3BzIiwiZ2V0U3RyYWlnaHRQYXRoIiwiU3RyYWlnaHRFZGdlIiwiY2FsY3VsYXRlQ29udHJvbE9mZnNldCIsImN1cnZhdHVyZSIsImdldENvbnRyb2xXaXRoQ3VydmF0dXJlIiwiZ2V0QmV6aWVyUGF0aCIsIkJlemllckVkZ2UiLCJOb2RlSWRDb250ZXh0IiwiQ29uc3VtZXIiLCJ1c2VOb2RlSWQiLCJub2RlSWQiLCJpc0VkZ2UiLCJpc05vZGUiLCJnZXRPdXRnb2VycyIsIm5vZGVzIiwib3V0Z29lcklkcyIsImZpbHRlciIsIm1hcCIsImdldEluY29tZXJzIiwiaW5jb21lcnNJZHMiLCJnZXRFZGdlSWQiLCJnZXRNYXJrZXJJZCIsIm1hcmtlciIsInJmSWQiLCJpZFByZWZpeCIsIk9iamVjdCIsImtleXMiLCJzb3J0Iiwia2V5Iiwiam9pbiIsImNvbm5lY3Rpb25FeGlzdHMiLCJzb21lIiwiZWwiLCJhZGRFZGdlIiwiZWRnZVBhcmFtcyIsImNvbmNhdCIsInVwZGF0ZUVkZ2UiLCJvbGRFZGdlIiwibmV3Q29ubmVjdGlvbiIsIm9wdGlvbnMiLCJzaG91bGRSZXBsYWNlSWQiLCJvbGRFZGdlSWQiLCJmb3VuZEVkZ2UiLCJwb2ludFRvUmVuZGVyZXJQb2ludCIsInR4IiwidHkiLCJ0U2NhbGUiLCJzbmFwVG9HcmlkIiwic25hcFgiLCJzbmFwWSIsInJvdW5kIiwicmVuZGVyZXJQb2ludFRvUG9pbnQiLCJnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luIiwibm9kZU9yaWdpbiIsImdldE5vZGVzQm91bmRzIiwiYm94IiwiY3VyckJveCIsIkluZmluaXR5IiwiZ2V0UmVjdE9mTm9kZXMiLCJnZXROb2Rlc0luc2lkZSIsIm5vZGVJbnRlcm5hbHMiLCJyZWN0IiwicGFydGlhbGx5IiwiZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyIsInBhbmVSZWN0IiwidmlzaWJsZU5vZGVzIiwiZm9yRWFjaCIsInNlbGVjdGFibGUiLCJoaWRkZW4iLCJub2RlUmVjdCIsIm92ZXJsYXBwaW5nQXJlYSIsIm5vdEluaXRpYWxpemVkIiwicGFydGlhbGx5VmlzaWJsZSIsImFyZWEiLCJpc1Zpc2libGUiLCJkcmFnZ2luZyIsInB1c2giLCJnZXRDb25uZWN0ZWRFZGdlcyIsIm5vZGVJZHMiLCJnZXRUcmFuc2Zvcm1Gb3JCb3VuZHMiLCJtaW5ab29tIiwibWF4Wm9vbSIsInBhZGRpbmciLCJnZXRWaWV3cG9ydEZvckJvdW5kcyIsInhab29tIiwieVpvb20iLCJjbGFtcGVkWm9vbSIsImJvdW5kc0NlbnRlclgiLCJib3VuZHNDZW50ZXJZIiwiZ2V0RDNUcmFuc2l0aW9uIiwic2VsZWN0aW9uIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uIiwiZ2V0SGFuZGxlcyIsImhhbmRsZUJvdW5kcyIsImN1cnJlbnRIYW5kbGUiLCJoIiwiZ2V0Q2xvc2VzdEhhbmRsZSIsImRvYyIsImNvbm5lY3Rpb25SYWRpdXMiLCJoYW5kbGVzIiwidmFsaWRhdG9yIiwiZG9tTm9kZXMiLCJlbGVtZW50c0Zyb21Qb2ludCIsImhhbmRsZUJlbG93IiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJoYW5kbGVOb2RlSWQiLCJnZXRBdHRyaWJ1dGUiLCJoYW5kbGVUeXBlIiwiZ2V0SGFuZGxlVHlwZSIsImhhbmRsZUlkIiwidmFsaWRIYW5kbGVSZXN1bHQiLCJoYW5kbGUiLCJjbG9zZXN0SGFuZGxlcyIsIm1pbkRpc3RhbmNlIiwiZGVmYXVsdFJlc3VsdCIsImhhc1ZhbGlkSGFuZGxlIiwiaXNWYWxpZCIsImhhc1RhcmdldEhhbmRsZSIsIm51bGxDb25uZWN0aW9uIiwiaGFuZGxlRG9tTm9kZSIsImNvbm5lY3Rpb24iLCJlbmRIYW5kbGUiLCJpc1ZhbGlkSGFuZGxlIiwiY29ubmVjdGlvbk1vZGUiLCJmcm9tTm9kZUlkIiwiZnJvbUhhbmRsZUlkIiwiZnJvbVR5cGUiLCJpc1ZhbGlkQ29ubmVjdGlvbiIsImlzVGFyZ2V0IiwiaGFuZGxlVG9DaGVjayIsInF1ZXJ5U2VsZWN0b3IiLCJyZXN1bHQiLCJjb25uZWN0YWJsZSIsImNvbm5lY3RhYmxlRW5kIiwiaXNDb25uZWN0YWJsZSIsIlN0cmljdCIsImdldEhhbmRsZUxvb2t1cCIsInNvdXJjZUhhbmRsZXMiLCJ0YXJnZXRIYW5kbGVzIiwiZWRnZVVwZGF0ZXJUeXBlIiwicmVzZXRSZWNlbnRIYW5kbGUiLCJyZW1vdmUiLCJnZXRDb25uZWN0aW9uU3RhdHVzIiwiaXNJbnNpZGVDb25uZWN0aW9uUmFkaXVzIiwiaXNIYW5kbGVWYWxpZCIsImNvbm5lY3Rpb25TdGF0dXMiLCJoYW5kbGVQb2ludGVyRG93biIsIm9uQ29ubmVjdCIsIm9uRWRnZVVwZGF0ZUVuZCIsImRvbU5vZGUiLCJhdXRvUGFuT25Db25uZWN0Iiwib25Db25uZWN0U3RhcnQiLCJwYW5CeSIsImdldE5vZGVzIiwiY2FuY2VsQ29ubmVjdGlvbiIsImF1dG9QYW5JZCIsImNsb3Nlc3RIYW5kbGUiLCJjbGlja2VkSGFuZGxlIiwiZWxlbWVudEZyb21Qb2ludCIsImNvbnRhaW5lckJvdW5kcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInByZXZBY3RpdmVIYW5kbGUiLCJjb25uZWN0aW9uUG9zaXRpb24iLCJhdXRvUGFuU3RhcnRlZCIsImhhbmRsZUxvb2t1cCIsImF1dG9QYW4iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjb25uZWN0aW9uTm9kZUlkIiwiY29ubmVjdGlvbkhhbmRsZUlkIiwiY29ubmVjdGlvbkhhbmRsZVR5cGUiLCJjb25uZWN0aW9uU3RhcnRIYW5kbGUiLCJjb25uZWN0aW9uRW5kSGFuZGxlIiwib25Qb2ludGVyTW92ZSIsImFkZCIsInRvZ2dsZSIsIm9uUG9pbnRlclVwIiwib25Db25uZWN0RW5kIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFsd2F5c1ZhbGlkIiwic2VsZWN0b3IkZiIsImNvbm5lY3RPbkNsaWNrIiwibm9QYW5DbGFzc05hbWUiLCJjb25uZWN0aW5nU2VsZWN0b3IiLCJzdGF0ZSIsInN0YXJ0SGFuZGxlIiwiY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUiLCJjbGlja0hhbmRsZSIsImNvbm5lY3RpbmciLCJjbGlja0Nvbm5lY3RpbmciLCJIYW5kbGUiLCJpc0Nvbm5lY3RhYmxlU3RhcnQiLCJpc0Nvbm5lY3RhYmxlRW5kIiwib25Nb3VzZURvd24iLCJvblRvdWNoU3RhcnQiLCJvbkVycm9yIiwib25Db25uZWN0RXh0ZW5kZWQiLCJwYXJhbXMiLCJkZWZhdWx0RWRnZU9wdGlvbnMiLCJvbkNvbm5lY3RBY3Rpb24iLCJoYXNEZWZhdWx0RWRnZXMiLCJzZXRFZGdlcyIsIm9uUG9pbnRlckRvd24iLCJidXR0b24iLCJvbkNsaWNrIiwib25DbGlja0Nvbm5lY3RTdGFydCIsIm9uQ2xpY2tDb25uZWN0RW5kIiwiaXNWYWxpZENvbm5lY3Rpb25TdG9yZSIsImlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciIsImNvbm5lY3RhYmxlc3RhcnQiLCJjb25uZWN0YWJsZWVuZCIsImNvbm5lY3Rpb25pbmRpY2F0b3IiLCJIYW5kbGUkMSIsIkRlZmF1bHROb2RlIiwiZGF0YSIsIkRlZmF1bHROb2RlJDEiLCJJbnB1dE5vZGUiLCJJbnB1dE5vZGUkMSIsIk91dHB1dE5vZGUiLCJPdXRwdXROb2RlJDEiLCJHcm91cE5vZGUiLCJzZWxlY3RvciRlIiwic2VsZWN0ZWROb2RlcyIsInNlbGVjdGVkIiwic2VsZWN0ZWRFZGdlcyIsInNlbGVjdElkIiwiYXJlRXF1YWwiLCJTZWxlY3Rpb25MaXN0ZW5lciIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwiZm4iLCJjaGFuZ2VTZWxlY3RvciIsIldyYXBwZXIkMSIsInN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlIiwic2VsZWN0b3IkZCIsInNldE5vZGVzIiwic2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMiLCJzZXRNaW5ab29tIiwic2V0TWF4Wm9vbSIsInNldFRyYW5zbGF0ZUV4dGVudCIsInNldE5vZGVFeHRlbnQiLCJyZXNldCIsInVzZVN0b3JlVXBkYXRlciIsInNldFN0b3JlU3RhdGUiLCJ1c2VEaXJlY3RTdG9yZVVwZGF0ZXIiLCJTdG9yZVVwZGF0ZXIiLCJkZWZhdWx0Tm9kZXMiLCJkZWZhdWx0RWRnZXMiLCJub2Rlc0RyYWdnYWJsZSIsIm5vZGVzQ29ubmVjdGFibGUiLCJub2Rlc0ZvY3VzYWJsZSIsImVkZ2VzRm9jdXNhYmxlIiwiZWRnZXNVcGRhdGFibGUiLCJlbGV2YXRlTm9kZXNPblNlbGVjdCIsIm5vZGVFeHRlbnQiLCJvbk5vZGVzQ2hhbmdlIiwib25FZGdlc0NoYW5nZSIsImVsZW1lbnRzU2VsZWN0YWJsZSIsInNuYXBHcmlkIiwidHJhbnNsYXRlRXh0ZW50IiwiZml0VmlldyIsImZpdFZpZXdPcHRpb25zIiwib25Ob2Rlc0RlbGV0ZSIsIm9uRWRnZXNEZWxldGUiLCJvbk5vZGVEcmFnIiwib25Ob2RlRHJhZ1N0YXJ0Iiwib25Ob2RlRHJhZ1N0b3AiLCJvblNlbGVjdGlvbkRyYWciLCJvblNlbGVjdGlvbkRyYWdTdGFydCIsIm9uU2VsZWN0aW9uRHJhZ1N0b3AiLCJhdXRvUGFuT25Ob2RlRHJhZyIsIm5vZGVEcmFnVGhyZXNob2xkIiwiZWRnZXNXaXRoRGVmYXVsdHMiLCJkaXNwbGF5IiwiYXJpYUxpdmVTdHlsZSIsIm1hcmdpbiIsImJvcmRlciIsIm92ZXJmbG93IiwiY2xpcCIsImNsaXBQYXRoIiwiQVJJQV9OT0RFX0RFU0NfS0VZIiwiQVJJQV9FREdFX0RFU0NfS0VZIiwiQVJJQV9MSVZFX01FU1NBR0UiLCJzZWxlY3RvciRjIiwiYXJpYUxpdmVNZXNzYWdlIiwiQXJpYUxpdmVNZXNzYWdlIiwiQTExeURlc2NyaXB0aW9ucyIsImRpc2FibGVLZXlib2FyZEExMXkiLCJ1c2VLZXlQcmVzcyIsImtleUNvZGUiLCJhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciIsImtleVByZXNzZWQiLCJzZXRLZXlQcmVzc2VkIiwibW9kaWZpZXJQcmVzc2VkIiwicHJlc3NlZEtleXMiLCJTZXQiLCJrZXlDb2RlcyIsImtleXNUb1dhdGNoIiwia2V5Q29kZUFyciIsIkFycmF5IiwiaXNBcnJheSIsImtjIiwia2V5c0ZsYXQiLCJpdGVtIiwiZG93bkhhbmRsZXIiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwicHJldmVudEFjdGlvbiIsImtleU9yQ29kZSIsInVzZUtleU9yQ29kZSIsImNvZGUiLCJpc01hdGNoaW5nS2V5IiwicHJldmVudERlZmF1bHQiLCJ1cEhhbmRsZXIiLCJjbGVhciIsImRlbGV0ZSIsInJlc2V0SGFuZGxlciIsImlzVXAiLCJldmVyeSIsImsiLCJoYXMiLCJldmVudENvZGUiLCJjYWxjdWxhdGVYWVpQb3NpdGlvbiIsInBhcmVudE5vZGUiLCJnZXQiLCJwYXJlbnROb2RlUG9zaXRpb24iLCJ6IiwidXBkYXRlQWJzb2x1dGVOb2RlUG9zaXRpb25zIiwicGFyZW50Tm9kZXMiLCJpc1BhcmVudCIsImNyZWF0ZU5vZGVJbnRlcm5hbHMiLCJuZXh0Tm9kZUludGVybmFscyIsIk1hcCIsInNlbGVjdGVkTm9kZVoiLCJ6SW5kZXgiLCJjdXJySW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwic2V0IiwiZDNab29tIiwiZDNTZWxlY3Rpb24iLCJmaXRWaWV3T25Jbml0RG9uZSIsImZpdFZpZXdPbkluaXQiLCJpc0luaXRpYWxGaXRWaWV3IiwiaW5pdGlhbCIsImQzaW5pdGlhbGl6ZWQiLCJpbmNsdWRlSGlkZGVuTm9kZXMiLCJvcHRpb25Ob2RlIiwibm9kZXNJbml0aWFsaXplZCIsIm5leHRUcmFuc2Zvcm0iLCJ0cmFuc2xhdGUiLCJzY2FsZSIsImhhbmRsZUNvbnRyb2xsZWROb2RlU2VsZWN0aW9uQ2hhbmdlIiwibm9kZUNoYW5nZXMiLCJjaGFuZ2UiLCJoYW5kbGVDb250cm9sbGVkRWRnZVNlbGVjdGlvbkNoYW5nZSIsImVkZ2VDaGFuZ2VzIiwidXBkYXRlTm9kZXNBbmRFZGdlc1NlbGVjdGlvbnMiLCJjaGFuZ2VkTm9kZXMiLCJjaGFuZ2VkRWRnZXMiLCJoYXNEZWZhdWx0Tm9kZXMiLCJub29wIiwiaW5pdGlhbFZpZXdwb3J0SGVscGVyIiwiem9vbUluIiwiem9vbU91dCIsInpvb21UbyIsImdldFpvb20iLCJzZXRWaWV3cG9ydCIsImdldFZpZXdwb3J0Iiwic2V0Q2VudGVyIiwiZml0Qm91bmRzIiwicHJvamVjdCIsInNjcmVlblRvRmxvd1Bvc2l0aW9uIiwiZmxvd1RvU2NyZWVuUG9zaXRpb24iLCJ2aWV3cG9ydEluaXRpYWxpemVkIiwic2VsZWN0b3IkYiIsInVzZVZpZXdwb3J0SGVscGVyIiwidmlld3BvcnRIZWxwZXJGdW5jdGlvbnMiLCJzY2FsZUJ5Iiwiem9vbUxldmVsIiwic2NhbGVUbyIsIm5leHRab29tIiwiZG9tWCIsImRvbVkiLCJyZWxhdGl2ZVBvc2l0aW9uIiwicmVuZGVyZXJQb3NpdGlvbiIsInVzZVJlYWN0RmxvdyIsInZpZXdwb3J0SGVscGVyIiwiZ2V0Tm9kZSIsImdldEVkZ2VzIiwiZ2V0RWRnZSIsInBheWxvYWQiLCJuZXh0Tm9kZXMiLCJjaGFuZ2VzIiwibmV4dEVkZ2VzIiwiYWRkTm9kZXMiLCJjdXJyZW50Tm9kZXMiLCJhZGRFZGdlcyIsInRvT2JqZWN0Iiwidmlld3BvcnQiLCJkZWxldGVFbGVtZW50cyIsIm5vZGVzRGVsZXRlZCIsImVkZ2VzRGVsZXRlZCIsImVkZ2VJZHMiLCJub2Rlc1RvUmVtb3ZlIiwicGFyZW50SGl0IiwiZGVsZXRhYmxlIiwiZGVsZXRhYmxlRWRnZXMiLCJpbml0aWFsSGl0RWRnZXMiLCJjb25uZWN0ZWRFZGdlcyIsImVkZ2VzVG9SZW1vdmUiLCJlZGdlSWRzVG9SZW1vdmUiLCJnZXROb2RlUmVjdCIsIm5vZGVPclJlY3QiLCJpc1JlY3QiLCJnZXRJbnRlcnNlY3RpbmdOb2RlcyIsImN1cnJOb2RlUmVjdCIsImlzTm9kZUludGVyc2VjdGluZyIsImRlbGV0ZUtleU9wdGlvbnMiLCJ1c2VHbG9iYWxLZXlIYW5kbGVyIiwiZGVsZXRlS2V5Q29kZSIsIm11bHRpU2VsZWN0aW9uS2V5Q29kZSIsImRlbGV0ZUtleVByZXNzZWQiLCJtdWx0aVNlbGVjdGlvbktleVByZXNzZWQiLCJub2Rlc1NlbGVjdGlvbkFjdGl2ZSIsIm11bHRpU2VsZWN0aW9uQWN0aXZlIiwidXNlUmVzaXplSGFuZGxlciIsInJlbmRlcmVyTm9kZSIsInJlc2l6ZU9ic2VydmVyIiwidXBkYXRlRGltZW5zaW9ucyIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsImNvbnRhaW5lclN0eWxlIiwidmlld0NoYW5nZWQiLCJwcmV2Vmlld3BvcnQiLCJldmVudFRyYW5zZm9ybSIsImV2ZW50VG9GbG93VHJhbnNmb3JtIiwiaXNXcmFwcGVkV2l0aENsYXNzIiwiaXNSaWdodENsaWNrUGFuIiwicGFuT25EcmFnIiwidXNlZEJ1dHRvbiIsIndoZWVsRGVsdGEiLCJmYWN0b3IiLCJkZWx0YVkiLCJkZWx0YU1vZGUiLCJzZWxlY3RvciRhIiwiZDNab29tSGFuZGxlciIsIlpvb21QYW5lIiwib25Nb3ZlIiwib25Nb3ZlU3RhcnQiLCJvbk1vdmVFbmQiLCJvblBhbmVDb250ZXh0TWVudSIsInpvb21PblNjcm9sbCIsInpvb21PblBpbmNoIiwicGFuT25TY3JvbGwiLCJwYW5PblNjcm9sbFNwZWVkIiwicGFuT25TY3JvbGxNb2RlIiwiRnJlZSIsInpvb21PbkRvdWJsZUNsaWNrIiwiZGVmYXVsdFZpZXdwb3J0Iiwiem9vbUFjdGl2YXRpb25LZXlDb2RlIiwicHJldmVudFNjcm9sbGluZyIsIm5vV2hlZWxDbGFzc05hbWUiLCJ0aW1lcklkIiwiaXNab29taW5nT3JQYW5uaW5nIiwiem9vbWVkV2l0aFJpZ2h0TW91c2VCdXR0b24iLCJ6b29tUGFuZSIsInByZXZUcmFuc2Zvcm0iLCJ6b29tQWN0aXZhdGlvbktleVByZXNzZWQiLCJtb3VzZUJ1dHRvbiIsImlzUGFuU2Nyb2xsaW5nIiwicGFuU2Nyb2xsVGltZW91dCIsImJib3giLCJkM1pvb21JbnN0YW5jZSIsInNjYWxlRXh0ZW50IiwiY2FsbCIsInVwZGF0ZWRUcmFuc2Zvcm0iLCJjb25zdHJhaW5lZFRyYW5zZm9ybSIsImNvbnN0cmFpbiIsIm9uIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiY3VycmVudFpvb20iLCJwcm9wZXJ0eSIsIl9pc01hY09zIiwicG9pbnQiLCJwaW5jaERlbHRhIiwiZGVsdGFOb3JtYWxpemUiLCJkZWx0YVgiLCJWZXJ0aWNhbCIsIkhvcml6b250YWwiLCJ0cmFuc2xhdGVCeSIsImludGVybmFsIiwibmV4dFZpZXdwb3J0Iiwib25WaWV3cG9ydENoYW5nZVN0YXJ0Iiwib25WaWV3cG9ydENoYW5nZSIsIm9uVmlld3BvcnRDaGFuZ2VFbmQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwicGFzc2l2ZSIsInNvdXJjZUV2ZW50IiwiZmxvd1RyYW5zZm9ybSIsInBhbmVEcmFnZ2luZyIsInpvb21TY3JvbGwiLCJwaW5jaFpvb20iLCJidXR0b25BbGxvd2VkIiwic2VsZWN0b3IkOSIsInVzZXJTZWxlY3Rpb25SZWN0IiwiVXNlclNlbGVjdGlvbiIsImlzQWN0aXZlIiwiaGFuZGxlUGFyZW50RXhwYW5kIiwidXBkYXRlSXRlbSIsInBhcmVudCIsImV4dGVuZFdpZHRoIiwiZXh0ZW5kSGVpZ2h0IiwieERpZmYiLCJ5RGlmZiIsImFwcGx5Q2hhbmdlcyIsImVsZW1lbnRzIiwiaW5pdEVsZW1lbnRzIiwiY3VycmVudENoYW5nZXMiLCJjdXJyZW50Q2hhbmdlIiwiZXhwYW5kUGFyZW50IiwiZGltZW5zaW9ucyIsInVwZGF0ZVN0eWxlIiwicmVzaXppbmciLCJhcHBseU5vZGVDaGFuZ2VzIiwiYXBwbHlFZGdlQ2hhbmdlcyIsImNyZWF0ZVNlbGVjdGlvbkNoYW5nZSIsImdldFNlbGVjdGlvbkNoYW5nZXMiLCJpdGVtcyIsInNlbGVjdGVkSWRzIiwid2lsbEJlU2VsZWN0ZWQiLCJ3cmFwSGFuZGxlciIsImNvbnRhaW5lclJlZiIsInNlbGVjdG9yJDgiLCJQYW5lIiwiaXNTZWxlY3RpbmciLCJzZWxlY3Rpb25Nb2RlIiwiRnVsbCIsIm9uU2VsZWN0aW9uU3RhcnQiLCJvblNlbGVjdGlvbkVuZCIsIm9uUGFuZUNsaWNrIiwib25QYW5lU2Nyb2xsIiwib25QYW5lTW91c2VFbnRlciIsIm9uUGFuZU1vdXNlTW92ZSIsIm9uUGFuZU1vdXNlTGVhdmUiLCJjb250YWluZXIiLCJwcmV2U2VsZWN0ZWROb2Rlc0NvdW50IiwicHJldlNlbGVjdGVkRWRnZXNDb3VudCIsInJlc2V0VXNlclNlbGVjdGlvbiIsInJlc2V0U2VsZWN0ZWRFbGVtZW50cyIsIm9uQ29udGV4dE1lbnUiLCJvbldoZWVsIiwic3RhcnRYIiwic3RhcnRZIiwib25Nb3VzZU1vdmUiLCJtb3VzZVBvcyIsIm5leHRVc2VyU2VsZWN0UmVjdCIsIlBhcnRpYWwiLCJzZWxlY3RlZEVkZ2VJZHMiLCJzZWxlY3RlZE5vZGVJZHMiLCJvbk1vdXNlVXAiLCJvbk1vdXNlTGVhdmUiLCJoYXNBY3RpdmVTZWxlY3Rpb24iLCJvbk1vdXNlRW50ZXIiLCJpc1BhcmVudFNlbGVjdGVkIiwiaGFzU2VsZWN0b3IiLCJub2RlUmVmIiwibWF0Y2hlcyIsInBhcmVudEVsZW1lbnQiLCJnZXREcmFnSXRlbXMiLCJmcm9tIiwidmFsdWVzIiwiZHJhZ2dhYmxlIiwiZGVsdGEiLCJjbGFtcE5vZGVFeHRlbnQiLCJjYWxjTmV4dFBvc2l0aW9uIiwibmV4dFBvc2l0aW9uIiwiY2xhbXBlZE5vZGVFeHRlbnQiLCJjdXJyZW50RXh0ZW50IiwicGFyZW50WCIsInBhcmVudFkiLCJwYXJlbnRQb3NpdGlvbiIsImdldEV2ZW50SGFuZGxlclBhcmFtcyIsImRyYWdJdGVtcyIsImV4dGVudGVkRHJhZ0l0ZW1zIiwiZ2V0SGFuZGxlQm91bmRzIiwibm9kZUVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaGFuZGxlc0FycmF5Iiwibm9kZUJvdW5kcyIsIm5vZGVPZmZzZXQiLCJnZXRNb3VzZUhhbmRsZXIiLCJoYW5kbGVOb2RlQ2xpY2siLCJ1bnNlbGVjdCIsImFkZFNlbGVjdGVkTm9kZXMiLCJ1bnNlbGVjdE5vZGVzQW5kRWRnZXMiLCJibHVyIiwidXNlR2V0UG9pbnRlclBvc2l0aW9uIiwiZ2V0UG9pbnRlclBvc2l0aW9uIiwicG9pbnRlclBvcyIsInhTbmFwcGVkIiwieVNuYXBwZWQiLCJ3cmFwU2VsZWN0aW9uRHJhZ0Z1bmMiLCJzZWxlY3Rpb25GdW5jIiwiXyIsInVzZURyYWciLCJkaXNhYmxlZCIsIm5vRHJhZ0NsYXNzTmFtZSIsImhhbmRsZVNlbGVjdG9yIiwiaXNTZWxlY3RhYmxlIiwic2VsZWN0Tm9kZXNPbkRyYWciLCJzZXREcmFnZ2luZyIsImxhc3RQb3MiLCJtb3VzZVBvc2l0aW9uIiwiZHJhZ0V2ZW50IiwiZHJhZ1N0YXJ0ZWQiLCJ1cGRhdGVOb2RlcyIsInVwZGF0ZU5vZGVQb3NpdGlvbnMiLCJoYXNDaGFuZ2UiLCJub2Rlc0JveCIsImFkanVzdGVkTm9kZUV4dGVudCIsInVwZGF0ZWRQb3MiLCJvbkRyYWciLCJjdXJyZW50Tm9kZSIsInN0YXJ0RHJhZyIsIm9uU3RhcnQiLCJkcmFnSGFuZGxlciIsIm9uU3RvcCIsImlzRHJhZ2dhYmxlIiwidXNlVXBkYXRlTm9kZVBvc2l0aW9ucyIsInVwZGF0ZVBvc2l0aW9ucyIsInhWZWxvIiwieVZlbG8iLCJpc1NoaWZ0UHJlc3NlZCIsInBvc2l0aW9uRGlmZlgiLCJwb3NpdGlvbkRpZmZZIiwibm9kZVVwZGF0ZXMiLCJhcnJvd0tleURpZmZzIiwiQXJyb3dVcCIsIkFycm93RG93biIsIkFycm93TGVmdCIsIkFycm93UmlnaHQiLCJ3cmFwTm9kZSIsIk5vZGVDb21wb25lbnQiLCJOb2RlV3JhcHBlciIsInhQb3MiLCJ5UG9zIiwieFBvc09yaWdpbiIsInlQb3NPcmlnaW4iLCJvbkRvdWJsZUNsaWNrIiwiaXNGb2N1c2FibGUiLCJkcmFnSGFuZGxlIiwiaW5pdGlhbGl6ZWQiLCJhcmlhTGFiZWwiLCJwcmV2U291cmNlUG9zaXRpb24iLCJwcmV2VGFyZ2V0UG9zaXRpb24iLCJwcmV2VHlwZSIsImhhc1BvaW50ZXJFdmVudHMiLCJvbk1vdXNlRW50ZXJIYW5kbGVyIiwib25Nb3VzZU1vdmVIYW5kbGVyIiwib25Nb3VzZUxlYXZlSGFuZGxlciIsIm9uQ29udGV4dE1lbnVIYW5kbGVyIiwib25Eb3VibGVDbGlja0hhbmRsZXIiLCJvblNlbGVjdE5vZGVIYW5kbGVyIiwib25LZXlEb3duIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJjdXJyTm9kZSIsInR5cGVDaGFuZ2VkIiwic291cmNlUG9zQ2hhbmdlZCIsInRhcmdldFBvc0NoYW5nZWQiLCJ1cGRhdGVOb2RlRGltZW5zaW9ucyIsImZvcmNlVXBkYXRlIiwidGFiSW5kZXgiLCJyb2xlIiwic2VsZWN0b3IkNyIsInRyYW5zZm9ybVN0cmluZyIsIk5vZGVzU2VsZWN0aW9uIiwib25TZWxlY3Rpb25Db250ZXh0TWVudSIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsIk5vZGVzU2VsZWN0aW9uJDEiLCJzZWxlY3RvciQ2IiwiRmxvd1JlbmRlcmVyIiwic2VsZWN0aW9uS2V5Q29kZSIsInNlbGVjdGlvbk9uRHJhZyIsInBhbkFjdGl2YXRpb25LZXlDb2RlIiwiX3Bhbk9uU2Nyb2xsIiwiX3Bhbk9uRHJhZyIsInNlbGVjdGlvbktleVByZXNzZWQiLCJwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIkZsb3dSZW5kZXJlciQxIiwidXNlVmlzaWJsZU5vZGVzIiwib25seVJlbmRlclZpc2libGUiLCJjcmVhdGVOb2RlVHlwZXMiLCJub2RlVHlwZXMiLCJzdGFuZGFyZFR5cGVzIiwiaW5wdXQiLCJkZWZhdWx0Iiwib3V0cHV0IiwiZ3JvdXAiLCJ3cmFwcGVkVHlwZXMiLCJzcGVjaWFsVHlwZXMiLCJnZXRQb3NpdGlvbldpdGhPcmlnaW4iLCJvcmlnaW4iLCJzZWxlY3RvciQ1IiwiTm9kZVJlbmRlcmVyIiwib25seVJlbmRlclZpc2libGVFbGVtZW50cyIsInJlc2l6ZU9ic2VydmVyUmVmIiwib2JzZXJ2ZXIiLCJlbnRyaWVzIiwidXBkYXRlcyIsImVudHJ5IiwiZGlzY29ubmVjdCIsImZvY3VzYWJsZSIsImNsYW1wZWRQb3NpdGlvbiIsInBvc1giLCJwb3NZIiwicG9zT3JpZ2luIiwib25Ob2RlQ2xpY2siLCJvbk5vZGVNb3VzZUVudGVyIiwib25Ob2RlTW91c2VNb3ZlIiwib25Ob2RlTW91c2VMZWF2ZSIsIm9uTm9kZUNvbnRleHRNZW51Iiwib25Ob2RlRG91YmxlQ2xpY2siLCJOb2RlUmVuZGVyZXIkMSIsInNoaWZ0WCIsInNoaWZ0Iiwic2hpZnRZIiwiRWRnZVVwZGF0ZXJDbGFzc05hbWUiLCJFZGdlQW5jaG9yIiwicmFkaXVzIiwib25Nb3VzZU91dCIsImN4IiwiY3kiLCJyIiwic3Ryb2tlIiwiYWx3YXlzVmFsaWRDb25uZWN0aW9uIiwid3JhcEVkZ2UiLCJFZGdlQ29tcG9uZW50IiwiRWRnZVdyYXBwZXIiLCJvbkVkZ2VEb3VibGVDbGljayIsImFuaW1hdGVkIiwic291cmNlSGFuZGxlSWQiLCJ0YXJnZXRIYW5kbGVJZCIsImVkZ2VVcGRhdGVyUmFkaXVzIiwib25FZGdlVXBkYXRlIiwib25FZGdlVXBkYXRlU3RhcnQiLCJpc1VwZGF0YWJsZSIsInVwZGF0ZUhvdmVyIiwic2V0VXBkYXRlSG92ZXIiLCJ1cGRhdGluZyIsInNldFVwZGF0aW5nIiwibWFya2VyU3RhcnRVcmwiLCJtYXJrZXJFbmRVcmwiLCJvbkVkZ2VDbGljayIsImFkZFNlbGVjdGVkRWRnZXMiLCJvbkVkZ2VEb3VibGVDbGlja0hhbmRsZXIiLCJvbkVkZ2VDb250ZXh0TWVudSIsIm9uRWRnZU1vdXNlRW50ZXIiLCJvbkVkZ2VNb3VzZU1vdmUiLCJvbkVkZ2VNb3VzZUxlYXZlIiwiaGFuZGxlRWRnZVVwZGF0ZXIiLCJpc1NvdXJjZUhhbmRsZSIsIl9vbkVkZ2VVcGRhdGVFbmQiLCJldnQiLCJvbkNvbm5lY3RFZGdlIiwib25FZGdlVXBkYXRlclNvdXJjZU1vdXNlRG93biIsIm9uRWRnZVVwZGF0ZXJUYXJnZXRNb3VzZURvd24iLCJvbkVkZ2VVcGRhdGVyTW91c2VFbnRlciIsIm9uRWRnZVVwZGF0ZXJNb3VzZU91dCIsImluYWN0aXZlIiwiY3JlYXRlRWRnZVR5cGVzIiwiZWRnZVR5cGVzIiwic3RyYWlnaHQiLCJiZXppZXIiLCJzdGVwIiwic21vb3Roc3RlcCIsInNpbXBsZWJlemllciIsImdldEhhbmRsZVBvc2l0aW9uIiwiZ2V0SGFuZGxlIiwiZ2V0RWRnZVBvc2l0aW9ucyIsInNvdXJjZU5vZGVSZWN0IiwidGFyZ2V0Tm9kZVJlY3QiLCJzb3VyY2VIYW5kbGVQb3MiLCJ0YXJnZXRIYW5kbGVQb3MiLCJpc0VkZ2VWaXNpYmxlIiwic291cmNlUG9zIiwidGFyZ2V0UG9zIiwic291cmNlV2lkdGgiLCJzb3VyY2VIZWlnaHQiLCJ0YXJnZXRXaWR0aCIsInRhcmdldEhlaWdodCIsImVkZ2VCb3giLCJ2aWV3Qm94IiwiZ2V0Tm9kZURhdGEiLCJkZWZhdWx0RWRnZVRyZWUiLCJsZXZlbCIsImlzTWF4TGV2ZWwiLCJncm91cEVkZ2VzQnlaTGV2ZWwiLCJlbGV2YXRlRWRnZXNPblNlbGVjdCIsIm1heExldmVsIiwibGV2ZWxMb29rdXAiLCJ0cmVlIiwiaGFzWkluZGV4IiwidGFyZ2V0Tm9kZSIsInNvdXJjZU5vZGUiLCJlZGdlT3JDb25uZWN0ZWROb2RlU2VsZWN0ZWQiLCJzZWxlY3RlZFpJbmRleCIsImVkZ2VUcmVlIiwidXNlVmlzaWJsZUVkZ2VzIiwiQXJyb3dTeW1ib2wiLCJjb2xvciIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsIkFycm93Q2xvc2VkU3ltYm9sIiwiTWFya2VyU3ltYm9scyIsIkFycm93IiwiQXJyb3dDbG9zZWQiLCJ1c2VNYXJrZXJTeW1ib2wiLCJzeW1ib2wiLCJzeW1ib2xFeGlzdHMiLCJNYXJrZXIiLCJtYXJrZXJVbml0cyIsIm9yaWVudCIsIm1hcmtlcldpZHRoIiwibWFya2VySGVpZ2h0IiwicmVmWCIsInJlZlkiLCJtYXJrZXJTZWxlY3RvciIsImRlZmF1bHRDb2xvciIsImlkcyIsIm1hcmtlcnMiLCJtYXJrZXJJZCIsImxvY2FsZUNvbXBhcmUiLCJNYXJrZXJEZWZpbml0aW9ucyIsIm0iLCJNYXJrZXJEZWZpbml0aW9ucyQxIiwic2VsZWN0b3IkNCIsIkVkZ2VSZW5kZXJlciIsImRlZmF1bHRNYXJrZXJDb2xvciIsInNvdXJjZUhhbmRsZUJvdW5kcyIsInNvdXJjZUlzVmFsaWQiLCJ0YXJnZXRIYW5kbGVCb3VuZHMiLCJ0YXJnZXRJc1ZhbGlkIiwidGFyZ2V0Tm9kZUhhbmRsZXMiLCJ1cGRhdGFibGUiLCJFZGdlUmVuZGVyZXIkMSIsInNlbGVjdG9yJDMiLCJWaWV3cG9ydCIsInVzZU9uSW5pdEhhbmRsZXIiLCJvbkluaXQiLCJyZkluc3RhbmNlIiwiaXNJbml0aWFsaXplZCIsIm9wcG9zaXRlUG9zaXRpb24iLCJDb25uZWN0aW9uTGluZSIsIkJlemllciIsIkN1c3RvbUNvbXBvbmVudCIsImZyb21Ob2RlIiwidG9YIiwidG9ZIiwiZnJvbUhhbmRsZUJvdW5kcyIsIkxvb3NlIiwiZnJvbUhhbmRsZSIsImZyb21IYW5kbGVYIiwiZnJvbUhhbmRsZVkiLCJmcm9tWCIsImZyb21ZIiwiZnJvbVBvc2l0aW9uIiwidG9Qb3NpdGlvbiIsImNvbm5lY3Rpb25MaW5lVHlwZSIsImNvbm5lY3Rpb25MaW5lU3R5bGUiLCJkQXR0ciIsInBhdGhQYXJhbXMiLCJTdGVwIiwiU21vb3RoU3RlcCIsIlNpbXBsZUJlemllciIsInNlbGVjdG9yJDIiLCJDb25uZWN0aW9uTGluZVdyYXBwZXIiLCJjb21wb25lbnQiLCJ1c2VOb2RlT3JFZGdlVHlwZXMiLCJub2RlT3JFZGdlVHlwZXMiLCJjcmVhdGVUeXBlcyIsInR5cGVzS2V5c1JlZiIsInR5cGVzUGFyc2VkIiwidHlwZUtleXMiLCJHcmFwaFZpZXciLCJjb25uZWN0aW9uTGluZUNvbXBvbmVudCIsImNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUiLCJub2RlVHlwZXNXcmFwcGVkIiwiZWRnZVR5cGVzV3JhcHBlZCIsIkdyYXBoVmlldyQxIiwiaW5maW5pdGVFeHRlbnQiLCJOdW1iZXIiLCJORUdBVElWRV9JTkZJTklUWSIsIlBPU0lUSVZFX0lORklOSVRZIiwiaW5pdGlhbFN0YXRlIiwiZml0Vmlld09uSW5pdE9wdGlvbnMiLCJjcmVhdGVSRlN0b3JlIiwidmlld3BvcnROb2RlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm0yMiIsIkRPTU1hdHJpeFJlYWRPbmx5IiwidXBkYXRlIiwiZG9VcGRhdGUiLCJuZXh0Rml0Vmlld09uSW5pdERvbmUiLCJub2RlRHJhZ0l0ZW1zIiwicG9zaXRpb25DaGFuZ2VkIiwidHJpZ2dlck5vZGVDaGFuZ2VzIiwiZWRnZUlkIiwic3RvcmVFZGdlcyIsIm5vZGVzVG9VbnNlbGVjdCIsImVkZ2VzVG9VbnNlbGVjdCIsInRyYW5zZm9ybUNoYW5nZWQiLCJpcyIsIlJlYWN0Rmxvd1Byb3ZpZGVyIiwic3RvcmVSZWYiLCJXcmFwcGVyIiwiaXNXcmFwcGVkIiwiZGVmYXVsdE5vZGVUeXBlcyIsImRlZmF1bHRFZGdlVHlwZXMiLCJpbml0Tm9kZU9yaWdpbiIsImluaXRTbmFwR3JpZCIsImluaXREZWZhdWx0Vmlld3BvcnQiLCJ3cmFwcGVyU3R5bGUiLCJSZWFjdEZsb3ciLCJhdHRyaWJ1dGlvblBvc2l0aW9uIiwic2VsZWN0b3IkMSIsIkVkZ2VMYWJlbFJlbmRlcmVyIiwiZWRnZUxhYmVsUmVuZGVyZXIiLCJ1c2VVcGRhdGVOb2RlSW50ZXJuYWxzIiwidXBkYXRlSWRzIiwidXBkYXRlSWQiLCJub2Rlc1NlbGVjdG9yIiwidXNlTm9kZXMiLCJlZGdlc1NlbGVjdG9yIiwidXNlRWRnZXMiLCJ2aWV3cG9ydFNlbGVjdG9yIiwidXNlVmlld3BvcnQiLCJjcmVhdGVVc2VJdGVtc1N0YXRlIiwiaW5pdGlhbEl0ZW1zIiwic2V0SXRlbXMiLCJvbkl0ZW1zQ2hhbmdlIiwidXNlTm9kZXNTdGF0ZSIsInVzZUVkZ2VzU3RhdGUiLCJ1c2VPblZpZXdwb3J0Q2hhbmdlIiwib25DaGFuZ2UiLCJvbkVuZCIsInVzZU9uU2VsZWN0aW9uQ2hhbmdlIiwibmV4dFNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIiwibmV4dEhhbmRsZXJzIiwiZGVmYXVsdE9wdGlvbnMiLCJ1c2VOb2Rlc0luaXRpYWxpemVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reactflow/core/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reactflow/minimap/dist/esm/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@reactflow/minimap/dist/esm/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap$1)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var _reactflow_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reactflow/core */ \"(ssr)/./node_modules/@reactflow/core/dist/esm/index.mjs\");\n\n\n\n\n\n\nconst MiniMapNode = ({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, onClick, selected })=>{\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__minimap-node\",\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        fill: fill,\n        stroke: strokeColor,\n        strokeWidth: strokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n};\nMiniMapNode.displayName = \"MiniMapNode\";\nvar MiniMapNode$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MiniMapNode);\n/* eslint-disable @typescript-eslint/ban-ts-comment */ const selector$1 = (s)=>s.nodeOrigin;\nconst selectorNodes = (s)=>s.getNodes().filter((node)=>!node.hidden && node.width && node.height);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor = \"transparent\", nodeColor = \"#e2e2e2\", nodeClassName = \"\", nodeBorderRadius = 5, nodeStrokeWidth = 2, // We need to rename the prop to be `CapitalCase` so that JSX will render it as\n// a component properly.\nnodeComponent: NodeComponent = MiniMapNode$1, onClick }) {\n    const nodes = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.useStore)(selectorNodes, zustand_shallow__WEBPACK_IMPORTED_MODULE_4__.shallow);\n    const nodeOrigin = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.useStore)(selector$1);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? \"crispEdges\" : 0;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, nodes.map((node)=>{\n        const { x, y } = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.getNodePositionWithOrigin)(node, nodeOrigin).positionAbsolute;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NodeComponent, {\n            key: node.id,\n            x: x,\n            y: y,\n            width: node.width,\n            height: node.height,\n            style: node.style,\n            selected: node.selected,\n            className: nodeClassNameFunc(node),\n            color: nodeColorFunc(node),\n            borderRadius: nodeBorderRadius,\n            strokeColor: nodeStrokeColorFunc(node),\n            strokeWidth: nodeStrokeWidth,\n            shapeRendering: shapeRendering,\n            onClick: onClick,\n            id: node.id\n        });\n    }));\n}\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MiniMapNodes);\n/* eslint-disable @typescript-eslint/ban-ts-comment */ const defaultWidth = 200;\nconst defaultHeight = 150;\nconst selector = (s)=>{\n    const nodes = s.getNodes();\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: nodes.length > 0 ? (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.getBoundsOfRects)((0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds)(nodes, s.nodeOrigin), viewBB) : viewBB,\n        rfId: s.rfId\n    };\n};\nconst ARIA_LABEL_KEY = \"react-flow__minimap-desc\";\nfunction MiniMap({ style, className, nodeStrokeColor = \"transparent\", nodeColor = \"#e2e2e2\", nodeClassName = \"\", nodeBorderRadius = 5, nodeStrokeWidth = 2, // We need to rename the prop to be `CapitalCase` so that JSX will render it as\n// a component properly.\nnodeComponent, maskColor = \"rgb(240, 240, 240, 0.6)\", maskStrokeColor = \"none\", maskStrokeWidth = 1, position = \"bottom-right\", onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel = \"React Flow mini map\", inversePan = false, zoomStep = 10, offsetScale = 5 }) {\n    const store = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.useStoreApi)();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { boundingRect, viewBB, rfId } = (0,_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.useStore)(selector, zustand_shallow__WEBPACK_IMPORTED_MODULE_4__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (svg.current) {\n            const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(svg.current);\n            const zoomHandler = (event)=>{\n                const { transform, d3Selection, d3Zoom } = store.getState();\n                if (event.sourceEvent.type !== \"wheel\" || !d3Selection || !d3Zoom) {\n                    return;\n                }\n                const pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) * zoomStep;\n                const zoom = transform[2] * Math.pow(2, pinchDelta);\n                d3Zoom.scaleTo(d3Selection, zoom);\n            };\n            const panHandler = (event)=>{\n                const { transform, d3Selection, d3Zoom, translateExtent, width, height } = store.getState();\n                if (event.sourceEvent.type !== \"mousemove\" || !d3Selection || !d3Zoom) {\n                    return;\n                }\n                // @TODO: how to calculate the correct next position? Math.max(1, transform[2]) is a workaround.\n                const moveScale = viewScaleRef.current * Math.max(1, transform[2]) * (inversePan ? -1 : 1);\n                const position = {\n                    x: transform[0] - event.sourceEvent.movementX * moveScale,\n                    y: transform[1] - event.sourceEvent.movementY * moveScale\n                };\n                const extent = [\n                    [\n                        0,\n                        0\n                    ],\n                    [\n                        width,\n                        height\n                    ]\n                ];\n                const nextTransform = d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoomIdentity.translate(position.x, position.y).scale(transform[2]);\n                const constrainedTransform = d3Zoom.constrain()(nextTransform, extent, translateExtent);\n                d3Zoom.transform(d3Selection, constrainedTransform);\n            };\n            const zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_2__.zoom)()// @ts-ignore\n            .on(\"zoom\", pannable ? panHandler : null)// @ts-ignore\n            .on(\"zoom.wheel\", zoomable ? zoomHandler : null);\n            selection.call(zoomAndPanHandler);\n            return ()=>{\n                selection.on(\"zoom\", null);\n            };\n        }\n    }, [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const rfCoord = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(event);\n        onClick(event, {\n            x: rfCoord[0],\n            y: rfCoord[1]\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (event, nodeId)=>{\n        const node = store.getState().nodeInternals.get(nodeId);\n        onNodeClick(event, node);\n    } : undefined;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_reactflow_core__WEBPACK_IMPORTED_MODULE_3__.Panel, {\n        position: position,\n        style: style,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            \"react-flow__minimap\",\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        width: elementWidth,\n        height: elementHeight,\n        viewBox: `${x} ${y} ${width} ${height}`,\n        role: \"img\",\n        \"aria-labelledby\": labelledBy,\n        ref: svg,\n        onClick: onSvgClick\n    }, ariaLabel && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"title\", {\n        id: labelledBy\n    }, ariaLabel), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MiniMapNodes$1, {\n        onClick: onSvgNodeClick,\n        nodeColor: nodeColor,\n        nodeStrokeColor: nodeStrokeColor,\n        nodeBorderRadius: nodeBorderRadius,\n        nodeClassName: nodeClassName,\n        nodeStrokeWidth: nodeStrokeWidth,\n        nodeComponent: nodeComponent\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        className: \"react-flow__minimap-mask\",\n        d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n        fill: maskColor,\n        fillRule: \"evenodd\",\n        stroke: maskStrokeColor,\n        strokeWidth: maskStrokeWidth,\n        pointerEvents: \"none\"\n    })));\n}\nMiniMap.displayName = \"MiniMap\";\nvar MiniMap$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MiniMap);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0Zmxvdy9taW5pbWFwL2Rpc3QvZXNtL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1RDtBQUM3QjtBQUNnQjtBQUNHO0FBQ0U7QUFDNkU7QUFFNUgsTUFBTWdCLGNBQWMsQ0FBQyxFQUFFQyxFQUFFLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsY0FBYyxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRztJQUNqSixNQUFNLEVBQUVDLFVBQVUsRUFBRUMsZUFBZSxFQUFFLEdBQUdWLFNBQVMsQ0FBQztJQUNsRCxNQUFNVyxPQUFRVixTQUFTUSxjQUFjQztJQUNyQyxxQkFBUWhDLGdEQUFtQixDQUFDLFFBQVE7UUFBRTBCLFdBQVd0QixvREFBRUEsQ0FBQztZQUFDO1lBQTRCO2dCQUFFMEI7WUFBUztZQUFHSjtTQUFVO1FBQUdSLEdBQUdBO1FBQUdDLEdBQUdBO1FBQUdnQixJQUFJUjtRQUFjUyxJQUFJVDtRQUFjUCxPQUFPQTtRQUFPQyxRQUFRQTtRQUFRWSxNQUFNQTtRQUFNSSxRQUFRYjtRQUFhQyxhQUFhQTtRQUFhRyxnQkFBZ0JBO1FBQWdCQyxTQUFTQSxVQUFVLENBQUNTLFFBQVVULFFBQVFTLE9BQU9yQixNQUFNc0I7SUFBVTtBQUN0VjtBQUNBdkIsWUFBWXdCLFdBQVcsR0FBRztBQUMxQixJQUFJQyw4QkFBZ0J4QywyQ0FBSUEsQ0FBQ2U7QUFFekIsb0RBQW9ELEdBQ3BELE1BQU0wQixhQUFhLENBQUNDLElBQU1BLEVBQUVDLFVBQVU7QUFDdEMsTUFBTUMsZ0JBQWdCLENBQUNGLElBQU1BLEVBQUVHLFFBQVEsR0FBR0MsTUFBTSxDQUFDLENBQUNDLE9BQVMsQ0FBQ0EsS0FBS0MsTUFBTSxJQUFJRCxLQUFLNUIsS0FBSyxJQUFJ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QUFJMEcsMEJBQVlqSiwyQ0FBSUEsQ0FBQ2dGO0FBRVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5kLW1hcC8uL25vZGVfbW9kdWxlcy9AcmVhY3RmbG93L21pbmltYXAvZGlzdC9lc20vaW5kZXgubWpzP2Q4YzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IG1lbW8sIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNjIGZyb20gJ2NsYXNzY2F0JztcbmltcG9ydCB7IHNoYWxsb3cgfSBmcm9tICd6dXN0YW5kL3NoYWxsb3cnO1xuaW1wb3J0IHsgem9vbSwgem9vbUlkZW50aXR5IH0gZnJvbSAnZDMtem9vbSc7XG5pbXBvcnQgeyBzZWxlY3QsIHBvaW50ZXIgfSBmcm9tICdkMy1zZWxlY3Rpb24nO1xuaW1wb3J0IHsgdXNlU3RvcmUsIGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4sIHVzZVN0b3JlQXBpLCBQYW5lbCwgZ2V0Qm91bmRzT2ZSZWN0cywgZ2V0Tm9kZXNCb3VuZHMgfSBmcm9tICdAcmVhY3RmbG93L2NvcmUnO1xuXG5jb25zdCBNaW5pTWFwTm9kZSA9ICh7IGlkLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdHlsZSwgY29sb3IsIHN0cm9rZUNvbG9yLCBzdHJva2VXaWR0aCwgY2xhc3NOYW1lLCBib3JkZXJSYWRpdXMsIHNoYXBlUmVuZGVyaW5nLCBvbkNsaWNrLCBzZWxlY3RlZCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgYmFja2dyb3VuZCwgYmFja2dyb3VuZENvbG9yIH0gPSBzdHlsZSB8fCB7fTtcbiAgICBjb25zdCBmaWxsID0gKGNvbG9yIHx8IGJhY2tncm91bmQgfHwgYmFja2dyb3VuZENvbG9yKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX21pbmltYXAtbm9kZScsIHsgc2VsZWN0ZWQgfSwgY2xhc3NOYW1lXSksIHg6IHgsIHk6IHksIHJ4OiBib3JkZXJSYWRpdXMsIHJ5OiBib3JkZXJSYWRpdXMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGZpbGw6IGZpbGwsIHN0cm9rZTogc3Ryb2tlQ29sb3IsIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCwgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nLCBvbkNsaWNrOiBvbkNsaWNrID8gKGV2ZW50KSA9PiBvbkNsaWNrKGV2ZW50LCBpZCkgOiB1bmRlZmluZWQgfSkpO1xufTtcbk1pbmlNYXBOb2RlLmRpc3BsYXlOYW1lID0gJ01pbmlNYXBOb2RlJztcbnZhciBNaW5pTWFwTm9kZSQxID0gbWVtbyhNaW5pTWFwTm9kZSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAqL1xuY29uc3Qgc2VsZWN0b3IkMSA9IChzKSA9PiBzLm5vZGVPcmlnaW47XG5jb25zdCBzZWxlY3Rvck5vZGVzID0gKHMpID0+IHMuZ2V0Tm9kZXMoKS5maWx0ZXIoKG5vZGUpID0+ICFub2RlLmhpZGRlbiAmJiBub2RlLndpZHRoICYmIG5vZGUuaGVpZ2h0KTtcbmNvbnN0IGdldEF0dHJGdW5jdGlvbiA9IChmdW5jKSA9PiAoZnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZnVuYyA6ICgpID0+IGZ1bmMpO1xuZnVuY3Rpb24gTWluaU1hcE5vZGVzKHsgbm9kZVN0cm9rZUNvbG9yID0gJ3RyYW5zcGFyZW50Jywgbm9kZUNvbG9yID0gJyNlMmUyZTInLCBub2RlQ2xhc3NOYW1lID0gJycsIG5vZGVCb3JkZXJSYWRpdXMgPSA1LCBub2RlU3Ryb2tlV2lkdGggPSAyLCBcbi8vIFdlIG5lZWQgdG8gcmVuYW1lIHRoZSBwcm9wIHRvIGJlIGBDYXBpdGFsQ2FzZWAgc28gdGhhdCBKU1ggd2lsbCByZW5kZXIgaXQgYXNcbi8vIGEgY29tcG9uZW50IHByb3Blcmx5Llxubm9kZUNvbXBvbmVudDogTm9kZUNvbXBvbmVudCA9IE1pbmlNYXBOb2RlJDEsIG9uQ2xpY2ssIH0pIHtcbiAgICBjb25zdCBub2RlcyA9IHVzZVN0b3JlKHNlbGVjdG9yTm9kZXMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG5vZGVPcmlnaW4gPSB1c2VTdG9yZShzZWxlY3RvciQxKTtcbiAgICBjb25zdCBub2RlQ29sb3JGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVDb2xvcik7XG4gICAgY29uc3Qgbm9kZVN0cm9rZUNvbG9yRnVuYyA9IGdldEF0dHJGdW5jdGlvbihub2RlU3Ryb2tlQ29sb3IpO1xuICAgIGNvbnN0IG5vZGVDbGFzc05hbWVGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVDbGFzc05hbWUpO1xuICAgIGNvbnN0IHNoYXBlUmVuZGVyaW5nID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgISF3aW5kb3cuY2hyb21lID8gJ2NyaXNwRWRnZXMnIDogJ2dlb21ldHJpY1ByZWNpc2lvbic7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBub2Rlcy5tYXAoKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKG5vZGUsIG5vZGVPcmlnaW4pLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChOb2RlQ29tcG9uZW50LCB7IGtleTogbm9kZS5pZCwgeDogeCwgeTogeSwgd2lkdGg6IG5vZGUud2lkdGgsIGhlaWdodDogbm9kZS5oZWlnaHQsIHN0eWxlOiBub2RlLnN0eWxlLCBzZWxlY3RlZDogbm9kZS5zZWxlY3RlZCwgY2xhc3NOYW1lOiBub2RlQ2xhc3NOYW1lRnVuYyhub2RlKSwgY29sb3I6IG5vZGVDb2xvckZ1bmMobm9kZSksIGJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgc3Ryb2tlQ29sb3I6IG5vZGVTdHJva2VDb2xvckZ1bmMobm9kZSksIHN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZywgb25DbGljazogb25DbGljaywgaWQ6IG5vZGUuaWQgfSkpO1xuICAgIH0pKSk7XG59XG52YXIgTWluaU1hcE5vZGVzJDEgPSBtZW1vKE1pbmlNYXBOb2Rlcyk7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAqL1xuY29uc3QgZGVmYXVsdFdpZHRoID0gMjAwO1xuY29uc3QgZGVmYXVsdEhlaWdodCA9IDE1MDtcbmNvbnN0IHNlbGVjdG9yID0gKHMpID0+IHtcbiAgICBjb25zdCBub2RlcyA9IHMuZ2V0Tm9kZXMoKTtcbiAgICBjb25zdCB2aWV3QkIgPSB7XG4gICAgICAgIHg6IC1zLnRyYW5zZm9ybVswXSAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICB5OiAtcy50cmFuc2Zvcm1bMV0gLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgd2lkdGg6IHMud2lkdGggLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgaGVpZ2h0OiBzLmhlaWdodCAvIHMudHJhbnNmb3JtWzJdLFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmlld0JCLFxuICAgICAgICBib3VuZGluZ1JlY3Q6IG5vZGVzLmxlbmd0aCA+IDAgPyBnZXRCb3VuZHNPZlJlY3RzKGdldE5vZGVzQm91bmRzKG5vZGVzLCBzLm5vZGVPcmlnaW4pLCB2aWV3QkIpIDogdmlld0JCLFxuICAgICAgICByZklkOiBzLnJmSWQsXG4gICAgfTtcbn07XG5jb25zdCBBUklBX0xBQkVMX0tFWSA9ICdyZWFjdC1mbG93X19taW5pbWFwLWRlc2MnO1xuZnVuY3Rpb24gTWluaU1hcCh7IHN0eWxlLCBjbGFzc05hbWUsIG5vZGVTdHJva2VDb2xvciA9ICd0cmFuc3BhcmVudCcsIG5vZGVDb2xvciA9ICcjZTJlMmUyJywgbm9kZUNsYXNzTmFtZSA9ICcnLCBub2RlQm9yZGVyUmFkaXVzID0gNSwgbm9kZVN0cm9rZVdpZHRoID0gMiwgXG4vLyBXZSBuZWVkIHRvIHJlbmFtZSB0aGUgcHJvcCB0byBiZSBgQ2FwaXRhbENhc2VgIHNvIHRoYXQgSlNYIHdpbGwgcmVuZGVyIGl0IGFzXG4vLyBhIGNvbXBvbmVudCBwcm9wZXJseS5cbm5vZGVDb21wb25lbnQsIG1hc2tDb2xvciA9ICdyZ2IoMjQwLCAyNDAsIDI0MCwgMC42KScsIG1hc2tTdHJva2VDb2xvciA9ICdub25lJywgbWFza1N0cm9rZVdpZHRoID0gMSwgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0Jywgb25DbGljaywgb25Ob2RlQ2xpY2ssIHBhbm5hYmxlID0gZmFsc2UsIHpvb21hYmxlID0gZmFsc2UsIGFyaWFMYWJlbCA9ICdSZWFjdCBGbG93IG1pbmkgbWFwJywgaW52ZXJzZVBhbiA9IGZhbHNlLCB6b29tU3RlcCA9IDEwLCBvZmZzZXRTY2FsZSA9IDUsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgc3ZnID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgYm91bmRpbmdSZWN0LCB2aWV3QkIsIHJmSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICBjb25zdCBlbGVtZW50V2lkdGggPSBzdHlsZT8ud2lkdGggPz8gZGVmYXVsdFdpZHRoO1xuICAgIGNvbnN0IGVsZW1lbnRIZWlnaHQgPSBzdHlsZT8uaGVpZ2h0ID8/IGRlZmF1bHRIZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBib3VuZGluZ1JlY3Qud2lkdGggLyBlbGVtZW50V2lkdGg7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gYm91bmRpbmdSZWN0LmhlaWdodCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29uc3Qgdmlld1NjYWxlID0gTWF0aC5tYXgoc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgY29uc3Qgdmlld1dpZHRoID0gdmlld1NjYWxlICogZWxlbWVudFdpZHRoO1xuICAgIGNvbnN0IHZpZXdIZWlnaHQgPSB2aWV3U2NhbGUgKiBlbGVtZW50SGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFNjYWxlICogdmlld1NjYWxlO1xuICAgIGNvbnN0IHggPSBib3VuZGluZ1JlY3QueCAtICh2aWV3V2lkdGggLSBib3VuZGluZ1JlY3Qud2lkdGgpIC8gMiAtIG9mZnNldDtcbiAgICBjb25zdCB5ID0gYm91bmRpbmdSZWN0LnkgLSAodmlld0hlaWdodCAtIGJvdW5kaW5nUmVjdC5oZWlnaHQpIC8gMiAtIG9mZnNldDtcbiAgICBjb25zdCB3aWR0aCA9IHZpZXdXaWR0aCArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgaGVpZ2h0ID0gdmlld0hlaWdodCArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgbGFiZWxsZWRCeSA9IGAke0FSSUFfTEFCRUxfS0VZfS0ke3JmSWR9YDtcbiAgICBjb25zdCB2aWV3U2NhbGVSZWYgPSB1c2VSZWYoMCk7XG4gICAgdmlld1NjYWxlUmVmLmN1cnJlbnQgPSB2aWV3U2NhbGU7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN2Zy5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3Qoc3ZnLmN1cnJlbnQpO1xuICAgICAgICAgICAgY29uc3Qgem9vbUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgZDNTZWxlY3Rpb24sIGQzWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ3doZWVsJyB8fCAhZDNTZWxlY3Rpb24gfHwgIWQzWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSAtZXZlbnQuc291cmNlRXZlbnQuZGVsdGFZICpcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50LnNvdXJjZUV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDAuMDUgOiBldmVudC5zb3VyY2VFdmVudC5kZWx0YU1vZGUgPyAxIDogMC4wMDIpICpcbiAgICAgICAgICAgICAgICAgICAgem9vbVN0ZXA7XG4gICAgICAgICAgICAgICAgY29uc3Qgem9vbSA9IHRyYW5zZm9ybVsyXSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEpO1xuICAgICAgICAgICAgICAgIGQzWm9vbS5zY2FsZVRvKGQzU2VsZWN0aW9uLCB6b29tKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwYW5IYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIGQzU2VsZWN0aW9uLCBkM1pvb20sIHRyYW5zbGF0ZUV4dGVudCwgd2lkdGgsIGhlaWdodCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ21vdXNlbW92ZScgfHwgIWQzU2VsZWN0aW9uIHx8ICFkM1pvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogaG93IHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCBuZXh0IHBvc2l0aW9uPyBNYXRoLm1heCgxLCB0cmFuc2Zvcm1bMl0pIGlzIGEgd29ya2Fyb3VuZC5cbiAgICAgICAgICAgICAgICBjb25zdCBtb3ZlU2NhbGUgPSB2aWV3U2NhbGVSZWYuY3VycmVudCAqIE1hdGgubWF4KDEsIHRyYW5zZm9ybVsyXSkgKiAoaW52ZXJzZVBhbiA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRyYW5zZm9ybVswXSAtIGV2ZW50LnNvdXJjZUV2ZW50Lm1vdmVtZW50WCAqIG1vdmVTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgeTogdHJhbnNmb3JtWzFdIC0gZXZlbnQuc291cmNlRXZlbnQubW92ZW1lbnRZICogbW92ZVNjYWxlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB6b29tSWRlbnRpdHkudHJhbnNsYXRlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpLnNjYWxlKHRyYW5zZm9ybVsyXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWluZWRUcmFuc2Zvcm0gPSBkM1pvb20uY29uc3RyYWluKCkobmV4dFRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICAgICAgICAgIGQzWm9vbS50cmFuc2Zvcm0oZDNTZWxlY3Rpb24sIGNvbnN0cmFpbmVkVHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB6b29tQW5kUGFuSGFuZGxlciA9IHpvb20oKVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAub24oJ3pvb20nLCBwYW5uYWJsZSA/IHBhbkhhbmRsZXIgOiBudWxsKVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAub24oJ3pvb20ud2hlZWwnLCB6b29tYWJsZSA/IHpvb21IYW5kbGVyIDogbnVsbCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uY2FsbCh6b29tQW5kUGFuSGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5vbignem9vbScsIG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtwYW5uYWJsZSwgem9vbWFibGUsIGludmVyc2VQYW4sIHpvb21TdGVwXSk7XG4gICAgY29uc3Qgb25TdmdDbGljayA9IG9uQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJmQ29vcmQgPSBwb2ludGVyKGV2ZW50KTtcbiAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIHsgeDogcmZDb29yZFswXSwgeTogcmZDb29yZFsxXSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvblN2Z05vZGVDbGljayA9IG9uTm9kZUNsaWNrXG4gICAgICAgID8gKGV2ZW50LCBub2RlSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVJbnRlcm5hbHMuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBvbk5vZGVDbGljayhldmVudCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFBhbmVsLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgc3R5bGU6IHN0eWxlLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbWluaW1hcCcsIGNsYXNzTmFtZV0pLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX21pbmltYXBcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgd2lkdGg6IGVsZW1lbnRXaWR0aCwgaGVpZ2h0OiBlbGVtZW50SGVpZ2h0LCB2aWV3Qm94OiBgJHt4fSAke3l9ICR7d2lkdGh9ICR7aGVpZ2h0fWAsIHJvbGU6IFwiaW1nXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkQnksIHJlZjogc3ZnLCBvbkNsaWNrOiBvblN2Z0NsaWNrIH0sXG4gICAgICAgICAgICBhcmlhTGFiZWwgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIHsgaWQ6IGxhYmVsbGVkQnkgfSwgYXJpYUxhYmVsKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWluaU1hcE5vZGVzJDEsIHsgb25DbGljazogb25TdmdOb2RlQ2xpY2ssIG5vZGVDb2xvcjogbm9kZUNvbG9yLCBub2RlU3Ryb2tlQ29sb3I6IG5vZGVTdHJva2VDb2xvciwgbm9kZUJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgbm9kZUNsYXNzTmFtZTogbm9kZUNsYXNzTmFtZSwgbm9kZVN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIG5vZGVDb21wb25lbnQ6IG5vZGVDb21wb25lbnQgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19taW5pbWFwLW1hc2tcIiwgZDogYE0ke3ggLSBvZmZzZXR9LCR7eSAtIG9mZnNldH1oJHt3aWR0aCArIG9mZnNldCAqIDJ9diR7aGVpZ2h0ICsgb2Zmc2V0ICogMn1oJHstd2lkdGggLSBvZmZzZXQgKiAyfXpcbiAgICAgICAgTSR7dmlld0JCLnh9LCR7dmlld0JCLnl9aCR7dmlld0JCLndpZHRofXYke3ZpZXdCQi5oZWlnaHR9aCR7LXZpZXdCQi53aWR0aH16YCwgZmlsbDogbWFza0NvbG9yLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIHN0cm9rZTogbWFza1N0cm9rZUNvbG9yLCBzdHJva2VXaWR0aDogbWFza1N0cm9rZVdpZHRoLCBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIiB9KSkpKTtcbn1cbk1pbmlNYXAuZGlzcGxheU5hbWUgPSAnTWluaU1hcCc7XG52YXIgTWluaU1hcCQxID0gbWVtbyhNaW5pTWFwKTtcblxuZXhwb3J0IHsgTWluaU1hcCQxIGFzIE1pbmlNYXAgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIm1lbW8iLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjYyIsInNoYWxsb3ciLCJ6b29tIiwiem9vbUlkZW50aXR5Iiwic2VsZWN0IiwicG9pbnRlciIsInVzZVN0b3JlIiwiZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbiIsInVzZVN0b3JlQXBpIiwiUGFuZWwiLCJnZXRCb3VuZHNPZlJlY3RzIiwiZ2V0Tm9kZXNCb3VuZHMiLCJNaW5pTWFwTm9kZSIsImlkIiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsInN0eWxlIiwiY29sb3IiLCJzdHJva2VDb2xvciIsInN0cm9rZVdpZHRoIiwiY2xhc3NOYW1lIiwiYm9yZGVyUmFkaXVzIiwic2hhcGVSZW5kZXJpbmciLCJvbkNsaWNrIiwic2VsZWN0ZWQiLCJiYWNrZ3JvdW5kIiwiYmFja2dyb3VuZENvbG9yIiwiZmlsbCIsImNyZWF0ZUVsZW1lbnQiLCJyeCIsInJ5Iiwic3Ryb2tlIiwiZXZlbnQiLCJ1bmRlZmluZWQiLCJkaXNwbGF5TmFtZSIsIk1pbmlNYXBOb2RlJDEiLCJzZWxlY3RvciQxIiwicyIsIm5vZGVPcmlnaW4iLCJzZWxlY3Rvck5vZGVzIiwiZ2V0Tm9kZXMiLCJmaWx0ZXIiLCJub2RlIiwiaGlkZGVuIiwiZ2V0QXR0ckZ1bmN0aW9uIiwiZnVuYyIsIkZ1bmN0aW9uIiwiTWluaU1hcE5vZGVzIiwibm9kZVN0cm9rZUNvbG9yIiwibm9kZUNvbG9yIiwibm9kZUNsYXNzTmFtZSIsIm5vZGVCb3JkZXJSYWRpdXMiLCJub2RlU3Ryb2tlV2lkdGgiLCJub2RlQ29tcG9uZW50IiwiTm9kZUNvbXBvbmVudCIsIm5vZGVzIiwibm9kZUNvbG9yRnVuYyIsIm5vZGVTdHJva2VDb2xvckZ1bmMiLCJub2RlQ2xhc3NOYW1lRnVuYyIsIndpbmRvdyIsImNocm9tZSIsIkZyYWdtZW50IiwibWFwIiwicG9zaXRpb25BYnNvbHV0ZSIsImtleSIsIk1pbmlNYXBOb2RlcyQxIiwiZGVmYXVsdFdpZHRoIiwiZGVmYXVsdEhlaWdodCIsInNlbGVjdG9yIiwidmlld0JCIiwidHJhbnNmb3JtIiwiYm91bmRpbmdSZWN0IiwibGVuZ3RoIiwicmZJZCIsIkFSSUFfTEFCRUxfS0VZIiwiTWluaU1hcCIsIm1hc2tDb2xvciIsIm1hc2tTdHJva2VDb2xvciIsIm1hc2tTdHJva2VXaWR0aCIsInBvc2l0aW9uIiwib25Ob2RlQ2xpY2siLCJwYW5uYWJsZSIsInpvb21hYmxlIiwiYXJpYUxhYmVsIiwiaW52ZXJzZVBhbiIsInpvb21TdGVwIiwib2Zmc2V0U2NhbGUiLCJzdG9yZSIsInN2ZyIsImVsZW1lbnRXaWR0aCIsImVsZW1lbnRIZWlnaHQiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInZpZXdTY2FsZSIsIk1hdGgiLCJtYXgiLCJ2aWV3V2lkdGgiLCJ2aWV3SGVpZ2h0Iiwib2Zmc2V0IiwibGFiZWxsZWRCeSIsInZpZXdTY2FsZVJlZiIsImN1cnJlbnQiLCJzZWxlY3Rpb24iLCJ6b29tSGFuZGxlciIsImQzU2VsZWN0aW9uIiwiZDNab29tIiwiZ2V0U3RhdGUiLCJzb3VyY2VFdmVudCIsInR5cGUiLCJwaW5jaERlbHRhIiwiZGVsdGFZIiwiZGVsdGFNb2RlIiwicG93Iiwic2NhbGVUbyIsInBhbkhhbmRsZXIiLCJ0cmFuc2xhdGVFeHRlbnQiLCJtb3ZlU2NhbGUiLCJtb3ZlbWVudFgiLCJtb3ZlbWVudFkiLCJleHRlbnQiLCJuZXh0VHJhbnNmb3JtIiwidHJhbnNsYXRlIiwic2NhbGUiLCJjb25zdHJhaW5lZFRyYW5zZm9ybSIsImNvbnN0cmFpbiIsInpvb21BbmRQYW5IYW5kbGVyIiwib24iLCJjYWxsIiwib25TdmdDbGljayIsInJmQ29vcmQiLCJvblN2Z05vZGVDbGljayIsIm5vZGVJZCIsIm5vZGVJbnRlcm5hbHMiLCJnZXQiLCJ2aWV3Qm94Iiwicm9sZSIsInJlZiIsImQiLCJmaWxsUnVsZSIsInBvaW50ZXJFdmVudHMiLCJNaW5pTWFwJDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reactflow/minimap/dist/esm/index.mjs\n");

/***/ })

};
;